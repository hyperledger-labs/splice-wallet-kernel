## CIP-0094: dApp Standard

<pre>
  CIP: 0094
  Title: dApp Standard
  Author: Marc Juchli (Digital Asset), Eugene Birski (PixelPlex)
  Status: Draft
  Type: <Standards Track | Tokenomics | Process | Informational>
  Created: 2025-11-28
  License: CC0-1.0
  Post-History: https://lists.sync.global/g/cip-discuss/topic/cip_tbd_dapp_api_towards/115892502
</pre>

## Abstract

This proposal introduces a vendor-neutral **dApp API** that decouples network connectivity and key management from decentralized applications, while providing a standardized set of primitives for interacting with the Canton Network.

Using the dApp API, users can interact with any dApp via the validator and signing provider of their choice. In this model, dApps are used in conjunction with **Wallets**, which implement the API, are trusted by the user, and enforce authorization to prevent phishing from untrusted dApps.

The design emphasizes a **minimal, interoperable surface** with strict and unambiguous semantics for requests, responses, and errors, while remaining flexible enough to support varying Wallet architectures and deployment models.

As a result, dApps built by one provider can seamlessly interoperate with Wallets built by another.

## Copyright

This CIP is licensed under CC0-1.0: [Creative Commons CC0 1.0 Universal](https://creativecommons.org/publicdomain/zero/1.0/)

## Motivation

Today, dApps built for the Canton Network are tightly coupled to specific networking stacks, key-management setups, and wallet integrations. The lack of a unified standard forces developers to repeatedly reimplement similar patterns, limits interoperability, and constrains user choice. Users cannot easily select the validator or signing provider they trust, while developers must maintain multiple ad-hoc integration paths. This fragmentation introduces unnecessary friction, increases integration effort, and elevates security risks.

Existing interfaces, such as gRPC and JSON-Ledger APIs, provide low-level protocol access but do not address higher-level concerns: standard signing flows, user consent, phishing resistance, cross-origin communication, or consistent error semantics. Without a formal standard, wallets and applications cannot reliably interoperate, preventing a healthy multi-provider ecosystem and hindering modular innovation.

To address these challenges, the **dApp API** introduces a **vendor-neutral, transport-agnostic framework** for Canton-native dApps. By defining a shared interface for ledger interaction, transaction submission, and message signing, the API decouples dApps from wallet implementations while preserving security guarantees. Users can connect through any validator and sign using the method of their choice, while wallets enforce authorization to prevent misbinding and phishing from untrusted dApps. The API is also designed to accommodate future wallets, custody solutions, and deployment models, ensuring that new implementations can interoperate seamlessly with existing dApps and infrastructure.

The API is designed for three primary client categories:

1. **Wallet and custody solution providers**
   Responsible for identity, authorization, and signing. They implement the dApp API to enable secure user interaction with dApps.

2. **User-facing dApps**
   Expose on-ledger actions (transfers, settlements, governance, etc.) through web or mobile interfaces.

3. **Application backends**
   Programmatically issue, query, and manage contracts on the Canton ledger.

The design emphasizes the following characteristics:

- **Transport-agnostic**
  Any dApp (client) can interact with any wallet (server), independent of implementation or transport.

- **Signing-provider agnostic**
  Supports internal and external signing, independent of private key location.

- **Multi-network support**
  Users may connect to any validator or participant node.

- **Minimal operation set**
  Standardizes primitives for ledger reads, ledger writes, and message signing.

- **Deterministic error model**
  Standardized error codes ensure predictable control flow and consistent telemetry.

- **Secure and phishing-resilient**
  Private keys remain within the signing provider; user authorization is enforced and attack surfaces are minimized.

This CIP draws inspiration from widely adopted standards such as **EIP-1193**, while addressing Canton-specific requirements: privacy-preserving participants, multi-party workflows, and synchronized settlement. The dApp API can also be **wrapped in a provider object**, similar to Ethereum, allowing dApps to interact with a Wallet through a familiar interface. By providing a portable, secure, and interoperable foundation, the dApp API enables any wallet to reliably interact with any dApp, reduces developer friction, improves user security, and supports a robust, modular Canton ecosystem.

## Specification

The technical specification should describe the syntax and semantics of any new feature. The specification should be detailed enough to allow competing, interoperable implementations for any of the current Global Synchronizer platforms.

### Definitions

This section defines the terms used normatively throughout the specification. Each term is scoped to this CIP and, unless stated otherwise, applies to all methods, transports, and UX requirements. The goal is to ensure unambiguous meaning so that independent wallets and dApps interpret the interface consistently.

| Term      | Definition                                                                                | Notes                                                                                   |
| --------- | ----------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- |
| `Client`  | Invokes RPC methods defined as part of the dApp API                                       | Client adheres to the JSON-RPC specification but defines the transport method           |
| `dApp`    | Application (oftentimes web) that consumes the dApp API                                   | Can do so via a client                                                                  |
| `Network` | Canton environment                                                                        | Uniquely defined by: (Validator, Synchronizer, Authentication details)                  |
| `Wallet`  | Provides the dApp API. Middleware between client and network as well as signing provider. | Implementation details are out of scope; MUST honor methods/events, UX, and error codes |

### Provider API

The Provider API defines a set of methods that enable the uniform usage of the dApp API (see below). The methods in this interface are an exact replica of the Provider API defined in [EIP-1193](https://eips.ethereum.org/EIPS/eip-1193).

Below is the interface description in Typescript. Interface definitions in other languages that replicate the methods are equaly valid:

```typescript
type EventListener<T> = (...args: T[]) => void

type RequestParams = unknown[] | Record<string, unknown>

interface RequestPayload {
    method: string
    params?: RequestParams
}

interface Provider {
    request<T>(args: RequestPayload): Promise<T>
    on<T>(event: string, listener: EventListener<T>): Provider
    emit<T>(event: string, ...args: T[]): boolean
    removeListener<T>(
        event: string,
        listenerToRemove: EventListener<T>
    ): Provider
}
```

Using the interface above, dApp API requests are issued by specifying the appropriate `method` and corresponding `params` as defined in this specification. Similarly, dApp API events can be consumed by registering a listener for the corresponding `event`.

#### Error Types

It is the Providerâ€™s responsibility to enforce a consistent error format. As noted above, this CIP adopts the conventions defined in EIP-1193, with error structure and codes further aligned with [EIP-1474](https://eips.ethereum.org/EIPS/eip-1474#error-codes):

```typescript
interface ProviderRpcError extends Error {
    message: string
    code: number
    data?: unknown
}
```

Error member included on the response object **MUST** be an object containing a `code` member and descriptive `message` member.

In addition to defining the error format, this CIP incorporates the error codes specified in EIP-1474. To ensure consistency with established ecosystem conventions, the following table enumerates all supported error codes and their corresponding messages:

| Code   | Message                        | Meaning                                       | Category     |
| ------ | ------------------------------ | --------------------------------------------- | ------------ |
| -32700 | Parse error                    | Invalid JSON                                  | standard     |
| -32600 | Invalid request                | JSON is not a valid request object            | standard     |
| -32601 | Method not found               | Method does not exist                         | standard     |
| -32602 | Invalid params                 | Invalid method parameters                     | standard     |
| -32603 | Internal error                 | Internal JSON-RPC error                       | standard     |
| -32000 | Invalid input                  | Missing or invalid parameters                 | non-standard |
| -32001 | Resource not found             | Requested resource not found                  | non-standard |
| -32002 | Resource unavailable           | Requested resource not available              | non-standard |
| -32003 | Transaction rejected           | Transaction creation failed                   | non-standard |
| -32004 | Method not supported           | Method is not implemented                     | non-standard |
| -32005 | Limit exceeded                 | Request exceeds defined limit                 | non-standard |
| -32006 | JSON-RPC version not supported | Version of JSON-RPC protocol is not supported | non-standard |

### dApp API

This section defines the methods and events that **MUST** be implemented by the dApp API providers. The API is defined in a transport-agnostic way using the [OpenRPC](https://www.open-rpc.org/) specification format.

Overview of methods:

| Method              | Output             | Notes                                                           |
| ------------------- | ------------------ | --------------------------------------------------------------- |
| `connect`           | `boolean`          | Establishes a connection to the server (e.g. Wallet)            |
| `disconnect`        | `void`             | Closes the session between the client and the provider          |
| `isConnected`       | `boolean`          | Indicates connectivity to the server (e.g. Wallet)              |
| `status`            | `StatusEvent`      | Contains information regarding the connected Wallet and Network |
| `getActiveNetwork`  | `Network`          | Details of connected network                                    |
| `listPackages`      | `Package[]`        | Lists DARs vetted on the connected participant node             |
| `listAccounts`      | `Wallet[]`         | Lists all Wallets/Accounts                                      |
| `getPrimaryAccount` | `Wallet`           | Single Wallet/Account that is subject to the dApp               |
| `signMessage`       | `string`           | Signs an arbitrary string                                       |
| `submitCommands`    | `Void`             | Prepares, signs and executes the commands                       |
| `ledgerApi`         | `string \| object` | Proxies Ledger API                                              |

Overview of events:

| Event               | Paylaod                | Notes                                                                                                                                                    |
| ------------------- | ---------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `onAccountsChanged` | `AccountsChangedEvent` | Contains all the accounts known to the provider and states which one is currently the primary account.                                                   |
| `onStatusChanged`   | `StatusEvent`          | Informs about the status of the provider the client is connected to; for example whether or not the user is authenticated and/or connected to a network. |
| `onTxChanged`       | `TxChangedEvent`       | Announces changes about the lifecycle of initiated transactions.                                                                                         |

### Discovery

## Rationale

The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work. The rationale should provide evidence of consensus within the community and discuss important objections or concerns raised during discussion.

- A JavaScript object made available to a consumer, that provides access to Ethereum by means of a Client.

## Backwards compatibility

All CIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The CIP must explain how the author proposes to deal with these incompatibilities.

## Reference implementation

The reference implementation must be completed before any CIP is given status "Final", but it need not be completed before the CIP is accepted. It is better to finish the specification and rationale first and reach consensus on it before writing code. The final implementation must include test code and documentation appropriate for the Global Synchronizer protocol.
