// Code generated by @open-rpc/generator DO NOT EDIT.
import _ from 'lodash'

import { RequestArgs, RequestPayload } from '@canton-network/core-types'
import { RpcTransport } from '@canton-network/core-rpc-transport'

/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 *
 * Network ID
 *
 */
export type NetworkId = string
/**
 *
 * Name of network
 *
 */
export type Name = string
/**
 *
 * Description of network
 *
 */
export type Description = string
/**
 *
 * Synchronizer ID
 *
 */
export type SynchronizerId = string
/**
 *
 * Identity Provider ID
 *
 */
export type IdentityProviderId = string
export type Method = string
export type Scope = string
export type ClientId = string
export type ClientSecret = string
/**
 *
 * Issuer of identity provider
 *
 */
export type Issuer = string
export type Audience = string
/**
 *
 * Represents the type of auth for a specified network
 *
 */
export interface Auth {
    method: Method
    scope: Scope
    clientId: ClientId
    clientSecret?: ClientSecret
    issuer?: Issuer
    audience: Audience
}
/**
 *
 * Ledger api url
 *
 */
export type LedgerApi = string
/**
 *
 * Structure representing the Networks
 *
 */
export interface Network {
    id: NetworkId
    name: Name
    description: Description
    synchronizerId?: SynchronizerId
    identityProviderId: IdentityProviderId
    auth: Auth
    adminAuth?: Auth
    ledgerApi: LedgerApi
}
/**
 *
 * Ledger api url
 *
 */
export type NetworkName = string
/**
 *
 * ID of the identity provider
 *
 */
export type Id = string
/**
 *
 * Type of identity provider (oauth / self_signed)
 *
 */
export type Type = any
/**
 *
 * The configuration URL for the identity provider.
 *
 */
export type ConfigUrl = string
/**
 *
 * Structure representing the Identity Providers
 *
 */
export interface Idp {
    id: Id
    type: Type
    issuer: Issuer
    configUrl?: ConfigUrl
}
/**
 *
 * Set as primary wallet for dApp usage.
 *
 */
export type Primary = boolean
/**
 *
 * The party hint and name of the wallet.
 *
 */
export type PartyHint = string
/**
 *
 * The signing provider ID the wallet corresponds to.
 *
 */
export type SigningProviderId = string
export type PartyId = string
/**
 *
 * Unique identifier of the signed transaction given by the Signing Provider. This may not be the same as the internal txId given by the Wallet Gateway.
 *
 */
export type ExternalTxId = string
/**
 *
 * The topology transactions
 *
 */
export type TopologyTransactions = string
/**
 *
 * The namespace of the party.
 *
 */
export type Namespace = string
/**
 *
 * Indicates that the wallet has been created in the database but hasn't yet been allocated by the participant.
 *
 */
export interface SigningProviderContext {
    partyId: PartyId
    externalTxId: ExternalTxId
    topologyTransactions: TopologyTransactions
    namespace: Namespace
}
/**
 *
 * Filter wallets by network IDs.
 *
 */
export type NetworkIds = NetworkId[]
/**
 *
 * Filter wallets by signing provider IDs.
 *
 */
export type SigningProviderIds = SigningProviderId[]
/**
 *
 * Filter for the wallets to be returned.
 *
 */
export interface WalletFilter {
    networkIds?: NetworkIds
    signingProviderIds?: SigningProviderIds
}
/**
 *
 * The transaction data corresponding to the command ID.
 *
 */
export type PreparedTransaction = string
/**
 *
 * The hash of the prepared transaction.
 *
 */
export type PreparedTransactionHash = string
/**
 *
 * The unique identifier of the command associated with the transaction.
 *
 */
export type CommandId = string
export type Signature = string
export type SignedBy = string
export type Networks = Network[]
export type Idps = Idp[]
/**
 *
 * The status of the wallet.
 *
 */
export type WalletStatus = 'initialized' | 'allocated'
/**
 *
 * The party hint and name of the wallet.
 *
 */
export type Hint = string
/**
 *
 * The public key of the party.
 *
 */
export type PublicKey = string
/**
 *
 * Whether the wallet is disabled. Wallets are disabled when no signing provider matches the party's namespace during sync. Disabled wallets use participant as the default signing provider.
 *
 */
export type Disabled = boolean
/**
 *
 * The reason for the current status.
 *
 */
export type Reason = string
/**
 *
 * Structure representing a wallet
 *
 */
export interface Wallet {
    primary: Primary
    partyId: PartyId
    status: WalletStatus
    hint: Hint
    publicKey: PublicKey
    namespace: Namespace
    networkId: NetworkId
    signingProviderId: SigningProviderId
    externalTxId?: ExternalTxId
    topologyTransactions?: TopologyTransactions
    disabled?: Disabled
    reason?: Reason
}
type AlwaysTrue = any
export type Added = Wallet[]
export type Removed = Wallet[]
/**
 *
 * Whether wallet sync is needed. Returns true if there are disabled wallets or parties on the ledger that aren't in the store.
 *
 */
export type WalletSyncNeeded = boolean
/**
 *
 * The access token for the session.
 *
 */
export type AccessToken = string
/**
 *
 * The status of the transaction.
 *
 */
export type Status = string
/**
 *
 * Structure representing the connected network session
 *
 */
export interface Session {
    id: Id
    network: Network
    idp: Idp
    accessToken: AccessToken
    status: Status
    reason?: Reason
}
export type Sessions = Session[]
/**
 *
 * The timestamp when the transaction was created.
 *
 */
export type CreatedAt = string
/**
 *
 * The timestamp when the transaction was signed.
 *
 */
export type SignedAt = string
/**
 *
 * Optional payload associated with the transaction.
 *
 */
export type Payload = string
/**
 *
 * The origin (dApp URL) that initiated this transaction request.
 *
 */
export type Origin = string
export interface Transaction {
    commandId: CommandId
    status: Status
    createdAt?: CreatedAt
    signedAt?: SignedAt
    preparedTransaction: PreparedTransaction
    preparedTransactionHash: PreparedTransactionHash
    payload?: Payload
    origin?: Origin
}
export type Transactions = Transaction[]
export interface AddNetworkParams {
    network: Network
}
export interface RemoveNetworkParams {
    networkName: NetworkName
}
export interface AddIdpParams {
    idp: Idp
}
export interface RemoveIdpParams {
    identityProviderId: IdentityProviderId
}
export interface CreateWalletParams {
    primary?: Primary
    partyHint: PartyHint
    signingProviderId: SigningProviderId
    signingProviderContext?: SigningProviderContext
}
export interface SetPrimaryWalletParams {
    partyId: PartyId
}
export interface RemoveWalletParams {
    partyId: PartyId
}
export interface ListWalletsParams {
    filter?: WalletFilter
}
export interface SignParams {
    preparedTransaction: PreparedTransaction
    preparedTransactionHash: PreparedTransactionHash
    commandId: CommandId
    partyId: PartyId
}
export interface ExecuteParams {
    signature: Signature
    partyId: PartyId
    commandId: CommandId
    signedBy: SignedBy
}
export interface AddSessionParams {
    networkId: NetworkId
}
export interface GetTransactionParams {
    commandId: CommandId
}
export interface DeleteTransactionParams {
    commandId: CommandId
}
/**
 *
 * Represents a null value, used in responses where no data is returned.
 *
 */
export type Null = null
export interface ListNetworksResult {
    networks: Networks
}
export interface ListIdpsResult {
    idps: Idps
}
export interface CreateWalletResult {
    wallet: Wallet
    [k: string]: any
}
export interface RemovePartyResult {
    [key: string]: any
}
/**
 *
 * An array of wallets that match the filter criteria.
 *
 */
export type ListWalletsResult = Wallet[]
/**
 *
 * Added and removed wallets as a result of the sync.
 *
 */
export interface SyncWalletsResult {
    added: Added
    removed: Removed
}
export interface IsWalletSyncNeededResult {
    walletSyncNeeded: WalletSyncNeeded
}
export interface SignResult {
    signature: Signature
    partyId: PartyId
    signedBy: SignedBy
}
export interface ExecuteResult {
    [key: string]: any
}
/**
 *
 * Structure representing the connected network session
 *
 */
export interface AddSessionResult {
    id: Id
    network: Network
    idp: Idp
    accessToken: AccessToken
    status: Status
    reason?: Reason
}
export interface ListSessionsResult {
    sessions: Sessions
}
export interface GetTransactionResult {
    commandId: CommandId
    status: Status
    createdAt?: CreatedAt
    signedAt?: SignedAt
    preparedTransaction: PreparedTransaction
    preparedTransactionHash: PreparedTransactionHash
    payload?: Payload
    origin?: Origin
}
export interface ListTransactionsResult {
    transactions: Transactions
}
/**
 *
 * Generated! Represents an alias to any of the provided schemas
 *
 */

export type AddNetwork = (params: AddNetworkParams) => Promise<Null>
export type RemoveNetwork = (params: RemoveNetworkParams) => Promise<Null>
export type ListNetworks = () => Promise<ListNetworksResult>
export type AddIdp = (params: AddIdpParams) => Promise<Null>
export type RemoveIdp = (params: RemoveIdpParams) => Promise<Null>
export type ListIdps = () => Promise<ListIdpsResult>
export type CreateWallet = (
    params: CreateWalletParams
) => Promise<CreateWalletResult>
export type SetPrimaryWallet = (params: SetPrimaryWalletParams) => Promise<Null>
export type RemoveWallet = (
    params: RemoveWalletParams
) => Promise<RemovePartyResult>
export type ListWallets = (
    params: ListWalletsParams
) => Promise<ListWalletsResult>
export type SyncWallets = () => Promise<SyncWalletsResult>
export type IsWalletSyncNeeded = () => Promise<IsWalletSyncNeededResult>
export type Sign = (params: SignParams) => Promise<SignResult>
export type Execute = (params: ExecuteParams) => Promise<ExecuteResult>
export type AddSession = (params: AddSessionParams) => Promise<AddSessionResult>
export type RemoveSession = () => Promise<Null>
export type ListSessions = () => Promise<ListSessionsResult>
export type GetTransaction = (
    params: GetTransactionParams
) => Promise<GetTransactionResult>
export type ListTransactions = () => Promise<ListTransactionsResult>
export type DeleteTransaction = (
    params: DeleteTransactionParams
) => Promise<Null>
/* eslint-enable @typescript-eslint/no-unused-vars */

type Params<T> = T extends (...args: infer A) => any
    ? A extends []
        ? never
        : A[0]
    : never
type Result<T> = T extends (...args: any[]) => Promise<infer R> ? R : never

export type RpcTypes = {
    addNetwork: {
        params: Params<AddNetwork>
        result: Result<AddNetwork>
    }

    removeNetwork: {
        params: Params<RemoveNetwork>
        result: Result<RemoveNetwork>
    }

    listNetworks: {
        params: Params<ListNetworks>
        result: Result<ListNetworks>
    }

    addIdp: {
        params: Params<AddIdp>
        result: Result<AddIdp>
    }

    removeIdp: {
        params: Params<RemoveIdp>
        result: Result<RemoveIdp>
    }

    listIdps: {
        params: Params<ListIdps>
        result: Result<ListIdps>
    }

    createWallet: {
        params: Params<CreateWallet>
        result: Result<CreateWallet>
    }

    setPrimaryWallet: {
        params: Params<SetPrimaryWallet>
        result: Result<SetPrimaryWallet>
    }

    removeWallet: {
        params: Params<RemoveWallet>
        result: Result<RemoveWallet>
    }

    listWallets: {
        params: Params<ListWallets>
        result: Result<ListWallets>
    }

    syncWallets: {
        params: Params<SyncWallets>
        result: Result<SyncWallets>
    }

    isWalletSyncNeeded: {
        params: Params<IsWalletSyncNeeded>
        result: Result<IsWalletSyncNeeded>
    }

    sign: {
        params: Params<Sign>
        result: Result<Sign>
    }

    execute: {
        params: Params<Execute>
        result: Result<Execute>
    }

    addSession: {
        params: Params<AddSession>
        result: Result<AddSession>
    }

    removeSession: {
        params: Params<RemoveSession>
        result: Result<RemoveSession>
    }

    listSessions: {
        params: Params<ListSessions>
        result: Result<ListSessions>
    }

    getTransaction: {
        params: Params<GetTransaction>
        result: Result<GetTransaction>
    }

    listTransactions: {
        params: Params<ListTransactions>
        result: Result<ListTransactions>
    }

    deleteTransaction: {
        params: Params<DeleteTransaction>
        result: Result<DeleteTransaction>
    }
}

export class SpliceWalletJSONRPCUserAPI {
    public transport: RpcTransport

    constructor(transport: RpcTransport) {
        this.transport = transport
    }

    public async request<M extends keyof RpcTypes>(
        args: RequestArgs<RpcTypes, M>
    ): Promise<RpcTypes[M]['result']> {
        const response = await this.transport.submit(args as RequestPayload)

        if ('error' in response) {
            throw new Error(
                'RPC error: ' +
                    response.error.code +
                    ' - ' +
                    response.error.message
            )
        } else {
            return response.result as RpcTypes[M]['result']
        }
    }
}
export default SpliceWalletJSONRPCUserAPI
