// Copyright (c) 2025-2026 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

import * as path from 'path'
import { move } from 'fs-extra'
import { IHooks } from './types'
import { readFile } from 'fs-extra'
import * as fs from 'fs'
import { promisify } from 'util'
const writeFile = promisify(fs.writeFile)
import TOML from '@iarna/toml'
import { template } from 'lodash'
import { execSync } from 'child_process'

const tsTemplate = template(`
// Code generated by @open-rpc/generator DO NOT EDIT.
import _ from "lodash";

import { RequestPayload, RequestArgsV2 } from '@canton-network/core-types'
import { RpcTransport } from '@canton-network/core-rpc-transport'

<%= methodTypings.toString("typescript").replace(/export type AnyOf[A-Za-z0-9]+ =(?:[\\r\\n]|.)*?;/gm, "") %>

type Params<T> = T extends (...args: infer A) => any ? A extends [] ? never : A[0] : never;
type Result<T> = T extends (...args: any[]) => Promise<infer R> ? R : never;

export type RpcTypes = {
  <% openrpcDocument.methods.forEach((method) => { %>
    <%= method.name %>: {
        params: Params<<%= _.upperFirst(method.name) %>>
        result: Result<<%= _.upperFirst(method.name) %>>
    }
  <% }); %>
};

export class <%= className %> {
  public transport: RpcTransport;

  constructor(transport: RpcTransport) {
    this.transport = transport;
  }

  <% openrpcDocument.methods.forEach((method) => { %>
  /**
   * <%= method.summary %>
   */
  // tslint:disable-next-line:max-line-length
  public async request(method: "<%= method.name %>", ...params: Parameters<<%= _.upperFirst(method.name) %>>): ReturnType<<%= _.upperFirst(method.name) %>>
  <% }); %>
  public async request(method: string, params?: RequestPayload['params']): Promise<unknown> {
    const response = await this.transport.submit({ method, params });

    if ('error' in response) {
        throw new Error('RPC error: ' + response.error.code + ' - ' + response.error.message);
    } else {
        return response.result;
    }
  }

  public async requestV2<M extends keyof RpcTypes>(args: RequestArgsV2<RpcTypes, M>): Promise<RpcTypes[M]['result']> {
    const response = await this.transport.submit(args as RequestPayload);

    if ('error' in response) {
        throw new Error('RPC error: ' + response.error.code + ' - ' + response.error.message);
    } else {
        return response.result as RpcTypes[M]['result'];
    }
  }
}
export default <%= className %>;
`)

const rsTemplate = template(`
#[macro_use]
extern crate jsonrpc_client_core;

<%= methodTypings.toString("rust", { includeSchemaTypings: true, includeMethodAliasTypings: false }) %>

jsonrpc_client!(pub struct <%= className %> {
<%= methodTypings.toString("rust", { includeSchemaTypings: false, includeMethodAliasTypings: true }) %>
});
`)

export const stripAnyOfTypes = (content: string): string => {
    return content.replace(/export type AnyOf[A-Za-z0-9]+ =[\s\S]*?;/gm, '')
}

const versionMap = new Map<string, string>()

// Derives the repository directory path from the destination path relative to repo root
const getRepositoryDirectory = (destPath: string): string | null => {
    let currentPath = destPath
    const maxDepth = 10
    for (let i = 0; i < maxDepth; i++) {
        const packageJsonPath = path.join(currentPath, 'package.json')
        try {
            if (fs.existsSync(packageJsonPath)) {
                const pkgContent = fs.readFileSync(packageJsonPath, 'utf-8')
                const pkg = JSON.parse(pkgContent)
                if (pkg.workspaces || pkg.name === 'splice-wallet-kernel') {
                    const relativePath = path.relative(currentPath, destPath)
                    return relativePath.replace(/\\/g, '/') // Normalize to forward slashes
                }
            }
        } catch {
            // Continue searching
        }
        const parentPath = path.dirname(currentPath)
        if (parentPath === currentPath) {
            break
        }
        currentPath = parentPath
    }
    return null
}

const hooks: IHooks = {
    afterCopyStatic: [
        async (dest, frm, component): Promise<void> => {
            if (component.language === 'typescript') {
                return await move(
                    path.join(dest, '_package.json'),
                    path.join(dest, 'package.json'),
                    {
                        overwrite: true,
                    }
                )
            }
        },
    ],
    beforeCopyStatic: [
        async (dest, frm, component): Promise<void> => {
            if (component.language === 'typescript') {
                const packagePath = path.join(dest, 'package.json')
                const fileContents = await readFile(packagePath)
                const pkg = JSON.parse(fileContents.toString())
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const currentVersion = (pkg as any).version
                versionMap.set(component.name, currentVersion!)
            }
        },
    ],
    afterCompileTemplate: [
        async (dest, frm, component, openrpcDocument): Promise<void> => {
            if (component.language === 'typescript') {
                const packagePath = path.join(dest, 'package.json')
                const fileContents = await readFile(packagePath)
                const pkg = JSON.parse(fileContents.toString())
                const updatedPkgObj: Record<string, unknown> = {
                    ...pkg,
                    name: component.name,
                    version:
                        versionMap.get(component.name) ??
                        openrpcDocument.info.version,
                }

                const repositoryDirectory = getRepositoryDirectory(dest)
                if (repositoryDirectory) {
                    updatedPkgObj.repository = {
                        type: 'git',
                        url: 'git+https://github.com/hyperledger-labs/splice-wallet-kernel.git',
                        directory: repositoryDirectory,
                    }
                }
                // else - fallback to repository field in template
                const updatedPkg = JSON.stringify(updatedPkgObj)
                execSync(`yarn prettier --write ${dest}/src/**/*`)
                return await writeFile(packagePath, updatedPkg)
            }
            if (component.language === 'rust') {
                const cargoTOMLPath = path.join(dest, 'Cargo.toml')
                const fileContents = await readFile(cargoTOMLPath)
                const cargoTOML = TOML.parse(fileContents.toString())
                const updatedCargo = TOML.stringify({
                    ...cargoTOML,
                    package: {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        ...(cargoTOML.package as any),
                        name: component.name,
                        version: openrpcDocument.info.version,
                    },
                })
                return await writeFile(cargoTOMLPath, updatedCargo)
            }
        },
    ],
    templateFiles: {
        typescript: [
            {
                path: 'src/index.ts',
                template: tsTemplate,
            },
        ],
        rust: [
            {
                path: 'src/index.rs',
                template: rsTemplate,
            },
        ],
    },
}

module.exports = {
    hooks,
    staticPath: () =>
        path.join(__dirname, '../../templates/client/typescript/'),
}
