// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/digitalasset/canton/topology/admin/v30/topology_manager_write_service.proto" (package "com.digitalasset.canton.topology.admin.v30", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import { ServiceType } from '@protobuf-ts/runtime-rpc'
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { StoreId_Temporary } from './common.js'
import { SignedTopologyTransaction } from '../../../protocol/v30/topology.js'
import { Duration } from '../../../../../../google/protobuf/duration.js'
import { StoreId } from './common.js'
import { TopologyMapping } from '../../../protocol/v30/topology.js'
import { Enums_TopologyChangeOp } from '../../../protocol/v30/topology.js'
/**
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.GenerateTransactionsRequest
 */
export interface GenerateTransactionsRequest {
    /**
     * transaction proposals for which to generate topology transactions
     *
     * @generated from protobuf field: repeated com.digitalasset.canton.topology.admin.v30.GenerateTransactionsRequest.Proposal proposals = 1
     */
    proposals: GenerateTransactionsRequest_Proposal[]
}
/**
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.GenerateTransactionsRequest.Proposal
 */
export interface GenerateTransactionsRequest_Proposal {
    /**
     * * Replace / Remove
     *
     * @generated from protobuf field: com.digitalasset.canton.protocol.v30.Enums.TopologyChangeOp operation = 1
     */
    operation: Enums_TopologyChangeOp
    /**
     * * Optionally, the serial number of this request (auto-determined if omitted)
     * NOTE: omitting the serial MAY end up overwriting previous mappings processed concurrently.
     * To avoid such cases, First read the state using the TopologyManagerReadService and update the mappings
     * accordingly, incrementing the serial by one and setting it here explicitly.
     *
     * @generated from protobuf field: uint32 serial = 2
     */
    serial: number
    /**
     * * The mapping to be authorized
     *
     * @generated from protobuf field: com.digitalasset.canton.protocol.v30.TopologyMapping mapping = 3
     */
    mapping?: TopologyMapping
    /**
     * Target store
     *
     * @generated from protobuf field: com.digitalasset.canton.topology.admin.v30.StoreId store = 4
     */
    store?: StoreId
}
/**
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.GenerateTransactionsResponse
 */
export interface GenerateTransactionsResponse {
    /**
     * Generated transactions, in the same order as the mappings provided in the request
     *
     * @generated from protobuf field: repeated com.digitalasset.canton.topology.admin.v30.GenerateTransactionsResponse.GeneratedTransaction generated_transactions = 1
     */
    generatedTransactions: GenerateTransactionsResponse_GeneratedTransaction[]
}
/**
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.GenerateTransactionsResponse.GeneratedTransaction
 */
export interface GenerateTransactionsResponse_GeneratedTransaction {
    /**
     * Serialized com.digitalasset.canton.protocol.v30.TopologyTransaction
     *
     * @generated from protobuf field: bytes serialized_transaction = 1
     */
    serializedTransaction: Uint8Array
    /**
     * Hash of the transaction - this should be signed by the submitter to authorize the transaction
     *
     * @generated from protobuf field: bytes transaction_hash = 2
     */
    transactionHash: Uint8Array
}
/**
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.AuthorizeRequest
 */
export interface AuthorizeRequest {
    /**
     * @generated from protobuf oneof: type
     */
    type:
        | {
              oneofKind: 'proposal'
              /**
               * *
               * Propose a transaction and distribute it.
               * If authorize if the node has enough signing keys
               *
               * @generated from protobuf field: com.digitalasset.canton.topology.admin.v30.AuthorizeRequest.Proposal proposal = 1
               */
              proposal: AuthorizeRequest_Proposal
          }
        | {
              oneofKind: 'transactionHash'
              /**
               * *
               * Authorize a transaction, meaning the node needs to be able to fully sign it locally.
               * Hash is in hexadecimal format.
               *
               * @generated from protobuf field: string transaction_hash = 2
               */
              transactionHash: string
          }
        | {
              oneofKind: undefined
          }
    /**
     * *
     * If true: the transaction is only signed if the new signatures will result in the transaction being fully
     * authorized. Otherwise returns as an error.
     * If false: the transaction is signed and the signature distributed. The transaction may still not be fully
     * authorized and remain as a proposal.
     *
     * @generated from protobuf field: bool must_fully_authorize = 3
     */
    mustFullyAuthorize: boolean
    /**
     * * Force specific changes even if dangerous
     *
     * @generated from protobuf field: repeated com.digitalasset.canton.topology.admin.v30.ForceFlag force_changes = 4
     */
    forceChanges: ForceFlag[]
    /**
     * *
     * Fingerprint of the keys signing the authorization
     *
     * The signing key is used to identify a particular `NamespaceDelegation` certificate,
     * which is used to justify the given authorization.
     * Optional, if empty, suitable signing keys available known to the node are automatically selected.
     *
     * @generated from protobuf field: repeated string signed_by = 5
     */
    signedBy: string[]
    /**
     * *
     * The store that is used as the underlying source for executing this request.
     * If `store` is a synchronizer store, the resulting topology transaction will only be available on the respective synchronizer.
     * If `store` is the authorized store, the resulting topology transaction may or may not be synchronized automatically
     * to all synchronizers that the node is currently connected to or will be connected to in the future.
     *
     * Selecting a specific synchronizers store might be necessary, if the transaction to authorize by hash or the previous
     * generation of the submitted proposal is only available on the synchronizers store and not in the authorized store.
     *
     * @generated from protobuf field: com.digitalasset.canton.topology.admin.v30.StoreId store = 6
     */
    store?: StoreId
    /**
     * * Optional timeout to wait for the transaction to become effective in the store.
     *
     * @generated from protobuf field: google.protobuf.Duration wait_to_become_effective = 7
     */
    waitToBecomeEffective?: Duration
}
/**
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.AuthorizeRequest.Proposal
 */
export interface AuthorizeRequest_Proposal {
    /**
     * * Replace / Remove
     *
     * @generated from protobuf field: com.digitalasset.canton.protocol.v30.Enums.TopologyChangeOp change = 1
     */
    change: Enums_TopologyChangeOp
    /**
     * * Optionally, the serial number of this request (auto-determined if omitted)
     *
     * @generated from protobuf field: uint32 serial = 2
     */
    serial: number
    /**
     * * The mapping to be authorized
     *
     * @generated from protobuf field: com.digitalasset.canton.protocol.v30.TopologyMapping mapping = 3
     */
    mapping?: TopologyMapping
}
/**
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.AuthorizeResponse
 */
export interface AuthorizeResponse {
    /**
     * * the generated signed topology transaction
     *
     * @generated from protobuf field: com.digitalasset.canton.protocol.v30.SignedTopologyTransaction transaction = 1
     */
    transaction?: SignedTopologyTransaction
}
/**
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.AddTransactionsRequest
 */
export interface AddTransactionsRequest {
    /**
     * *
     * The transactions that should be added to the target store as indicated by the parameter `store`.
     *
     * @generated from protobuf field: repeated com.digitalasset.canton.protocol.v30.SignedTopologyTransaction transactions = 1
     */
    transactions: SignedTopologyTransaction[]
    /**
     * * Force specific changes even if dangerous
     *
     * @generated from protobuf field: repeated com.digitalasset.canton.topology.admin.v30.ForceFlag force_changes = 2
     */
    forceChanges: ForceFlag[]
    /**
     * *
     * The store that is used as the underlying source for executing this request.
     * If `store` is a synchronizers store, the resulting topology transaction will only be available on the respective synchronizers.
     * If `store` is the authorized store, the resulting topology transaction may or may not be synchronized automatically
     * to all synchronizers that the node is currently connected to or will be connected to in the future.
     *
     * Selecting a specific synchronizers store might be necessary, if the transaction to authorize by hash or the previous
     * generation of the submitted proposal is only available on the synchronizers store and not in the authorized store.
     *
     * @generated from protobuf field: com.digitalasset.canton.topology.admin.v30.StoreId store = 3
     */
    store?: StoreId
    /**
     * * Optional timeout to wait for the transaction to become effective in the store.
     *
     * @generated from protobuf field: google.protobuf.Duration wait_to_become_effective = 7
     */
    waitToBecomeEffective?: Duration
}
/**
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.AddTransactionsResponse
 */
export interface AddTransactionsResponse {}
/**
 * *
 * Same message as AddTransactionsRequest, except that transactions are encoded in a byte string
 *
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.ImportTopologySnapshotRequest
 */
export interface ImportTopologySnapshotRequest {
    /**
     * @generated from protobuf field: bytes topology_snapshot = 1
     */
    topologySnapshot: Uint8Array
    /**
     * @generated from protobuf field: com.digitalasset.canton.topology.admin.v30.StoreId store = 2
     */
    store?: StoreId
    /**
     * * Optional timeout to wait for the transaction to become effective in the store.
     *
     * @generated from protobuf field: google.protobuf.Duration wait_to_become_effective = 3
     */
    waitToBecomeEffective?: Duration
}
/**
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.ImportTopologySnapshotResponse
 */
export interface ImportTopologySnapshotResponse {}
/**
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.SignTransactionsRequest
 */
export interface SignTransactionsRequest {
    /**
     * * The transactions to be signed, but will not be stored in the authorized store
     *
     * @generated from protobuf field: repeated com.digitalasset.canton.protocol.v30.SignedTopologyTransaction transactions = 1
     */
    transactions: SignedTopologyTransaction[]
    /**
     * *
     * Fingerprint of the keys signing the authorization
     *
     * The signing key is used to identify a particular `NamespaceDelegation` certificate,
     * which is used to justify the given authorization.
     * Optional, if empty, suitable signing keys available known to the node are automatically selected.
     *
     * @generated from protobuf field: repeated string signed_by = 2
     */
    signedBy: string[]
    /**
     * Target store
     *
     * @generated from protobuf field: com.digitalasset.canton.topology.admin.v30.StoreId store = 3
     */
    store?: StoreId
    /**
     * * Force specific changes even if dangerous
     *
     * @generated from protobuf field: repeated com.digitalasset.canton.topology.admin.v30.ForceFlag force_flags = 4
     */
    forceFlags: ForceFlag[]
}
/**
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.SignTransactionsResponse
 */
export interface SignTransactionsResponse {
    /**
     * * The transactions with the additional signatures from this node.
     *
     * @generated from protobuf field: repeated com.digitalasset.canton.protocol.v30.SignedTopologyTransaction transactions = 1
     */
    transactions: SignedTopologyTransaction[]
}
/**
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.CreateTemporaryTopologyStoreRequest
 */
export interface CreateTemporaryTopologyStoreRequest {
    /**
     * * The name of the topology store
     *
     * @generated from protobuf field: string name = 1
     */
    name: string
    /**
     * * The protocol version that should be used by the store
     *
     * @generated from protobuf field: uint32 protocol_version = 2
     */
    protocolVersion: number
}
/**
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.CreateTemporaryTopologyStoreResponse
 */
export interface CreateTemporaryTopologyStoreResponse {
    /**
     * * The identifier of the topology store that should be used as a store filter string
     *
     * @generated from protobuf field: com.digitalasset.canton.topology.admin.v30.StoreId.Temporary store_id = 1
     */
    storeId?: StoreId_Temporary
}
/**
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.DropTemporaryTopologyStoreRequest
 */
export interface DropTemporaryTopologyStoreRequest {
    /**
     * * The identifier of the topology store that should be dropped
     *
     * @generated from protobuf field: com.digitalasset.canton.topology.admin.v30.StoreId.Temporary store_id = 1
     */
    storeId?: StoreId_Temporary
}
/**
 * @generated from protobuf message com.digitalasset.canton.topology.admin.v30.DropTemporaryTopologyStoreResponse
 */
export interface DropTemporaryTopologyStoreResponse {}
/**
 * @generated from protobuf enum com.digitalasset.canton.topology.admin.v30.ForceFlag
 */
export enum ForceFlag {
    /**
     * @generated from protobuf enum value: FORCE_FLAG_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * * Required when authorizing adding a topology transaction on behalf of another node.
     *
     * @generated from protobuf enum value: FORCE_FLAG_ALIEN_MEMBER = 1;
     */
    ALIEN_MEMBER = 1,
    /**
     * Deprecated, increasing ledger time record time tolerance does not require a force flag for PV >= 32
     *
     * @generated from protobuf enum value: FORCE_FLAG_LEDGER_TIME_RECORD_TIME_TOLERANCE_INCREASE = 2;
     */
    LEDGER_TIME_RECORD_TIME_TOLERANCE_INCREASE = 2,
    /**
     * * Required when revoking the vetting of a package
     *
     * @generated from protobuf enum value: FORCE_FLAG_ALLOW_UNVET_PACKAGE = 3;
     */
    ALLOW_UNVET_PACKAGE = 3,
    /**
     * * Required when vetting unknown packages (not uploaded).
     *
     * @generated from protobuf enum value: FORCE_FLAG_ALLOW_UNKNOWN_PACKAGE = 4;
     */
    ALLOW_UNKNOWN_PACKAGE = 4,
    /**
     * * Required when vetting a package with unvetted dependencies
     *
     * @generated from protobuf enum value: FORCE_FLAG_ALLOW_UNVETTED_DEPENDENCIES = 5;
     */
    ALLOW_UNVETTED_DEPENDENCIES = 5,
    /**
     * * Required when disabling a party with active contracts
     *
     * @generated from protobuf enum value: FORCE_FLAG_DISABLE_PARTY_WITH_ACTIVE_CONTRACTS = 6;
     */
    DISABLE_PARTY_WITH_ACTIVE_CONTRACTS = 6,
    /**
     * *
     * Required when using a key that is not suitable to sign a topology transaction.
     * Using this force flag likely causes the transaction to be rejected at a later stage of the processing.
     *
     * @generated from protobuf enum value: FORCE_FLAG_ALLOW_UNVALIDATED_SIGNING_KEYS = 7;
     */
    ALLOW_UNVALIDATED_SIGNING_KEYS = 7,
    /**
     * * Required when unvetting a package with active contracts
     *
     * @generated from protobuf enum value: FORCE_FLAG_ALLOW_UNVET_PACKAGE_WITH_ACTIVE_CONTRACTS = 8;
     */
    ALLOW_UNVET_PACKAGE_WITH_ACTIVE_CONTRACTS = 8,
    /**
     * * Required when increasing the submission time record time tolerance
     *
     * @generated from protobuf enum value: FORCE_FLAG_PREPARATION_TIME_RECORD_TIME_TOLERANCE_INCREASE = 9;
     */
    PREPARATION_TIME_RECORD_TIME_TOLERANCE_INCREASE = 9,
    /**
     * * Required when we want to change all participants' permissions to observation while the party is still a signatory of a contract.
     *
     * @generated from protobuf enum value: FORCE_FLAG_ALLOW_INSUFFICIENT_PARTICIPANT_PERMISSION_FOR_SIGNATORY_PARTY = 10;
     */
    ALLOW_INSUFFICIENT_PARTICIPANT_PERMISSION_FOR_SIGNATORY_PARTY = 10,
    /**
     * * Required when changing the party-to-participant mapping, that would result in insufficient
     * signatory-assigning participants and thus the assignment would be stuck.
     *
     * @generated from protobuf enum value: FORCE_FLAG_ALLOW_INSUFFICIENT_SIGNATORY_ASSIGNING_PARTICIPANTS_FOR_PARTY = 11;
     */
    ALLOW_INSUFFICIENT_SIGNATORY_ASSIGNING_PARTICIPANTS_FOR_PARTY = 11,
}
// @generated message type with reflection information, may provide speed optimized methods
class GenerateTransactionsRequest$Type extends MessageType<GenerateTransactionsRequest> {
    constructor() {
        super(
            'com.digitalasset.canton.topology.admin.v30.GenerateTransactionsRequest',
            [
                {
                    no: 1,
                    name: 'proposals',
                    kind: 'message',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: () => GenerateTransactionsRequest_Proposal,
                },
            ]
        )
    }
    create(
        value?: PartialMessage<GenerateTransactionsRequest>
    ): GenerateTransactionsRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.proposals = []
        if (value !== undefined)
            reflectionMergePartial<GenerateTransactionsRequest>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GenerateTransactionsRequest
    ): GenerateTransactionsRequest {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated com.digitalasset.canton.topology.admin.v30.GenerateTransactionsRequest.Proposal proposals */ 1:
                    message.proposals.push(
                        GenerateTransactionsRequest_Proposal.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GenerateTransactionsRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated com.digitalasset.canton.topology.admin.v30.GenerateTransactionsRequest.Proposal proposals = 1; */
        for (let i = 0; i < message.proposals.length; i++)
            GenerateTransactionsRequest_Proposal.internalBinaryWrite(
                message.proposals[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.GenerateTransactionsRequest
 */
export const GenerateTransactionsRequest =
    new GenerateTransactionsRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GenerateTransactionsRequest_Proposal$Type extends MessageType<GenerateTransactionsRequest_Proposal> {
    constructor() {
        super(
            'com.digitalasset.canton.topology.admin.v30.GenerateTransactionsRequest.Proposal',
            [
                {
                    no: 1,
                    name: 'operation',
                    kind: 'enum',
                    T: () => [
                        'com.digitalasset.canton.protocol.v30.Enums.TopologyChangeOp',
                        Enums_TopologyChangeOp,
                        'TOPOLOGY_CHANGE_OP_',
                    ],
                },
                {
                    no: 2,
                    name: 'serial',
                    kind: 'scalar',
                    T: 13 /*ScalarType.UINT32*/,
                },
                {
                    no: 3,
                    name: 'mapping',
                    kind: 'message',
                    T: () => TopologyMapping,
                },
                { no: 4, name: 'store', kind: 'message', T: () => StoreId },
            ]
        )
    }
    create(
        value?: PartialMessage<GenerateTransactionsRequest_Proposal>
    ): GenerateTransactionsRequest_Proposal {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.operation = 0
        message.serial = 0
        if (value !== undefined)
            reflectionMergePartial<GenerateTransactionsRequest_Proposal>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GenerateTransactionsRequest_Proposal
    ): GenerateTransactionsRequest_Proposal {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.protocol.v30.Enums.TopologyChangeOp operation */ 1:
                    message.operation = reader.int32()
                    break
                case /* uint32 serial */ 2:
                    message.serial = reader.uint32()
                    break
                case /* com.digitalasset.canton.protocol.v30.TopologyMapping mapping */ 3:
                    message.mapping = TopologyMapping.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.mapping
                    )
                    break
                case /* com.digitalasset.canton.topology.admin.v30.StoreId store */ 4:
                    message.store = StoreId.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.store
                    )
                    break
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GenerateTransactionsRequest_Proposal,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.protocol.v30.Enums.TopologyChangeOp operation = 1; */
        if (message.operation !== 0)
            writer.tag(1, WireType.Varint).int32(message.operation)
        /* uint32 serial = 2; */
        if (message.serial !== 0)
            writer.tag(2, WireType.Varint).uint32(message.serial)
        /* com.digitalasset.canton.protocol.v30.TopologyMapping mapping = 3; */
        if (message.mapping)
            TopologyMapping.internalBinaryWrite(
                message.mapping,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.topology.admin.v30.StoreId store = 4; */
        if (message.store)
            StoreId.internalBinaryWrite(
                message.store,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.GenerateTransactionsRequest.Proposal
 */
export const GenerateTransactionsRequest_Proposal =
    new GenerateTransactionsRequest_Proposal$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GenerateTransactionsResponse$Type extends MessageType<GenerateTransactionsResponse> {
    constructor() {
        super(
            'com.digitalasset.canton.topology.admin.v30.GenerateTransactionsResponse',
            [
                {
                    no: 1,
                    name: 'generated_transactions',
                    kind: 'message',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: () => GenerateTransactionsResponse_GeneratedTransaction,
                },
            ]
        )
    }
    create(
        value?: PartialMessage<GenerateTransactionsResponse>
    ): GenerateTransactionsResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.generatedTransactions = []
        if (value !== undefined)
            reflectionMergePartial<GenerateTransactionsResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GenerateTransactionsResponse
    ): GenerateTransactionsResponse {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated com.digitalasset.canton.topology.admin.v30.GenerateTransactionsResponse.GeneratedTransaction generated_transactions */ 1:
                    message.generatedTransactions.push(
                        GenerateTransactionsResponse_GeneratedTransaction.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GenerateTransactionsResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated com.digitalasset.canton.topology.admin.v30.GenerateTransactionsResponse.GeneratedTransaction generated_transactions = 1; */
        for (let i = 0; i < message.generatedTransactions.length; i++)
            GenerateTransactionsResponse_GeneratedTransaction.internalBinaryWrite(
                message.generatedTransactions[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.GenerateTransactionsResponse
 */
export const GenerateTransactionsResponse =
    new GenerateTransactionsResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GenerateTransactionsResponse_GeneratedTransaction$Type extends MessageType<GenerateTransactionsResponse_GeneratedTransaction> {
    constructor() {
        super(
            'com.digitalasset.canton.topology.admin.v30.GenerateTransactionsResponse.GeneratedTransaction',
            [
                {
                    no: 1,
                    name: 'serialized_transaction',
                    kind: 'scalar',
                    T: 12 /*ScalarType.BYTES*/,
                },
                {
                    no: 2,
                    name: 'transaction_hash',
                    kind: 'scalar',
                    T: 12 /*ScalarType.BYTES*/,
                },
            ]
        )
    }
    create(
        value?: PartialMessage<GenerateTransactionsResponse_GeneratedTransaction>
    ): GenerateTransactionsResponse_GeneratedTransaction {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.serializedTransaction = new Uint8Array(0)
        message.transactionHash = new Uint8Array(0)
        if (value !== undefined)
            reflectionMergePartial<GenerateTransactionsResponse_GeneratedTransaction>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GenerateTransactionsResponse_GeneratedTransaction
    ): GenerateTransactionsResponse_GeneratedTransaction {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* bytes serialized_transaction */ 1:
                    message.serializedTransaction = reader.bytes()
                    break
                case /* bytes transaction_hash */ 2:
                    message.transactionHash = reader.bytes()
                    break
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GenerateTransactionsResponse_GeneratedTransaction,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* bytes serialized_transaction = 1; */
        if (message.serializedTransaction.length)
            writer
                .tag(1, WireType.LengthDelimited)
                .bytes(message.serializedTransaction)
        /* bytes transaction_hash = 2; */
        if (message.transactionHash.length)
            writer
                .tag(2, WireType.LengthDelimited)
                .bytes(message.transactionHash)
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.GenerateTransactionsResponse.GeneratedTransaction
 */
export const GenerateTransactionsResponse_GeneratedTransaction =
    new GenerateTransactionsResponse_GeneratedTransaction$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizeRequest$Type extends MessageType<AuthorizeRequest> {
    constructor() {
        super('com.digitalasset.canton.topology.admin.v30.AuthorizeRequest', [
            {
                no: 1,
                name: 'proposal',
                kind: 'message',
                oneof: 'type',
                T: () => AuthorizeRequest_Proposal,
            },
            {
                no: 2,
                name: 'transaction_hash',
                kind: 'scalar',
                oneof: 'type',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 3,
                name: 'must_fully_authorize',
                kind: 'scalar',
                T: 8 /*ScalarType.BOOL*/,
            },
            {
                no: 4,
                name: 'force_changes',
                kind: 'enum',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => [
                    'com.digitalasset.canton.topology.admin.v30.ForceFlag',
                    ForceFlag,
                    'FORCE_FLAG_',
                ],
            },
            {
                no: 5,
                name: 'signed_by',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/,
            },
            { no: 6, name: 'store', kind: 'message', T: () => StoreId },
            {
                no: 7,
                name: 'wait_to_become_effective',
                kind: 'message',
                T: () => Duration,
            },
        ])
    }
    create(value?: PartialMessage<AuthorizeRequest>): AuthorizeRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.type = { oneofKind: undefined }
        message.mustFullyAuthorize = false
        message.forceChanges = []
        message.signedBy = []
        if (value !== undefined)
            reflectionMergePartial<AuthorizeRequest>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: AuthorizeRequest
    ): AuthorizeRequest {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.topology.admin.v30.AuthorizeRequest.Proposal proposal */ 1:
                    message.type = {
                        oneofKind: 'proposal',
                        proposal: AuthorizeRequest_Proposal.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.type as any).proposal
                        ),
                    }
                    break
                case /* string transaction_hash */ 2:
                    message.type = {
                        oneofKind: 'transactionHash',
                        transactionHash: reader.string(),
                    }
                    break
                case /* bool must_fully_authorize */ 3:
                    message.mustFullyAuthorize = reader.bool()
                    break
                case /* repeated com.digitalasset.canton.topology.admin.v30.ForceFlag force_changes */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (
                            let e = reader.int32() + reader.pos;
                            reader.pos < e;

                        )
                            message.forceChanges.push(reader.int32())
                    else message.forceChanges.push(reader.int32())
                    break
                case /* repeated string signed_by */ 5:
                    message.signedBy.push(reader.string())
                    break
                case /* com.digitalasset.canton.topology.admin.v30.StoreId store */ 6:
                    message.store = StoreId.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.store
                    )
                    break
                case /* google.protobuf.Duration wait_to_become_effective */ 7:
                    message.waitToBecomeEffective = Duration.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.waitToBecomeEffective
                    )
                    break
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: AuthorizeRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.topology.admin.v30.AuthorizeRequest.Proposal proposal = 1; */
        if (message.type.oneofKind === 'proposal')
            AuthorizeRequest_Proposal.internalBinaryWrite(
                message.type.proposal,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* string transaction_hash = 2; */
        if (message.type.oneofKind === 'transactionHash')
            writer
                .tag(2, WireType.LengthDelimited)
                .string(message.type.transactionHash)
        /* bool must_fully_authorize = 3; */
        if (message.mustFullyAuthorize !== false)
            writer.tag(3, WireType.Varint).bool(message.mustFullyAuthorize)
        /* repeated com.digitalasset.canton.topology.admin.v30.ForceFlag force_changes = 4; */
        if (message.forceChanges.length) {
            writer.tag(4, WireType.LengthDelimited).fork()
            for (let i = 0; i < message.forceChanges.length; i++)
                writer.int32(message.forceChanges[i])
            writer.join()
        }
        /* repeated string signed_by = 5; */
        for (let i = 0; i < message.signedBy.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.signedBy[i])
        /* com.digitalasset.canton.topology.admin.v30.StoreId store = 6; */
        if (message.store)
            StoreId.internalBinaryWrite(
                message.store,
                writer.tag(6, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* google.protobuf.Duration wait_to_become_effective = 7; */
        if (message.waitToBecomeEffective)
            Duration.internalBinaryWrite(
                message.waitToBecomeEffective,
                writer.tag(7, WireType.LengthDelimited).fork(),
                options
            ).join()
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.AuthorizeRequest
 */
export const AuthorizeRequest = new AuthorizeRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizeRequest_Proposal$Type extends MessageType<AuthorizeRequest_Proposal> {
    constructor() {
        super(
            'com.digitalasset.canton.topology.admin.v30.AuthorizeRequest.Proposal',
            [
                {
                    no: 1,
                    name: 'change',
                    kind: 'enum',
                    T: () => [
                        'com.digitalasset.canton.protocol.v30.Enums.TopologyChangeOp',
                        Enums_TopologyChangeOp,
                        'TOPOLOGY_CHANGE_OP_',
                    ],
                },
                {
                    no: 2,
                    name: 'serial',
                    kind: 'scalar',
                    T: 13 /*ScalarType.UINT32*/,
                },
                {
                    no: 3,
                    name: 'mapping',
                    kind: 'message',
                    T: () => TopologyMapping,
                },
            ]
        )
    }
    create(
        value?: PartialMessage<AuthorizeRequest_Proposal>
    ): AuthorizeRequest_Proposal {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.change = 0
        message.serial = 0
        if (value !== undefined)
            reflectionMergePartial<AuthorizeRequest_Proposal>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: AuthorizeRequest_Proposal
    ): AuthorizeRequest_Proposal {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.protocol.v30.Enums.TopologyChangeOp change */ 1:
                    message.change = reader.int32()
                    break
                case /* uint32 serial */ 2:
                    message.serial = reader.uint32()
                    break
                case /* com.digitalasset.canton.protocol.v30.TopologyMapping mapping */ 3:
                    message.mapping = TopologyMapping.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.mapping
                    )
                    break
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: AuthorizeRequest_Proposal,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.protocol.v30.Enums.TopologyChangeOp change = 1; */
        if (message.change !== 0)
            writer.tag(1, WireType.Varint).int32(message.change)
        /* uint32 serial = 2; */
        if (message.serial !== 0)
            writer.tag(2, WireType.Varint).uint32(message.serial)
        /* com.digitalasset.canton.protocol.v30.TopologyMapping mapping = 3; */
        if (message.mapping)
            TopologyMapping.internalBinaryWrite(
                message.mapping,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.AuthorizeRequest.Proposal
 */
export const AuthorizeRequest_Proposal = new AuthorizeRequest_Proposal$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AuthorizeResponse$Type extends MessageType<AuthorizeResponse> {
    constructor() {
        super('com.digitalasset.canton.topology.admin.v30.AuthorizeResponse', [
            {
                no: 1,
                name: 'transaction',
                kind: 'message',
                T: () => SignedTopologyTransaction,
            },
        ])
    }
    create(value?: PartialMessage<AuthorizeResponse>): AuthorizeResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<AuthorizeResponse>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: AuthorizeResponse
    ): AuthorizeResponse {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.protocol.v30.SignedTopologyTransaction transaction */ 1:
                    message.transaction =
                        SignedTopologyTransaction.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.transaction
                        )
                    break
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: AuthorizeResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.protocol.v30.SignedTopologyTransaction transaction = 1; */
        if (message.transaction)
            SignedTopologyTransaction.internalBinaryWrite(
                message.transaction,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.AuthorizeResponse
 */
export const AuthorizeResponse = new AuthorizeResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AddTransactionsRequest$Type extends MessageType<AddTransactionsRequest> {
    constructor() {
        super(
            'com.digitalasset.canton.topology.admin.v30.AddTransactionsRequest',
            [
                {
                    no: 1,
                    name: 'transactions',
                    kind: 'message',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: () => SignedTopologyTransaction,
                },
                {
                    no: 2,
                    name: 'force_changes',
                    kind: 'enum',
                    repeat: 1 /*RepeatType.PACKED*/,
                    T: () => [
                        'com.digitalasset.canton.topology.admin.v30.ForceFlag',
                        ForceFlag,
                        'FORCE_FLAG_',
                    ],
                },
                { no: 3, name: 'store', kind: 'message', T: () => StoreId },
                {
                    no: 7,
                    name: 'wait_to_become_effective',
                    kind: 'message',
                    T: () => Duration,
                },
            ]
        )
    }
    create(
        value?: PartialMessage<AddTransactionsRequest>
    ): AddTransactionsRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.transactions = []
        message.forceChanges = []
        if (value !== undefined)
            reflectionMergePartial<AddTransactionsRequest>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: AddTransactionsRequest
    ): AddTransactionsRequest {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated com.digitalasset.canton.protocol.v30.SignedTopologyTransaction transactions */ 1:
                    message.transactions.push(
                        SignedTopologyTransaction.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                case /* repeated com.digitalasset.canton.topology.admin.v30.ForceFlag force_changes */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (
                            let e = reader.int32() + reader.pos;
                            reader.pos < e;

                        )
                            message.forceChanges.push(reader.int32())
                    else message.forceChanges.push(reader.int32())
                    break
                case /* com.digitalasset.canton.topology.admin.v30.StoreId store */ 3:
                    message.store = StoreId.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.store
                    )
                    break
                case /* google.protobuf.Duration wait_to_become_effective */ 7:
                    message.waitToBecomeEffective = Duration.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.waitToBecomeEffective
                    )
                    break
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: AddTransactionsRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated com.digitalasset.canton.protocol.v30.SignedTopologyTransaction transactions = 1; */
        for (let i = 0; i < message.transactions.length; i++)
            SignedTopologyTransaction.internalBinaryWrite(
                message.transactions[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* repeated com.digitalasset.canton.topology.admin.v30.ForceFlag force_changes = 2; */
        if (message.forceChanges.length) {
            writer.tag(2, WireType.LengthDelimited).fork()
            for (let i = 0; i < message.forceChanges.length; i++)
                writer.int32(message.forceChanges[i])
            writer.join()
        }
        /* com.digitalasset.canton.topology.admin.v30.StoreId store = 3; */
        if (message.store)
            StoreId.internalBinaryWrite(
                message.store,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* google.protobuf.Duration wait_to_become_effective = 7; */
        if (message.waitToBecomeEffective)
            Duration.internalBinaryWrite(
                message.waitToBecomeEffective,
                writer.tag(7, WireType.LengthDelimited).fork(),
                options
            ).join()
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.AddTransactionsRequest
 */
export const AddTransactionsRequest = new AddTransactionsRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AddTransactionsResponse$Type extends MessageType<AddTransactionsResponse> {
    constructor() {
        super(
            'com.digitalasset.canton.topology.admin.v30.AddTransactionsResponse',
            []
        )
    }
    create(
        value?: PartialMessage<AddTransactionsResponse>
    ): AddTransactionsResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<AddTransactionsResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: AddTransactionsResponse
    ): AddTransactionsResponse {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: AddTransactionsResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.AddTransactionsResponse
 */
export const AddTransactionsResponse = new AddTransactionsResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ImportTopologySnapshotRequest$Type extends MessageType<ImportTopologySnapshotRequest> {
    constructor() {
        super(
            'com.digitalasset.canton.topology.admin.v30.ImportTopologySnapshotRequest',
            [
                {
                    no: 1,
                    name: 'topology_snapshot',
                    kind: 'scalar',
                    T: 12 /*ScalarType.BYTES*/,
                },
                { no: 2, name: 'store', kind: 'message', T: () => StoreId },
                {
                    no: 3,
                    name: 'wait_to_become_effective',
                    kind: 'message',
                    T: () => Duration,
                },
            ]
        )
    }
    create(
        value?: PartialMessage<ImportTopologySnapshotRequest>
    ): ImportTopologySnapshotRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.topologySnapshot = new Uint8Array(0)
        if (value !== undefined)
            reflectionMergePartial<ImportTopologySnapshotRequest>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ImportTopologySnapshotRequest
    ): ImportTopologySnapshotRequest {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* bytes topology_snapshot */ 1:
                    message.topologySnapshot = reader.bytes()
                    break
                case /* com.digitalasset.canton.topology.admin.v30.StoreId store */ 2:
                    message.store = StoreId.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.store
                    )
                    break
                case /* google.protobuf.Duration wait_to_become_effective */ 3:
                    message.waitToBecomeEffective = Duration.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.waitToBecomeEffective
                    )
                    break
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: ImportTopologySnapshotRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* bytes topology_snapshot = 1; */
        if (message.topologySnapshot.length)
            writer
                .tag(1, WireType.LengthDelimited)
                .bytes(message.topologySnapshot)
        /* com.digitalasset.canton.topology.admin.v30.StoreId store = 2; */
        if (message.store)
            StoreId.internalBinaryWrite(
                message.store,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* google.protobuf.Duration wait_to_become_effective = 3; */
        if (message.waitToBecomeEffective)
            Duration.internalBinaryWrite(
                message.waitToBecomeEffective,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.ImportTopologySnapshotRequest
 */
export const ImportTopologySnapshotRequest =
    new ImportTopologySnapshotRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ImportTopologySnapshotResponse$Type extends MessageType<ImportTopologySnapshotResponse> {
    constructor() {
        super(
            'com.digitalasset.canton.topology.admin.v30.ImportTopologySnapshotResponse',
            []
        )
    }
    create(
        value?: PartialMessage<ImportTopologySnapshotResponse>
    ): ImportTopologySnapshotResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<ImportTopologySnapshotResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ImportTopologySnapshotResponse
    ): ImportTopologySnapshotResponse {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: ImportTopologySnapshotResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.ImportTopologySnapshotResponse
 */
export const ImportTopologySnapshotResponse =
    new ImportTopologySnapshotResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SignTransactionsRequest$Type extends MessageType<SignTransactionsRequest> {
    constructor() {
        super(
            'com.digitalasset.canton.topology.admin.v30.SignTransactionsRequest',
            [
                {
                    no: 1,
                    name: 'transactions',
                    kind: 'message',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: () => SignedTopologyTransaction,
                },
                {
                    no: 2,
                    name: 'signed_by',
                    kind: 'scalar',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: 9 /*ScalarType.STRING*/,
                },
                { no: 3, name: 'store', kind: 'message', T: () => StoreId },
                {
                    no: 4,
                    name: 'force_flags',
                    kind: 'enum',
                    repeat: 1 /*RepeatType.PACKED*/,
                    T: () => [
                        'com.digitalasset.canton.topology.admin.v30.ForceFlag',
                        ForceFlag,
                        'FORCE_FLAG_',
                    ],
                },
            ]
        )
    }
    create(
        value?: PartialMessage<SignTransactionsRequest>
    ): SignTransactionsRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.transactions = []
        message.signedBy = []
        message.forceFlags = []
        if (value !== undefined)
            reflectionMergePartial<SignTransactionsRequest>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SignTransactionsRequest
    ): SignTransactionsRequest {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated com.digitalasset.canton.protocol.v30.SignedTopologyTransaction transactions */ 1:
                    message.transactions.push(
                        SignedTopologyTransaction.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                case /* repeated string signed_by */ 2:
                    message.signedBy.push(reader.string())
                    break
                case /* com.digitalasset.canton.topology.admin.v30.StoreId store */ 3:
                    message.store = StoreId.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.store
                    )
                    break
                case /* repeated com.digitalasset.canton.topology.admin.v30.ForceFlag force_flags */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (
                            let e = reader.int32() + reader.pos;
                            reader.pos < e;

                        )
                            message.forceFlags.push(reader.int32())
                    else message.forceFlags.push(reader.int32())
                    break
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: SignTransactionsRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated com.digitalasset.canton.protocol.v30.SignedTopologyTransaction transactions = 1; */
        for (let i = 0; i < message.transactions.length; i++)
            SignedTopologyTransaction.internalBinaryWrite(
                message.transactions[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* repeated string signed_by = 2; */
        for (let i = 0; i < message.signedBy.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.signedBy[i])
        /* com.digitalasset.canton.topology.admin.v30.StoreId store = 3; */
        if (message.store)
            StoreId.internalBinaryWrite(
                message.store,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* repeated com.digitalasset.canton.topology.admin.v30.ForceFlag force_flags = 4; */
        if (message.forceFlags.length) {
            writer.tag(4, WireType.LengthDelimited).fork()
            for (let i = 0; i < message.forceFlags.length; i++)
                writer.int32(message.forceFlags[i])
            writer.join()
        }
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.SignTransactionsRequest
 */
export const SignTransactionsRequest = new SignTransactionsRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SignTransactionsResponse$Type extends MessageType<SignTransactionsResponse> {
    constructor() {
        super(
            'com.digitalasset.canton.topology.admin.v30.SignTransactionsResponse',
            [
                {
                    no: 1,
                    name: 'transactions',
                    kind: 'message',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: () => SignedTopologyTransaction,
                },
            ]
        )
    }
    create(
        value?: PartialMessage<SignTransactionsResponse>
    ): SignTransactionsResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.transactions = []
        if (value !== undefined)
            reflectionMergePartial<SignTransactionsResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SignTransactionsResponse
    ): SignTransactionsResponse {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated com.digitalasset.canton.protocol.v30.SignedTopologyTransaction transactions */ 1:
                    message.transactions.push(
                        SignedTopologyTransaction.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: SignTransactionsResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated com.digitalasset.canton.protocol.v30.SignedTopologyTransaction transactions = 1; */
        for (let i = 0; i < message.transactions.length; i++)
            SignedTopologyTransaction.internalBinaryWrite(
                message.transactions[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.SignTransactionsResponse
 */
export const SignTransactionsResponse = new SignTransactionsResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CreateTemporaryTopologyStoreRequest$Type extends MessageType<CreateTemporaryTopologyStoreRequest> {
    constructor() {
        super(
            'com.digitalasset.canton.topology.admin.v30.CreateTemporaryTopologyStoreRequest',
            [
                {
                    no: 1,
                    name: 'name',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'protocol_version',
                    kind: 'scalar',
                    T: 13 /*ScalarType.UINT32*/,
                },
            ]
        )
    }
    create(
        value?: PartialMessage<CreateTemporaryTopologyStoreRequest>
    ): CreateTemporaryTopologyStoreRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.name = ''
        message.protocolVersion = 0
        if (value !== undefined)
            reflectionMergePartial<CreateTemporaryTopologyStoreRequest>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CreateTemporaryTopologyStoreRequest
    ): CreateTemporaryTopologyStoreRequest {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string()
                    break
                case /* uint32 protocol_version */ 2:
                    message.protocolVersion = reader.uint32()
                    break
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: CreateTemporaryTopologyStoreRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.name)
        /* uint32 protocol_version = 2; */
        if (message.protocolVersion !== 0)
            writer.tag(2, WireType.Varint).uint32(message.protocolVersion)
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.CreateTemporaryTopologyStoreRequest
 */
export const CreateTemporaryTopologyStoreRequest =
    new CreateTemporaryTopologyStoreRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CreateTemporaryTopologyStoreResponse$Type extends MessageType<CreateTemporaryTopologyStoreResponse> {
    constructor() {
        super(
            'com.digitalasset.canton.topology.admin.v30.CreateTemporaryTopologyStoreResponse',
            [
                {
                    no: 1,
                    name: 'store_id',
                    kind: 'message',
                    T: () => StoreId_Temporary,
                },
            ]
        )
    }
    create(
        value?: PartialMessage<CreateTemporaryTopologyStoreResponse>
    ): CreateTemporaryTopologyStoreResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<CreateTemporaryTopologyStoreResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CreateTemporaryTopologyStoreResponse
    ): CreateTemporaryTopologyStoreResponse {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.topology.admin.v30.StoreId.Temporary store_id */ 1:
                    message.storeId = StoreId_Temporary.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.storeId
                    )
                    break
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: CreateTemporaryTopologyStoreResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.topology.admin.v30.StoreId.Temporary store_id = 1; */
        if (message.storeId)
            StoreId_Temporary.internalBinaryWrite(
                message.storeId,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.CreateTemporaryTopologyStoreResponse
 */
export const CreateTemporaryTopologyStoreResponse =
    new CreateTemporaryTopologyStoreResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DropTemporaryTopologyStoreRequest$Type extends MessageType<DropTemporaryTopologyStoreRequest> {
    constructor() {
        super(
            'com.digitalasset.canton.topology.admin.v30.DropTemporaryTopologyStoreRequest',
            [
                {
                    no: 1,
                    name: 'store_id',
                    kind: 'message',
                    T: () => StoreId_Temporary,
                },
            ]
        )
    }
    create(
        value?: PartialMessage<DropTemporaryTopologyStoreRequest>
    ): DropTemporaryTopologyStoreRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<DropTemporaryTopologyStoreRequest>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: DropTemporaryTopologyStoreRequest
    ): DropTemporaryTopologyStoreRequest {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.topology.admin.v30.StoreId.Temporary store_id */ 1:
                    message.storeId = StoreId_Temporary.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.storeId
                    )
                    break
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: DropTemporaryTopologyStoreRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.topology.admin.v30.StoreId.Temporary store_id = 1; */
        if (message.storeId)
            StoreId_Temporary.internalBinaryWrite(
                message.storeId,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.DropTemporaryTopologyStoreRequest
 */
export const DropTemporaryTopologyStoreRequest =
    new DropTemporaryTopologyStoreRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DropTemporaryTopologyStoreResponse$Type extends MessageType<DropTemporaryTopologyStoreResponse> {
    constructor() {
        super(
            'com.digitalasset.canton.topology.admin.v30.DropTemporaryTopologyStoreResponse',
            []
        )
    }
    create(
        value?: PartialMessage<DropTemporaryTopologyStoreResponse>
    ): DropTemporaryTopologyStoreResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<DropTemporaryTopologyStoreResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: DropTemporaryTopologyStoreResponse
    ): DropTemporaryTopologyStoreResponse {
        const message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            const [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                default:
                    const u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    const d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: DropTemporaryTopologyStoreResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        const u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.topology.admin.v30.DropTemporaryTopologyStoreResponse
 */
export const DropTemporaryTopologyStoreResponse =
    new DropTemporaryTopologyStoreResponse$Type()
/**
 * @generated ServiceType for protobuf service com.digitalasset.canton.topology.admin.v30.TopologyManagerWriteService
 */
export const TopologyManagerWriteService = new ServiceType(
    'com.digitalasset.canton.topology.admin.v30.TopologyManagerWriteService',
    [
        {
            name: 'Authorize',
            options: {},
            I: AuthorizeRequest,
            O: AuthorizeResponse,
        },
        {
            name: 'AddTransactions',
            options: {},
            I: AddTransactionsRequest,
            O: AddTransactionsResponse,
        },
        {
            name: 'ImportTopologySnapshot',
            clientStreaming: true,
            options: {},
            I: ImportTopologySnapshotRequest,
            O: ImportTopologySnapshotResponse,
        },
        {
            name: 'SignTransactions',
            options: {},
            I: SignTransactionsRequest,
            O: SignTransactionsResponse,
        },
        {
            name: 'GenerateTransactions',
            options: {},
            I: GenerateTransactionsRequest,
            O: GenerateTransactionsResponse,
        },
        {
            name: 'CreateTemporaryTopologyStore',
            options: {},
            I: CreateTemporaryTopologyStoreRequest,
            O: CreateTemporaryTopologyStoreResponse,
        },
        {
            name: 'DropTemporaryTopologyStore',
            options: {},
            I: DropTemporaryTopologyStoreRequest,
            O: DropTemporaryTopologyStoreResponse,
        },
    ]
)
