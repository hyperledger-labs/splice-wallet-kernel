// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/digitalasset/canton/protocol/v30/topology.proto" (package "com.digitalasset.canton.protocol.v30", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import { WireType } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { Signature } from '../../crypto/v30/crypto.js'
import { DynamicSequencingParameters } from './sequencing_parameters.js'
import { DynamicSynchronizerParameters } from './synchronizer_parameters.js'
import { Timestamp } from '../../../../../google/protobuf/timestamp.js'
import { ParticipantSynchronizerLimits } from './synchronizer_parameters.js'
import { PublicKey } from '../../crypto/v30/crypto.js'
import { SigningPublicKey } from '../../crypto/v30/crypto.js'
/**
 * @generated from protobuf enum com.digitalasset.canton.protocol.v30.Enums.TopologyChangeOp
 */
export var Enums_TopologyChangeOp
;(function (Enums_TopologyChangeOp) {
    /**
     * @generated from protobuf enum value: TOPOLOGY_CHANGE_OP_UNSPECIFIED = 0;
     */
    Enums_TopologyChangeOp[(Enums_TopologyChangeOp['UNSPECIFIED'] = 0)] =
        'UNSPECIFIED'
    /**
     * Adds a new or replaces an existing mapping
     *
     * @generated from protobuf enum value: TOPOLOGY_CHANGE_OP_ADD_REPLACE = 1;
     */
    Enums_TopologyChangeOp[(Enums_TopologyChangeOp['ADD_REPLACE'] = 1)] =
        'ADD_REPLACE'
    /**
     * Remove an existing mapping
     *
     * @generated from protobuf enum value: TOPOLOGY_CHANGE_OP_REMOVE = 2;
     */
    Enums_TopologyChangeOp[(Enums_TopologyChangeOp['REMOVE'] = 2)] = 'REMOVE'
})(Enums_TopologyChangeOp || (Enums_TopologyChangeOp = {}))
/**
 * enum indicating the participant permission level
 * Regardless of the ParticipantPermission level, all participants can submit a reassignment.
 *
 * @generated from protobuf enum com.digitalasset.canton.protocol.v30.Enums.ParticipantPermission
 */
export var Enums_ParticipantPermission
;(function (Enums_ParticipantPermission) {
    /**
     * @generated from protobuf enum value: PARTICIPANT_PERMISSION_UNSPECIFIED = 0;
     */
    Enums_ParticipantPermission[
        (Enums_ParticipantPermission['UNSPECIFIED'] = 0)
    ] = 'UNSPECIFIED'
    /**
     * participant is active, can submit transactions and reassignments
     *
     * @generated from protobuf enum value: PARTICIPANT_PERMISSION_SUBMISSION = 1;
     */
    Enums_ParticipantPermission[
        (Enums_ParticipantPermission['SUBMISSION'] = 1)
    ] = 'SUBMISSION'
    /**
     * participant is passive, can only confirm transactions and submit reassignments
     *
     * @generated from protobuf enum value: PARTICIPANT_PERMISSION_CONFIRMATION = 2;
     */
    Enums_ParticipantPermission[
        (Enums_ParticipantPermission['CONFIRMATION'] = 2)
    ] = 'CONFIRMATION'
    /**
     * participant is passive, can only observe transactions and submit reassignments
     *
     * @generated from protobuf enum value: PARTICIPANT_PERMISSION_OBSERVATION = 3;
     */
    Enums_ParticipantPermission[
        (Enums_ParticipantPermission['OBSERVATION'] = 3)
    ] = 'OBSERVATION'
})(Enums_ParticipantPermission || (Enums_ParticipantPermission = {}))
/**
 * @generated from protobuf enum com.digitalasset.canton.protocol.v30.Enums.TopologyMappingCode
 */
export var Enums_TopologyMappingCode
;(function (Enums_TopologyMappingCode) {
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_UNSPECIFIED = 0;
     */
    Enums_TopologyMappingCode[(Enums_TopologyMappingCode['UNSPECIFIED'] = 0)] =
        'UNSPECIFIED'
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_NAMESPACE_DELEGATION = 1;
     */
    Enums_TopologyMappingCode[
        (Enums_TopologyMappingCode['NAMESPACE_DELEGATION'] = 1)
    ] = 'NAMESPACE_DELEGATION'
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_DECENTRALIZED_NAMESPACE_DEFINITION = 3;
     */
    Enums_TopologyMappingCode[
        (Enums_TopologyMappingCode['DECENTRALIZED_NAMESPACE_DEFINITION'] = 3)
    ] = 'DECENTRALIZED_NAMESPACE_DEFINITION'
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_OWNER_TO_KEY_MAPPING = 4;
     */
    Enums_TopologyMappingCode[
        (Enums_TopologyMappingCode['OWNER_TO_KEY_MAPPING'] = 4)
    ] = 'OWNER_TO_KEY_MAPPING'
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_SYNCHRONIZER_TRUST_CERTIFICATE = 5;
     */
    Enums_TopologyMappingCode[
        (Enums_TopologyMappingCode['SYNCHRONIZER_TRUST_CERTIFICATE'] = 5)
    ] = 'SYNCHRONIZER_TRUST_CERTIFICATE'
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_PARTICIPANT_PERMISSION = 6;
     */
    Enums_TopologyMappingCode[
        (Enums_TopologyMappingCode['PARTICIPANT_PERMISSION'] = 6)
    ] = 'PARTICIPANT_PERMISSION'
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_PARTY_HOSTING_LIMITS = 7;
     */
    Enums_TopologyMappingCode[
        (Enums_TopologyMappingCode['PARTY_HOSTING_LIMITS'] = 7)
    ] = 'PARTY_HOSTING_LIMITS'
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_VETTED_PACKAGES = 8;
     */
    Enums_TopologyMappingCode[
        (Enums_TopologyMappingCode['VETTED_PACKAGES'] = 8)
    ] = 'VETTED_PACKAGES'
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_PARTY_TO_PARTICIPANT = 9;
     */
    Enums_TopologyMappingCode[
        (Enums_TopologyMappingCode['PARTY_TO_PARTICIPANT'] = 9)
    ] = 'PARTY_TO_PARTICIPANT'
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_SYNCHRONIZER_PARAMETERS_STATE = 11;
     */
    Enums_TopologyMappingCode[
        (Enums_TopologyMappingCode['SYNCHRONIZER_PARAMETERS_STATE'] = 11)
    ] = 'SYNCHRONIZER_PARAMETERS_STATE'
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_MEDIATOR_SYNCHRONIZER_STATE = 12;
     */
    Enums_TopologyMappingCode[
        (Enums_TopologyMappingCode['MEDIATOR_SYNCHRONIZER_STATE'] = 12)
    ] = 'MEDIATOR_SYNCHRONIZER_STATE'
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_SEQUENCER_SYNCHRONIZER_STATE = 13;
     */
    Enums_TopologyMappingCode[
        (Enums_TopologyMappingCode['SEQUENCER_SYNCHRONIZER_STATE'] = 13)
    ] = 'SEQUENCER_SYNCHRONIZER_STATE'
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_PURGE_TOPOLOGY_TXS = 15;
     */
    Enums_TopologyMappingCode[
        (Enums_TopologyMappingCode['PURGE_TOPOLOGY_TXS'] = 15)
    ] = 'PURGE_TOPOLOGY_TXS'
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_SEQUENCING_DYNAMIC_PARAMETERS_STATE = 17;
     */
    Enums_TopologyMappingCode[
        (Enums_TopologyMappingCode['SEQUENCING_DYNAMIC_PARAMETERS_STATE'] = 17)
    ] = 'SEQUENCING_DYNAMIC_PARAMETERS_STATE'
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_PARTY_TO_KEY_MAPPING = 18;
     */
    Enums_TopologyMappingCode[
        (Enums_TopologyMappingCode['PARTY_TO_KEY_MAPPING'] = 18)
    ] = 'PARTY_TO_KEY_MAPPING'
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_SYNCHRONIZER_MIGRATION_ANNOUNCEMENT = 19;
     */
    Enums_TopologyMappingCode[
        (Enums_TopologyMappingCode['SYNCHRONIZER_MIGRATION_ANNOUNCEMENT'] = 19)
    ] = 'SYNCHRONIZER_MIGRATION_ANNOUNCEMENT'
    /**
     * @generated from protobuf enum value: TOPOLOGY_MAPPING_CODE_SEQUENCER_CONNECTION_SUCCESSOR = 20;
     */
    Enums_TopologyMappingCode[
        (Enums_TopologyMappingCode['SEQUENCER_CONNECTION_SUCCESSOR'] = 20)
    ] = 'SEQUENCER_CONNECTION_SUCCESSOR'
})(Enums_TopologyMappingCode || (Enums_TopologyMappingCode = {}))
// @generated message type with reflection information, may provide speed optimized methods
class Enums$Type extends MessageType {
    constructor() {
        super('com.digitalasset.canton.protocol.v30.Enums', [])
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.Enums
 */
export const Enums = new Enums$Type()
// @generated message type with reflection information, may provide speed optimized methods
class NamespaceDelegation$Type extends MessageType {
    constructor() {
        super('com.digitalasset.canton.protocol.v30.NamespaceDelegation', [
            {
                no: 1,
                name: 'namespace',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'target_key',
                kind: 'message',
                T: () => SigningPublicKey,
            },
            {
                no: 3,
                name: 'is_root_delegation',
                kind: 'scalar',
                T: 8 /*ScalarType.BOOL*/,
            },
            {
                no: 4,
                name: 'can_sign_all_mappings',
                kind: 'message',
                oneof: 'restriction',
                T: () => NamespaceDelegation_CanSignAllMappings,
            },
            {
                no: 5,
                name: 'can_sign_all_but_namespace_delegations',
                kind: 'message',
                oneof: 'restriction',
                T: () => NamespaceDelegation_CanSignAllButNamespaceDelegations,
            },
            {
                no: 6,
                name: 'can_sign_specific_mapings',
                kind: 'message',
                oneof: 'restriction',
                T: () => NamespaceDelegation_CanSignSpecificMappings,
            },
        ])
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.namespace = ''
        message.isRootDelegation = false
        message.restriction = { oneofKind: undefined }
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string namespace */ 1:
                    message.namespace = reader.string()
                    break
                case /* com.digitalasset.canton.crypto.v30.SigningPublicKey target_key */ 2:
                    message.targetKey = SigningPublicKey.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.targetKey
                    )
                    break
                case /* bool is_root_delegation = 3 [deprecated = true] */ 3:
                    message.isRootDelegation = reader.bool()
                    break
                case /* com.digitalasset.canton.protocol.v30.NamespaceDelegation.CanSignAllMappings can_sign_all_mappings */ 4:
                    message.restriction = {
                        oneofKind: 'canSignAllMappings',
                        canSignAllMappings:
                            NamespaceDelegation_CanSignAllMappings.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                message.restriction.canSignAllMappings
                            ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.NamespaceDelegation.CanSignAllButNamespaceDelegations can_sign_all_but_namespace_delegations */ 5:
                    message.restriction = {
                        oneofKind: 'canSignAllButNamespaceDelegations',
                        canSignAllButNamespaceDelegations:
                            NamespaceDelegation_CanSignAllButNamespaceDelegations.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                message.restriction
                                    .canSignAllButNamespaceDelegations
                            ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.NamespaceDelegation.CanSignSpecificMappings can_sign_specific_mapings */ 6:
                    message.restriction = {
                        oneofKind: 'canSignSpecificMapings',
                        canSignSpecificMapings:
                            NamespaceDelegation_CanSignSpecificMappings.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                message.restriction.canSignSpecificMapings
                            ),
                    }
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string namespace = 1; */
        if (message.namespace !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.namespace)
        /* com.digitalasset.canton.crypto.v30.SigningPublicKey target_key = 2; */
        if (message.targetKey)
            SigningPublicKey.internalBinaryWrite(
                message.targetKey,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* bool is_root_delegation = 3 [deprecated = true]; */
        if (message.isRootDelegation !== false)
            writer.tag(3, WireType.Varint).bool(message.isRootDelegation)
        /* com.digitalasset.canton.protocol.v30.NamespaceDelegation.CanSignAllMappings can_sign_all_mappings = 4; */
        if (message.restriction.oneofKind === 'canSignAllMappings')
            NamespaceDelegation_CanSignAllMappings.internalBinaryWrite(
                message.restriction.canSignAllMappings,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.NamespaceDelegation.CanSignAllButNamespaceDelegations can_sign_all_but_namespace_delegations = 5; */
        if (
            message.restriction.oneofKind ===
            'canSignAllButNamespaceDelegations'
        )
            NamespaceDelegation_CanSignAllButNamespaceDelegations.internalBinaryWrite(
                message.restriction.canSignAllButNamespaceDelegations,
                writer.tag(5, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.NamespaceDelegation.CanSignSpecificMappings can_sign_specific_mapings = 6; */
        if (message.restriction.oneofKind === 'canSignSpecificMapings')
            NamespaceDelegation_CanSignSpecificMappings.internalBinaryWrite(
                message.restriction.canSignSpecificMapings,
                writer.tag(6, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.NamespaceDelegation
 */
export const NamespaceDelegation = new NamespaceDelegation$Type()
// @generated message type with reflection information, may provide speed optimized methods
class NamespaceDelegation_CanSignAllMappings$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.NamespaceDelegation.CanSignAllMappings',
            []
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.NamespaceDelegation.CanSignAllMappings
 */
export const NamespaceDelegation_CanSignAllMappings =
    new NamespaceDelegation_CanSignAllMappings$Type()
// @generated message type with reflection information, may provide speed optimized methods
class NamespaceDelegation_CanSignAllButNamespaceDelegations$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.NamespaceDelegation.CanSignAllButNamespaceDelegations',
            []
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.NamespaceDelegation.CanSignAllButNamespaceDelegations
 */
export const NamespaceDelegation_CanSignAllButNamespaceDelegations =
    new NamespaceDelegation_CanSignAllButNamespaceDelegations$Type()
// @generated message type with reflection information, may provide speed optimized methods
class NamespaceDelegation_CanSignSpecificMappings$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.NamespaceDelegation.CanSignSpecificMappings',
            [
                {
                    no: 1,
                    name: 'mappings',
                    kind: 'enum',
                    repeat: 1 /*RepeatType.PACKED*/,
                    T: () => [
                        'com.digitalasset.canton.protocol.v30.Enums.TopologyMappingCode',
                        Enums_TopologyMappingCode,
                        'TOPOLOGY_MAPPING_CODE_',
                    ],
                },
            ]
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.mappings = []
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated com.digitalasset.canton.protocol.v30.Enums.TopologyMappingCode mappings */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (
                            let e = reader.int32() + reader.pos;
                            reader.pos < e;

                        )
                            message.mappings.push(reader.int32())
                    else message.mappings.push(reader.int32())
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated com.digitalasset.canton.protocol.v30.Enums.TopologyMappingCode mappings = 1; */
        if (message.mappings.length) {
            writer.tag(1, WireType.LengthDelimited).fork()
            for (let i = 0; i < message.mappings.length; i++)
                writer.int32(message.mappings[i])
            writer.join()
        }
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.NamespaceDelegation.CanSignSpecificMappings
 */
export const NamespaceDelegation_CanSignSpecificMappings =
    new NamespaceDelegation_CanSignSpecificMappings$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DecentralizedNamespaceDefinition$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.DecentralizedNamespaceDefinition',
            [
                {
                    no: 1,
                    name: 'decentralized_namespace',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'threshold',
                    kind: 'scalar',
                    T: 5 /*ScalarType.INT32*/,
                },
                {
                    no: 3,
                    name: 'owners',
                    kind: 'scalar',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: 9 /*ScalarType.STRING*/,
                },
            ]
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.decentralizedNamespace = ''
        message.threshold = 0
        message.owners = []
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string decentralized_namespace */ 1:
                    message.decentralizedNamespace = reader.string()
                    break
                case /* int32 threshold */ 2:
                    message.threshold = reader.int32()
                    break
                case /* repeated string owners */ 3:
                    message.owners.push(reader.string())
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string decentralized_namespace = 1; */
        if (message.decentralizedNamespace !== '')
            writer
                .tag(1, WireType.LengthDelimited)
                .string(message.decentralizedNamespace)
        /* int32 threshold = 2; */
        if (message.threshold !== 0)
            writer.tag(2, WireType.Varint).int32(message.threshold)
        /* repeated string owners = 3; */
        for (let i = 0; i < message.owners.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.owners[i])
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.DecentralizedNamespaceDefinition
 */
export const DecentralizedNamespaceDefinition =
    new DecentralizedNamespaceDefinition$Type()
// @generated message type with reflection information, may provide speed optimized methods
class OwnerToKeyMapping$Type extends MessageType {
    constructor() {
        super('com.digitalasset.canton.protocol.v30.OwnerToKeyMapping', [
            {
                no: 1,
                name: 'member',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'public_keys',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => PublicKey,
            },
        ])
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.member = ''
        message.publicKeys = []
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string member */ 1:
                    message.member = reader.string()
                    break
                case /* repeated com.digitalasset.canton.crypto.v30.PublicKey public_keys */ 2:
                    message.publicKeys.push(
                        PublicKey.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string member = 1; */
        if (message.member !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.member)
        /* repeated com.digitalasset.canton.crypto.v30.PublicKey public_keys = 2; */
        for (let i = 0; i < message.publicKeys.length; i++)
            PublicKey.internalBinaryWrite(
                message.publicKeys[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.OwnerToKeyMapping
 */
export const OwnerToKeyMapping = new OwnerToKeyMapping$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PartyToKeyMapping$Type extends MessageType {
    constructor() {
        super('com.digitalasset.canton.protocol.v30.PartyToKeyMapping', [
            {
                no: 1,
                name: 'party',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 3,
                name: 'threshold',
                kind: 'scalar',
                T: 13 /*ScalarType.UINT32*/,
            },
            {
                no: 4,
                name: 'signing_keys',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => SigningPublicKey,
            },
        ])
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.party = ''
        message.threshold = 0
        message.signingKeys = []
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string party */ 1:
                    message.party = reader.string()
                    break
                case /* uint32 threshold */ 3:
                    message.threshold = reader.uint32()
                    break
                case /* repeated com.digitalasset.canton.crypto.v30.SigningPublicKey signing_keys */ 4:
                    message.signingKeys.push(
                        SigningPublicKey.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string party = 1; */
        if (message.party !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.party)
        /* uint32 threshold = 3; */
        if (message.threshold !== 0)
            writer.tag(3, WireType.Varint).uint32(message.threshold)
        /* repeated com.digitalasset.canton.crypto.v30.SigningPublicKey signing_keys = 4; */
        for (let i = 0; i < message.signingKeys.length; i++)
            SigningPublicKey.internalBinaryWrite(
                message.signingKeys[i],
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.PartyToKeyMapping
 */
export const PartyToKeyMapping = new PartyToKeyMapping$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SynchronizerTrustCertificate$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.SynchronizerTrustCertificate',
            [
                {
                    no: 1,
                    name: 'participant_uid',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'synchronizer_id',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
            ]
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.participantUid = ''
        message.synchronizerId = ''
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string participant_uid */ 1:
                    message.participantUid = reader.string()
                    break
                case /* string synchronizer_id */ 2:
                    message.synchronizerId = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string participant_uid = 1; */
        if (message.participantUid !== '')
            writer
                .tag(1, WireType.LengthDelimited)
                .string(message.participantUid)
        /* string synchronizer_id = 2; */
        if (message.synchronizerId !== '')
            writer
                .tag(2, WireType.LengthDelimited)
                .string(message.synchronizerId)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.SynchronizerTrustCertificate
 */
export const SynchronizerTrustCertificate =
    new SynchronizerTrustCertificate$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ParticipantSynchronizerPermission$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.ParticipantSynchronizerPermission',
            [
                {
                    no: 1,
                    name: 'synchronizer_id',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'participant_uid',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 3,
                    name: 'permission',
                    kind: 'enum',
                    T: () => [
                        'com.digitalasset.canton.protocol.v30.Enums.ParticipantPermission',
                        Enums_ParticipantPermission,
                        'PARTICIPANT_PERMISSION_',
                    ],
                },
                {
                    no: 4,
                    name: 'limits',
                    kind: 'message',
                    T: () => ParticipantSynchronizerLimits,
                },
                {
                    no: 5,
                    name: 'login_after',
                    kind: 'scalar',
                    opt: true,
                    T: 3 /*ScalarType.INT64*/,
                    L: 0 /*LongType.BIGINT*/,
                },
            ]
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.synchronizerId = ''
        message.participantUid = ''
        message.permission = 0
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string synchronizer_id */ 1:
                    message.synchronizerId = reader.string()
                    break
                case /* string participant_uid */ 2:
                    message.participantUid = reader.string()
                    break
                case /* com.digitalasset.canton.protocol.v30.Enums.ParticipantPermission permission */ 3:
                    message.permission = reader.int32()
                    break
                case /* com.digitalasset.canton.protocol.v30.ParticipantSynchronizerLimits limits */ 4:
                    message.limits =
                        ParticipantSynchronizerLimits.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.limits
                        )
                    break
                case /* optional int64 login_after */ 5:
                    message.loginAfter = reader.int64().toBigInt()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string synchronizer_id = 1; */
        if (message.synchronizerId !== '')
            writer
                .tag(1, WireType.LengthDelimited)
                .string(message.synchronizerId)
        /* string participant_uid = 2; */
        if (message.participantUid !== '')
            writer
                .tag(2, WireType.LengthDelimited)
                .string(message.participantUid)
        /* com.digitalasset.canton.protocol.v30.Enums.ParticipantPermission permission = 3; */
        if (message.permission !== 0)
            writer.tag(3, WireType.Varint).int32(message.permission)
        /* com.digitalasset.canton.protocol.v30.ParticipantSynchronizerLimits limits = 4; */
        if (message.limits)
            ParticipantSynchronizerLimits.internalBinaryWrite(
                message.limits,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* optional int64 login_after = 5; */
        if (message.loginAfter !== undefined)
            writer.tag(5, WireType.Varint).int64(message.loginAfter)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.ParticipantSynchronizerPermission
 */
export const ParticipantSynchronizerPermission =
    new ParticipantSynchronizerPermission$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PartyHostingLimits$Type extends MessageType {
    constructor() {
        super('com.digitalasset.canton.protocol.v30.PartyHostingLimits', [
            {
                no: 1,
                name: 'synchronizer_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'party',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
        ])
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.synchronizerId = ''
        message.party = ''
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string synchronizer_id */ 1:
                    message.synchronizerId = reader.string()
                    break
                case /* string party */ 2:
                    message.party = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string synchronizer_id = 1; */
        if (message.synchronizerId !== '')
            writer
                .tag(1, WireType.LengthDelimited)
                .string(message.synchronizerId)
        /* string party = 2; */
        if (message.party !== '')
            writer.tag(2, WireType.LengthDelimited).string(message.party)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.PartyHostingLimits
 */
export const PartyHostingLimits = new PartyHostingLimits$Type()
// @generated message type with reflection information, may provide speed optimized methods
class VettedPackages$Type extends MessageType {
    constructor() {
        super('com.digitalasset.canton.protocol.v30.VettedPackages', [
            {
                no: 1,
                name: 'participant_uid',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'package_ids',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 4,
                name: 'packages',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => VettedPackages_VettedPackage,
            },
        ])
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.participantUid = ''
        message.packageIds = []
        message.packages = []
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string participant_uid */ 1:
                    message.participantUid = reader.string()
                    break
                case /* repeated string package_ids = 2 [deprecated = true] */ 2:
                    message.packageIds.push(reader.string())
                    break
                case /* repeated com.digitalasset.canton.protocol.v30.VettedPackages.VettedPackage packages */ 4:
                    message.packages.push(
                        VettedPackages_VettedPackage.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string participant_uid = 1; */
        if (message.participantUid !== '')
            writer
                .tag(1, WireType.LengthDelimited)
                .string(message.participantUid)
        /* repeated string package_ids = 2 [deprecated = true]; */
        for (let i = 0; i < message.packageIds.length; i++)
            writer
                .tag(2, WireType.LengthDelimited)
                .string(message.packageIds[i])
        /* repeated com.digitalasset.canton.protocol.v30.VettedPackages.VettedPackage packages = 4; */
        for (let i = 0; i < message.packages.length; i++)
            VettedPackages_VettedPackage.internalBinaryWrite(
                message.packages[i],
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.VettedPackages
 */
export const VettedPackages = new VettedPackages$Type()
// @generated message type with reflection information, may provide speed optimized methods
class VettedPackages_VettedPackage$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.VettedPackages.VettedPackage',
            [
                {
                    no: 1,
                    name: 'package_id',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'valid_from_inclusive',
                    kind: 'message',
                    T: () => Timestamp,
                },
                {
                    no: 3,
                    name: 'valid_until_exclusive',
                    kind: 'message',
                    T: () => Timestamp,
                },
            ]
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.packageId = ''
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string package_id */ 1:
                    message.packageId = reader.string()
                    break
                case /* google.protobuf.Timestamp valid_from_inclusive */ 2:
                    message.validFromInclusive = Timestamp.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.validFromInclusive
                    )
                    break
                case /* google.protobuf.Timestamp valid_until_exclusive */ 3:
                    message.validUntilExclusive = Timestamp.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.validUntilExclusive
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string package_id = 1; */
        if (message.packageId !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.packageId)
        /* google.protobuf.Timestamp valid_from_inclusive = 2; */
        if (message.validFromInclusive)
            Timestamp.internalBinaryWrite(
                message.validFromInclusive,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* google.protobuf.Timestamp valid_until_exclusive = 3; */
        if (message.validUntilExclusive)
            Timestamp.internalBinaryWrite(
                message.validUntilExclusive,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.VettedPackages.VettedPackage
 */
export const VettedPackages_VettedPackage =
    new VettedPackages_VettedPackage$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PartyToParticipant$Type extends MessageType {
    constructor() {
        super('com.digitalasset.canton.protocol.v30.PartyToParticipant', [
            {
                no: 1,
                name: 'party',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'threshold',
                kind: 'scalar',
                T: 13 /*ScalarType.UINT32*/,
            },
            {
                no: 3,
                name: 'participants',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => PartyToParticipant_HostingParticipant,
            },
        ])
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.party = ''
        message.threshold = 0
        message.participants = []
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string party */ 1:
                    message.party = reader.string()
                    break
                case /* uint32 threshold */ 2:
                    message.threshold = reader.uint32()
                    break
                case /* repeated com.digitalasset.canton.protocol.v30.PartyToParticipant.HostingParticipant participants */ 3:
                    message.participants.push(
                        PartyToParticipant_HostingParticipant.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string party = 1; */
        if (message.party !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.party)
        /* uint32 threshold = 2; */
        if (message.threshold !== 0)
            writer.tag(2, WireType.Varint).uint32(message.threshold)
        /* repeated com.digitalasset.canton.protocol.v30.PartyToParticipant.HostingParticipant participants = 3; */
        for (let i = 0; i < message.participants.length; i++)
            PartyToParticipant_HostingParticipant.internalBinaryWrite(
                message.participants[i],
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.PartyToParticipant
 */
export const PartyToParticipant = new PartyToParticipant$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PartyToParticipant_HostingParticipant$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.PartyToParticipant.HostingParticipant',
            [
                {
                    no: 1,
                    name: 'participant_uid',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'permission',
                    kind: 'enum',
                    T: () => [
                        'com.digitalasset.canton.protocol.v30.Enums.ParticipantPermission',
                        Enums_ParticipantPermission,
                        'PARTICIPANT_PERMISSION_',
                    ],
                },
                {
                    no: 3,
                    name: 'onboarding',
                    kind: 'message',
                    T: () => PartyToParticipant_HostingParticipant_Onboarding,
                },
            ]
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.participantUid = ''
        message.permission = 0
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string participant_uid */ 1:
                    message.participantUid = reader.string()
                    break
                case /* com.digitalasset.canton.protocol.v30.Enums.ParticipantPermission permission */ 2:
                    message.permission = reader.int32()
                    break
                case /* com.digitalasset.canton.protocol.v30.PartyToParticipant.HostingParticipant.Onboarding onboarding */ 3:
                    message.onboarding =
                        PartyToParticipant_HostingParticipant_Onboarding.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.onboarding
                        )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string participant_uid = 1; */
        if (message.participantUid !== '')
            writer
                .tag(1, WireType.LengthDelimited)
                .string(message.participantUid)
        /* com.digitalasset.canton.protocol.v30.Enums.ParticipantPermission permission = 2; */
        if (message.permission !== 0)
            writer.tag(2, WireType.Varint).int32(message.permission)
        /* com.digitalasset.canton.protocol.v30.PartyToParticipant.HostingParticipant.Onboarding onboarding = 3; */
        if (message.onboarding)
            PartyToParticipant_HostingParticipant_Onboarding.internalBinaryWrite(
                message.onboarding,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.PartyToParticipant.HostingParticipant
 */
export const PartyToParticipant_HostingParticipant =
    new PartyToParticipant_HostingParticipant$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PartyToParticipant_HostingParticipant_Onboarding$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.PartyToParticipant.HostingParticipant.Onboarding',
            []
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.PartyToParticipant.HostingParticipant.Onboarding
 */
export const PartyToParticipant_HostingParticipant_Onboarding =
    new PartyToParticipant_HostingParticipant_Onboarding$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SynchronizerParametersState$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.SynchronizerParametersState',
            [
                {
                    no: 1,
                    name: 'synchronizer_id',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'synchronizer_parameters',
                    kind: 'message',
                    T: () => DynamicSynchronizerParameters,
                },
            ]
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.synchronizerId = ''
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string synchronizer_id */ 1:
                    message.synchronizerId = reader.string()
                    break
                case /* com.digitalasset.canton.protocol.v30.DynamicSynchronizerParameters synchronizer_parameters */ 2:
                    message.synchronizerParameters =
                        DynamicSynchronizerParameters.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.synchronizerParameters
                        )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string synchronizer_id = 1; */
        if (message.synchronizerId !== '')
            writer
                .tag(1, WireType.LengthDelimited)
                .string(message.synchronizerId)
        /* com.digitalasset.canton.protocol.v30.DynamicSynchronizerParameters synchronizer_parameters = 2; */
        if (message.synchronizerParameters)
            DynamicSynchronizerParameters.internalBinaryWrite(
                message.synchronizerParameters,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.SynchronizerParametersState
 */
export const SynchronizerParametersState =
    new SynchronizerParametersState$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DynamicSequencingParametersState$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.DynamicSequencingParametersState',
            [
                {
                    no: 1,
                    name: 'synchronizer_id',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'sequencing_parameters',
                    kind: 'message',
                    T: () => DynamicSequencingParameters,
                },
            ]
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.synchronizerId = ''
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string synchronizer_id */ 1:
                    message.synchronizerId = reader.string()
                    break
                case /* com.digitalasset.canton.protocol.v30.DynamicSequencingParameters sequencing_parameters */ 2:
                    message.sequencingParameters =
                        DynamicSequencingParameters.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.sequencingParameters
                        )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string synchronizer_id = 1; */
        if (message.synchronizerId !== '')
            writer
                .tag(1, WireType.LengthDelimited)
                .string(message.synchronizerId)
        /* com.digitalasset.canton.protocol.v30.DynamicSequencingParameters sequencing_parameters = 2; */
        if (message.sequencingParameters)
            DynamicSequencingParameters.internalBinaryWrite(
                message.sequencingParameters,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.DynamicSequencingParametersState
 */
export const DynamicSequencingParametersState =
    new DynamicSequencingParametersState$Type()
// @generated message type with reflection information, may provide speed optimized methods
class MediatorSynchronizerState$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.MediatorSynchronizerState',
            [
                {
                    no: 1,
                    name: 'synchronizer_id',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'group',
                    kind: 'scalar',
                    T: 13 /*ScalarType.UINT32*/,
                },
                {
                    no: 3,
                    name: 'threshold',
                    kind: 'scalar',
                    T: 13 /*ScalarType.UINT32*/,
                },
                {
                    no: 4,
                    name: 'active',
                    kind: 'scalar',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 5,
                    name: 'observers',
                    kind: 'scalar',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: 9 /*ScalarType.STRING*/,
                },
            ]
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.synchronizerId = ''
        message.group = 0
        message.threshold = 0
        message.active = []
        message.observers = []
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string synchronizer_id */ 1:
                    message.synchronizerId = reader.string()
                    break
                case /* uint32 group */ 2:
                    message.group = reader.uint32()
                    break
                case /* uint32 threshold */ 3:
                    message.threshold = reader.uint32()
                    break
                case /* repeated string active */ 4:
                    message.active.push(reader.string())
                    break
                case /* repeated string observers */ 5:
                    message.observers.push(reader.string())
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string synchronizer_id = 1; */
        if (message.synchronizerId !== '')
            writer
                .tag(1, WireType.LengthDelimited)
                .string(message.synchronizerId)
        /* uint32 group = 2; */
        if (message.group !== 0)
            writer.tag(2, WireType.Varint).uint32(message.group)
        /* uint32 threshold = 3; */
        if (message.threshold !== 0)
            writer.tag(3, WireType.Varint).uint32(message.threshold)
        /* repeated string active = 4; */
        for (let i = 0; i < message.active.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.active[i])
        /* repeated string observers = 5; */
        for (let i = 0; i < message.observers.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.observers[i])
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.MediatorSynchronizerState
 */
export const MediatorSynchronizerState = new MediatorSynchronizerState$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SequencerSynchronizerState$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.SequencerSynchronizerState',
            [
                {
                    no: 1,
                    name: 'synchronizer_id',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'threshold',
                    kind: 'scalar',
                    T: 13 /*ScalarType.UINT32*/,
                },
                {
                    no: 3,
                    name: 'active',
                    kind: 'scalar',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 4,
                    name: 'observers',
                    kind: 'scalar',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: 9 /*ScalarType.STRING*/,
                },
            ]
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.synchronizerId = ''
        message.threshold = 0
        message.active = []
        message.observers = []
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string synchronizer_id */ 1:
                    message.synchronizerId = reader.string()
                    break
                case /* uint32 threshold */ 2:
                    message.threshold = reader.uint32()
                    break
                case /* repeated string active */ 3:
                    message.active.push(reader.string())
                    break
                case /* repeated string observers */ 4:
                    message.observers.push(reader.string())
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string synchronizer_id = 1; */
        if (message.synchronizerId !== '')
            writer
                .tag(1, WireType.LengthDelimited)
                .string(message.synchronizerId)
        /* uint32 threshold = 2; */
        if (message.threshold !== 0)
            writer.tag(2, WireType.Varint).uint32(message.threshold)
        /* repeated string active = 3; */
        for (let i = 0; i < message.active.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.active[i])
        /* repeated string observers = 4; */
        for (let i = 0; i < message.observers.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.observers[i])
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.SequencerSynchronizerState
 */
export const SequencerSynchronizerState = new SequencerSynchronizerState$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PurgeTopologyTransaction$Type extends MessageType {
    constructor() {
        super('com.digitalasset.canton.protocol.v30.PurgeTopologyTransaction', [
            {
                no: 1,
                name: 'synchronizer_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'mappings',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => TopologyMapping,
            },
        ])
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.synchronizerId = ''
        message.mappings = []
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string synchronizer_id */ 1:
                    message.synchronizerId = reader.string()
                    break
                case /* repeated com.digitalasset.canton.protocol.v30.TopologyMapping mappings */ 2:
                    message.mappings.push(
                        TopologyMapping.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string synchronizer_id = 1; */
        if (message.synchronizerId !== '')
            writer
                .tag(1, WireType.LengthDelimited)
                .string(message.synchronizerId)
        /* repeated com.digitalasset.canton.protocol.v30.TopologyMapping mappings = 2; */
        for (let i = 0; i < message.mappings.length; i++)
            TopologyMapping.internalBinaryWrite(
                message.mappings[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.PurgeTopologyTransaction
 */
export const PurgeTopologyTransaction = new PurgeTopologyTransaction$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SynchronizerUpgradeAnnouncement$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.SynchronizerUpgradeAnnouncement',
            [
                {
                    no: 1,
                    name: 'physical_synchronizer_id',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'successor_physical_synchronizer_id',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 3,
                    name: 'upgrade_time',
                    kind: 'message',
                    T: () => Timestamp,
                },
            ]
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.physicalSynchronizerId = ''
        message.successorPhysicalSynchronizerId = ''
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string physical_synchronizer_id */ 1:
                    message.physicalSynchronizerId = reader.string()
                    break
                case /* string successor_physical_synchronizer_id */ 2:
                    message.successorPhysicalSynchronizerId = reader.string()
                    break
                case /* google.protobuf.Timestamp upgrade_time */ 3:
                    message.upgradeTime = Timestamp.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.upgradeTime
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string physical_synchronizer_id = 1; */
        if (message.physicalSynchronizerId !== '')
            writer
                .tag(1, WireType.LengthDelimited)
                .string(message.physicalSynchronizerId)
        /* string successor_physical_synchronizer_id = 2; */
        if (message.successorPhysicalSynchronizerId !== '')
            writer
                .tag(2, WireType.LengthDelimited)
                .string(message.successorPhysicalSynchronizerId)
        /* google.protobuf.Timestamp upgrade_time = 3; */
        if (message.upgradeTime)
            Timestamp.internalBinaryWrite(
                message.upgradeTime,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.SynchronizerUpgradeAnnouncement
 */
export const SynchronizerUpgradeAnnouncement =
    new SynchronizerUpgradeAnnouncement$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SequencerConnectionSuccessor$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.SequencerConnectionSuccessor',
            [
                {
                    no: 1,
                    name: 'sequencer_id',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'physical_synchronizer_id',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 3,
                    name: 'connection',
                    kind: 'message',
                    T: () => SequencerConnectionSuccessor_SequencerConnection,
                },
            ]
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.sequencerId = ''
        message.physicalSynchronizerId = ''
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string sequencer_id */ 1:
                    message.sequencerId = reader.string()
                    break
                case /* string physical_synchronizer_id */ 2:
                    message.physicalSynchronizerId = reader.string()
                    break
                case /* com.digitalasset.canton.protocol.v30.SequencerConnectionSuccessor.SequencerConnection connection */ 3:
                    message.connection =
                        SequencerConnectionSuccessor_SequencerConnection.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.connection
                        )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string sequencer_id = 1; */
        if (message.sequencerId !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.sequencerId)
        /* string physical_synchronizer_id = 2; */
        if (message.physicalSynchronizerId !== '')
            writer
                .tag(2, WireType.LengthDelimited)
                .string(message.physicalSynchronizerId)
        /* com.digitalasset.canton.protocol.v30.SequencerConnectionSuccessor.SequencerConnection connection = 3; */
        if (message.connection)
            SequencerConnectionSuccessor_SequencerConnection.internalBinaryWrite(
                message.connection,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.SequencerConnectionSuccessor
 */
export const SequencerConnectionSuccessor =
    new SequencerConnectionSuccessor$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SequencerConnectionSuccessor_SequencerConnection$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.SequencerConnectionSuccessor.SequencerConnection',
            [
                {
                    no: 1,
                    name: 'grpc',
                    kind: 'message',
                    oneof: 'connectionType',
                    T: () =>
                        SequencerConnectionSuccessor_SequencerConnection_Grpc,
                },
            ]
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.connectionType = { oneofKind: undefined }
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.protocol.v30.SequencerConnectionSuccessor.SequencerConnection.Grpc grpc */ 1:
                    message.connectionType = {
                        oneofKind: 'grpc',
                        grpc: SequencerConnectionSuccessor_SequencerConnection_Grpc.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.connectionType.grpc
                        ),
                    }
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* com.digitalasset.canton.protocol.v30.SequencerConnectionSuccessor.SequencerConnection.Grpc grpc = 1; */
        if (message.connectionType.oneofKind === 'grpc')
            SequencerConnectionSuccessor_SequencerConnection_Grpc.internalBinaryWrite(
                message.connectionType.grpc,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.SequencerConnectionSuccessor.SequencerConnection
 */
export const SequencerConnectionSuccessor_SequencerConnection =
    new SequencerConnectionSuccessor_SequencerConnection$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SequencerConnectionSuccessor_SequencerConnection_Grpc$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.SequencerConnectionSuccessor.SequencerConnection.Grpc',
            [
                {
                    no: 1,
                    name: 'endpoints',
                    kind: 'scalar',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'custom_trust_certificates',
                    kind: 'scalar',
                    opt: true,
                    T: 12 /*ScalarType.BYTES*/,
                },
            ]
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.endpoints = []
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated string endpoints */ 1:
                    message.endpoints.push(reader.string())
                    break
                case /* optional bytes custom_trust_certificates */ 2:
                    message.customTrustCertificates = reader.bytes()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated string endpoints = 1; */
        for (let i = 0; i < message.endpoints.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.endpoints[i])
        /* optional bytes custom_trust_certificates = 2; */
        if (message.customTrustCertificates !== undefined)
            writer
                .tag(2, WireType.LengthDelimited)
                .bytes(message.customTrustCertificates)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.SequencerConnectionSuccessor.SequencerConnection.Grpc
 */
export const SequencerConnectionSuccessor_SequencerConnection_Grpc =
    new SequencerConnectionSuccessor_SequencerConnection_Grpc$Type()
// @generated message type with reflection information, may provide speed optimized methods
class TopologyMapping$Type extends MessageType {
    constructor() {
        super('com.digitalasset.canton.protocol.v30.TopologyMapping', [
            {
                no: 1,
                name: 'namespace_delegation',
                kind: 'message',
                oneof: 'mapping',
                T: () => NamespaceDelegation,
            },
            {
                no: 3,
                name: 'decentralized_namespace_definition',
                kind: 'message',
                oneof: 'mapping',
                T: () => DecentralizedNamespaceDefinition,
            },
            {
                no: 4,
                name: 'owner_to_key_mapping',
                kind: 'message',
                oneof: 'mapping',
                T: () => OwnerToKeyMapping,
            },
            {
                no: 5,
                name: 'synchronizer_trust_certificate',
                kind: 'message',
                oneof: 'mapping',
                T: () => SynchronizerTrustCertificate,
            },
            {
                no: 6,
                name: 'participant_permission',
                kind: 'message',
                oneof: 'mapping',
                T: () => ParticipantSynchronizerPermission,
            },
            {
                no: 7,
                name: 'party_hosting_limits',
                kind: 'message',
                oneof: 'mapping',
                T: () => PartyHostingLimits,
            },
            {
                no: 8,
                name: 'vetted_packages',
                kind: 'message',
                oneof: 'mapping',
                T: () => VettedPackages,
            },
            {
                no: 9,
                name: 'party_to_participant',
                kind: 'message',
                oneof: 'mapping',
                T: () => PartyToParticipant,
            },
            {
                no: 11,
                name: 'synchronizer_parameters_state',
                kind: 'message',
                oneof: 'mapping',
                T: () => SynchronizerParametersState,
            },
            {
                no: 12,
                name: 'mediator_synchronizer_state',
                kind: 'message',
                oneof: 'mapping',
                T: () => MediatorSynchronizerState,
            },
            {
                no: 13,
                name: 'sequencer_synchronizer_state',
                kind: 'message',
                oneof: 'mapping',
                T: () => SequencerSynchronizerState,
            },
            {
                no: 14,
                name: 'purge_topology_txs',
                kind: 'message',
                oneof: 'mapping',
                T: () => PurgeTopologyTransaction,
            },
            {
                no: 15,
                name: 'sequencing_dynamic_parameters_state',
                kind: 'message',
                oneof: 'mapping',
                T: () => DynamicSequencingParametersState,
            },
            {
                no: 16,
                name: 'party_to_key_mapping',
                kind: 'message',
                oneof: 'mapping',
                T: () => PartyToKeyMapping,
            },
            {
                no: 17,
                name: 'synchronizer_upgrade_announcement',
                kind: 'message',
                oneof: 'mapping',
                T: () => SynchronizerUpgradeAnnouncement,
            },
            {
                no: 18,
                name: 'sequencer_connection_successor',
                kind: 'message',
                oneof: 'mapping',
                T: () => SequencerConnectionSuccessor,
            },
        ])
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.mapping = { oneofKind: undefined }
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.protocol.v30.NamespaceDelegation namespace_delegation */ 1:
                    message.mapping = {
                        oneofKind: 'namespaceDelegation',
                        namespaceDelegation:
                            NamespaceDelegation.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                message.mapping.namespaceDelegation
                            ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.DecentralizedNamespaceDefinition decentralized_namespace_definition */ 3:
                    message.mapping = {
                        oneofKind: 'decentralizedNamespaceDefinition',
                        decentralizedNamespaceDefinition:
                            DecentralizedNamespaceDefinition.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                message.mapping.decentralizedNamespaceDefinition
                            ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.OwnerToKeyMapping owner_to_key_mapping */ 4:
                    message.mapping = {
                        oneofKind: 'ownerToKeyMapping',
                        ownerToKeyMapping: OwnerToKeyMapping.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.mapping.ownerToKeyMapping
                        ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.SynchronizerTrustCertificate synchronizer_trust_certificate */ 5:
                    message.mapping = {
                        oneofKind: 'synchronizerTrustCertificate',
                        synchronizerTrustCertificate:
                            SynchronizerTrustCertificate.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                message.mapping.synchronizerTrustCertificate
                            ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.ParticipantSynchronizerPermission participant_permission */ 6:
                    message.mapping = {
                        oneofKind: 'participantPermission',
                        participantPermission:
                            ParticipantSynchronizerPermission.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                message.mapping.participantPermission
                            ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.PartyHostingLimits party_hosting_limits */ 7:
                    message.mapping = {
                        oneofKind: 'partyHostingLimits',
                        partyHostingLimits:
                            PartyHostingLimits.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                message.mapping.partyHostingLimits
                            ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.VettedPackages vetted_packages */ 8:
                    message.mapping = {
                        oneofKind: 'vettedPackages',
                        vettedPackages: VettedPackages.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.mapping.vettedPackages
                        ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.PartyToParticipant party_to_participant */ 9:
                    message.mapping = {
                        oneofKind: 'partyToParticipant',
                        partyToParticipant:
                            PartyToParticipant.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                message.mapping.partyToParticipant
                            ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.SynchronizerParametersState synchronizer_parameters_state */ 11:
                    message.mapping = {
                        oneofKind: 'synchronizerParametersState',
                        synchronizerParametersState:
                            SynchronizerParametersState.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                message.mapping.synchronizerParametersState
                            ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.MediatorSynchronizerState mediator_synchronizer_state */ 12:
                    message.mapping = {
                        oneofKind: 'mediatorSynchronizerState',
                        mediatorSynchronizerState:
                            MediatorSynchronizerState.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                message.mapping.mediatorSynchronizerState
                            ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.SequencerSynchronizerState sequencer_synchronizer_state */ 13:
                    message.mapping = {
                        oneofKind: 'sequencerSynchronizerState',
                        sequencerSynchronizerState:
                            SequencerSynchronizerState.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                message.mapping.sequencerSynchronizerState
                            ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.PurgeTopologyTransaction purge_topology_txs */ 14:
                    message.mapping = {
                        oneofKind: 'purgeTopologyTxs',
                        purgeTopologyTxs:
                            PurgeTopologyTransaction.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                message.mapping.purgeTopologyTxs
                            ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.DynamicSequencingParametersState sequencing_dynamic_parameters_state */ 15:
                    message.mapping = {
                        oneofKind: 'sequencingDynamicParametersState',
                        sequencingDynamicParametersState:
                            DynamicSequencingParametersState.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                message.mapping.sequencingDynamicParametersState
                            ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.PartyToKeyMapping party_to_key_mapping */ 16:
                    message.mapping = {
                        oneofKind: 'partyToKeyMapping',
                        partyToKeyMapping: PartyToKeyMapping.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.mapping.partyToKeyMapping
                        ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.SynchronizerUpgradeAnnouncement synchronizer_upgrade_announcement */ 17:
                    message.mapping = {
                        oneofKind: 'synchronizerUpgradeAnnouncement',
                        synchronizerUpgradeAnnouncement:
                            SynchronizerUpgradeAnnouncement.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                message.mapping.synchronizerUpgradeAnnouncement
                            ),
                    }
                    break
                case /* com.digitalasset.canton.protocol.v30.SequencerConnectionSuccessor sequencer_connection_successor */ 18:
                    message.mapping = {
                        oneofKind: 'sequencerConnectionSuccessor',
                        sequencerConnectionSuccessor:
                            SequencerConnectionSuccessor.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                message.mapping.sequencerConnectionSuccessor
                            ),
                    }
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* com.digitalasset.canton.protocol.v30.NamespaceDelegation namespace_delegation = 1; */
        if (message.mapping.oneofKind === 'namespaceDelegation')
            NamespaceDelegation.internalBinaryWrite(
                message.mapping.namespaceDelegation,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.DecentralizedNamespaceDefinition decentralized_namespace_definition = 3; */
        if (message.mapping.oneofKind === 'decentralizedNamespaceDefinition')
            DecentralizedNamespaceDefinition.internalBinaryWrite(
                message.mapping.decentralizedNamespaceDefinition,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.OwnerToKeyMapping owner_to_key_mapping = 4; */
        if (message.mapping.oneofKind === 'ownerToKeyMapping')
            OwnerToKeyMapping.internalBinaryWrite(
                message.mapping.ownerToKeyMapping,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.SynchronizerTrustCertificate synchronizer_trust_certificate = 5; */
        if (message.mapping.oneofKind === 'synchronizerTrustCertificate')
            SynchronizerTrustCertificate.internalBinaryWrite(
                message.mapping.synchronizerTrustCertificate,
                writer.tag(5, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.ParticipantSynchronizerPermission participant_permission = 6; */
        if (message.mapping.oneofKind === 'participantPermission')
            ParticipantSynchronizerPermission.internalBinaryWrite(
                message.mapping.participantPermission,
                writer.tag(6, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.PartyHostingLimits party_hosting_limits = 7; */
        if (message.mapping.oneofKind === 'partyHostingLimits')
            PartyHostingLimits.internalBinaryWrite(
                message.mapping.partyHostingLimits,
                writer.tag(7, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.VettedPackages vetted_packages = 8; */
        if (message.mapping.oneofKind === 'vettedPackages')
            VettedPackages.internalBinaryWrite(
                message.mapping.vettedPackages,
                writer.tag(8, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.PartyToParticipant party_to_participant = 9; */
        if (message.mapping.oneofKind === 'partyToParticipant')
            PartyToParticipant.internalBinaryWrite(
                message.mapping.partyToParticipant,
                writer.tag(9, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.SynchronizerParametersState synchronizer_parameters_state = 11; */
        if (message.mapping.oneofKind === 'synchronizerParametersState')
            SynchronizerParametersState.internalBinaryWrite(
                message.mapping.synchronizerParametersState,
                writer.tag(11, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.MediatorSynchronizerState mediator_synchronizer_state = 12; */
        if (message.mapping.oneofKind === 'mediatorSynchronizerState')
            MediatorSynchronizerState.internalBinaryWrite(
                message.mapping.mediatorSynchronizerState,
                writer.tag(12, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.SequencerSynchronizerState sequencer_synchronizer_state = 13; */
        if (message.mapping.oneofKind === 'sequencerSynchronizerState')
            SequencerSynchronizerState.internalBinaryWrite(
                message.mapping.sequencerSynchronizerState,
                writer.tag(13, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.PurgeTopologyTransaction purge_topology_txs = 14; */
        if (message.mapping.oneofKind === 'purgeTopologyTxs')
            PurgeTopologyTransaction.internalBinaryWrite(
                message.mapping.purgeTopologyTxs,
                writer.tag(14, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.DynamicSequencingParametersState sequencing_dynamic_parameters_state = 15; */
        if (message.mapping.oneofKind === 'sequencingDynamicParametersState')
            DynamicSequencingParametersState.internalBinaryWrite(
                message.mapping.sequencingDynamicParametersState,
                writer.tag(15, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.PartyToKeyMapping party_to_key_mapping = 16; */
        if (message.mapping.oneofKind === 'partyToKeyMapping')
            PartyToKeyMapping.internalBinaryWrite(
                message.mapping.partyToKeyMapping,
                writer.tag(16, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.SynchronizerUpgradeAnnouncement synchronizer_upgrade_announcement = 17; */
        if (message.mapping.oneofKind === 'synchronizerUpgradeAnnouncement')
            SynchronizerUpgradeAnnouncement.internalBinaryWrite(
                message.mapping.synchronizerUpgradeAnnouncement,
                writer.tag(17, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.protocol.v30.SequencerConnectionSuccessor sequencer_connection_successor = 18; */
        if (message.mapping.oneofKind === 'sequencerConnectionSuccessor')
            SequencerConnectionSuccessor.internalBinaryWrite(
                message.mapping.sequencerConnectionSuccessor,
                writer.tag(18, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.TopologyMapping
 */
export const TopologyMapping = new TopologyMapping$Type()
// @generated message type with reflection information, may provide speed optimized methods
class TopologyTransaction$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.TopologyTransaction',
            [
                {
                    no: 1,
                    name: 'operation',
                    kind: 'enum',
                    T: () => [
                        'com.digitalasset.canton.protocol.v30.Enums.TopologyChangeOp',
                        Enums_TopologyChangeOp,
                        'TOPOLOGY_CHANGE_OP_',
                    ],
                },
                {
                    no: 2,
                    name: 'serial',
                    kind: 'scalar',
                    T: 13 /*ScalarType.UINT32*/,
                },
                {
                    no: 3,
                    name: 'mapping',
                    kind: 'message',
                    T: () => TopologyMapping,
                },
            ],
            {
                'scalapb.message': {
                    companionExtends: [
                        'com.digitalasset.canton.version.AlphaProtoVersion',
                    ],
                },
            }
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.operation = 0
        message.serial = 0
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.protocol.v30.Enums.TopologyChangeOp operation */ 1:
                    message.operation = reader.int32()
                    break
                case /* uint32 serial */ 2:
                    message.serial = reader.uint32()
                    break
                case /* com.digitalasset.canton.protocol.v30.TopologyMapping mapping */ 3:
                    message.mapping = TopologyMapping.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.mapping
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* com.digitalasset.canton.protocol.v30.Enums.TopologyChangeOp operation = 1; */
        if (message.operation !== 0)
            writer.tag(1, WireType.Varint).int32(message.operation)
        /* uint32 serial = 2; */
        if (message.serial !== 0)
            writer.tag(2, WireType.Varint).uint32(message.serial)
        /* com.digitalasset.canton.protocol.v30.TopologyMapping mapping = 3; */
        if (message.mapping)
            TopologyMapping.internalBinaryWrite(
                message.mapping,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.TopologyTransaction
 */
export const TopologyTransaction = new TopologyTransaction$Type()
// @generated message type with reflection information, may provide speed optimized methods
class MultiTransactionSignatures$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.MultiTransactionSignatures',
            [
                {
                    no: 1,
                    name: 'transaction_hashes',
                    kind: 'scalar',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: 12 /*ScalarType.BYTES*/,
                },
                {
                    no: 2,
                    name: 'signatures',
                    kind: 'message',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: () => Signature,
                },
            ]
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.transactionHashes = []
        message.signatures = []
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated bytes transaction_hashes */ 1:
                    message.transactionHashes.push(reader.bytes())
                    break
                case /* repeated com.digitalasset.canton.crypto.v30.Signature signatures */ 2:
                    message.signatures.push(
                        Signature.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated bytes transaction_hashes = 1; */
        for (let i = 0; i < message.transactionHashes.length; i++)
            writer
                .tag(1, WireType.LengthDelimited)
                .bytes(message.transactionHashes[i])
        /* repeated com.digitalasset.canton.crypto.v30.Signature signatures = 2; */
        for (let i = 0; i < message.signatures.length; i++)
            Signature.internalBinaryWrite(
                message.signatures[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.MultiTransactionSignatures
 */
export const MultiTransactionSignatures = new MultiTransactionSignatures$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SignedTopologyTransaction$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.SignedTopologyTransaction',
            [
                {
                    no: 1,
                    name: 'transaction',
                    kind: 'scalar',
                    T: 12 /*ScalarType.BYTES*/,
                },
                {
                    no: 2,
                    name: 'signatures',
                    kind: 'message',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: () => Signature,
                },
                {
                    no: 3,
                    name: 'proposal',
                    kind: 'scalar',
                    T: 8 /*ScalarType.BOOL*/,
                },
                {
                    no: 4,
                    name: 'multi_transaction_signatures',
                    kind: 'message',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: () => MultiTransactionSignatures,
                },
            ],
            {
                'scalapb.message': {
                    companionExtends: [
                        'com.digitalasset.canton.version.AlphaProtoVersion',
                    ],
                },
            }
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.transaction = new Uint8Array(0)
        message.signatures = []
        message.proposal = false
        message.multiTransactionSignatures = []
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* bytes transaction */ 1:
                    message.transaction = reader.bytes()
                    break
                case /* repeated com.digitalasset.canton.crypto.v30.Signature signatures */ 2:
                    message.signatures.push(
                        Signature.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                case /* bool proposal */ 3:
                    message.proposal = reader.bool()
                    break
                case /* repeated com.digitalasset.canton.protocol.v30.MultiTransactionSignatures multi_transaction_signatures */ 4:
                    message.multiTransactionSignatures.push(
                        MultiTransactionSignatures.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* bytes transaction = 1; */
        if (message.transaction.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.transaction)
        /* repeated com.digitalasset.canton.crypto.v30.Signature signatures = 2; */
        for (let i = 0; i < message.signatures.length; i++)
            Signature.internalBinaryWrite(
                message.signatures[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* bool proposal = 3; */
        if (message.proposal !== false)
            writer.tag(3, WireType.Varint).bool(message.proposal)
        /* repeated com.digitalasset.canton.protocol.v30.MultiTransactionSignatures multi_transaction_signatures = 4; */
        for (let i = 0; i < message.multiTransactionSignatures.length; i++)
            MultiTransactionSignatures.internalBinaryWrite(
                message.multiTransactionSignatures[i],
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.SignedTopologyTransaction
 */
export const SignedTopologyTransaction = new SignedTopologyTransaction$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SignedTopologyTransactions$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.SignedTopologyTransactions',
            [
                {
                    no: 1,
                    name: 'signed_transaction',
                    kind: 'scalar',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: 12 /*ScalarType.BYTES*/,
                },
            ],
            {
                'scalapb.message': {
                    companionExtends: [
                        'com.digitalasset.canton.version.AlphaProtoVersion',
                    ],
                },
            }
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.signedTransaction = []
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated bytes signed_transaction */ 1:
                    message.signedTransaction.push(reader.bytes())
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* repeated bytes signed_transaction = 1; */
        for (let i = 0; i < message.signedTransaction.length; i++)
            writer
                .tag(1, WireType.LengthDelimited)
                .bytes(message.signedTransaction[i])
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.SignedTopologyTransactions
 */
export const SignedTopologyTransactions = new SignedTopologyTransactions$Type()
// @generated message type with reflection information, may provide speed optimized methods
class TopologyTransactionsBroadcast$Type extends MessageType {
    constructor() {
        super(
            'com.digitalasset.canton.protocol.v30.TopologyTransactionsBroadcast',
            [
                {
                    no: 1,
                    name: 'physical_synchronizer_id',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'signed_transactions',
                    kind: 'message',
                    T: () => SignedTopologyTransactions,
                },
            ],
            {
                'scalapb.message': {
                    companionExtends: [
                        'com.digitalasset.canton.version.AlphaProtoVersion',
                    ],
                },
            }
        )
    }
    create(value) {
        const message = globalThis.Object.create(this.messagePrototype)
        message.physicalSynchronizerId = ''
        if (value !== undefined) reflectionMergePartial(this, message, value)
        return message
    }
    internalBinaryRead(reader, length, options, target) {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string physical_synchronizer_id */ 1:
                    message.physicalSynchronizerId = reader.string()
                    break
                case /* com.digitalasset.canton.protocol.v30.SignedTopologyTransactions signed_transactions */ 2:
                    message.signedTransactions =
                        SignedTopologyTransactions.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.signedTransactions
                        )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(message, writer, options) {
        /* string physical_synchronizer_id = 1; */
        if (message.physicalSynchronizerId !== '')
            writer
                .tag(1, WireType.LengthDelimited)
                .string(message.physicalSynchronizerId)
        /* com.digitalasset.canton.protocol.v30.SignedTopologyTransactions signed_transactions = 2; */
        if (message.signedTransactions)
            SignedTopologyTransactions.internalBinaryWrite(
                message.signedTransactions,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.protocol.v30.TopologyTransactionsBroadcast
 */
export const TopologyTransactionsBroadcast =
    new TopologyTransactionsBroadcast$Type()
