// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/reassignment_commands.proto" (package "com.daml.ledger.api.v2", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
/**
 * @generated from protobuf message com.daml.ledger.api.v2.ReassignmentCommands
 */
export interface ReassignmentCommands {
    /**
     * Identifier of the on-ledger workflow that this command is a part of.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Optional
     *
     * @generated from protobuf field: string workflow_id = 1
     */
    workflowId: string
    /**
     * Uniquely identifies the participant user that issued the command.
     * Must be a valid UserIdString (as described in ``value.proto``).
     * Required unless authentication is used with a user token.
     * In that case, the token's user-id will be used for the request's user_id.
     *
     * @generated from protobuf field: string user_id = 2
     */
    userId: string
    /**
     * Uniquely identifies the command.
     * The triple (user_id, submitter, command_id) constitutes the change ID for the intended ledger change.
     * The change ID can be used for matching the intended ledger changes with all their completions.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string command_id = 3
     */
    commandId: string
    /**
     * Party on whose behalf the command should be executed.
     * If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
     * to act on behalf of the given party.
     * Must be a valid PartyIdString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string submitter = 4
     */
    submitter: string
    /**
     * A unique identifier to distinguish completions for different submissions with the same change ID.
     * Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
     * with the same change ID.
     * Must be a valid LedgerString (as described in ``value.proto``).
     *
     * If omitted, the participant or the committer may set a value of their choice.
     * Optional
     *
     * @generated from protobuf field: string submission_id = 5
     */
    submissionId: string
    /**
     * Individual elements of this reassignment. Must be non-empty.
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.ReassignmentCommand commands = 6
     */
    commands: ReassignmentCommand[]
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.ReassignmentCommand
 */
export interface ReassignmentCommand {
    /**
     * @generated from protobuf oneof: command
     */
    command:
        | {
              oneofKind: 'unassignCommand'
              /**
               * @generated from protobuf field: com.daml.ledger.api.v2.UnassignCommand unassign_command = 1
               */
              unassignCommand: UnassignCommand
          }
        | {
              oneofKind: 'assignCommand'
              /**
               * @generated from protobuf field: com.daml.ledger.api.v2.AssignCommand assign_command = 2
               */
              assignCommand: AssignCommand
          }
        | {
              oneofKind: undefined
          }
}
/**
 * Unassign a contract
 *
 * @generated from protobuf message com.daml.ledger.api.v2.UnassignCommand
 */
export interface UnassignCommand {
    /**
     * The ID of the contract the client wants to unassign.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string contract_id = 1
     */
    contractId: string
    /**
     * The ID of the source synchronizer
     * Must be a valid synchronizer id
     * Required
     *
     * @generated from protobuf field: string source = 2
     */
    source: string
    /**
     * The ID of the target synchronizer
     * Must be a valid synchronizer id
     * Required
     *
     * @generated from protobuf field: string target = 3
     */
    target: string
}
/**
 * Assign a contract
 *
 * @generated from protobuf message com.daml.ledger.api.v2.AssignCommand
 */
export interface AssignCommand {
    /**
     * The ID from the unassigned event to be completed by this assignment.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string unassign_id = 1
     */
    unassignId: string
    /**
     * The ID of the source synchronizer
     * Must be a valid synchronizer id
     * Required
     *
     * @generated from protobuf field: string source = 2
     */
    source: string
    /**
     * The ID of the target synchronizer
     * Must be a valid synchronizer id
     * Required
     *
     * @generated from protobuf field: string target = 3
     */
    target: string
}
// @generated message type with reflection information, may provide speed optimized methods
class ReassignmentCommands$Type extends MessageType<ReassignmentCommands> {
    constructor() {
        super('com.daml.ledger.api.v2.ReassignmentCommands', [
            {
                no: 1,
                name: 'workflow_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'user_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 3,
                name: 'command_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 4,
                name: 'submitter',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 5,
                name: 'submission_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 6,
                name: 'commands',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => ReassignmentCommand,
            },
        ])
    }
    create(value?: PartialMessage<ReassignmentCommands>): ReassignmentCommands {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.workflowId = ''
        message.userId = ''
        message.commandId = ''
        message.submitter = ''
        message.submissionId = ''
        message.commands = []
        if (value !== undefined)
            reflectionMergePartial<ReassignmentCommands>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ReassignmentCommands
    ): ReassignmentCommands {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string workflow_id */ 1:
                    message.workflowId = reader.string()
                    break
                case /* string user_id */ 2:
                    message.userId = reader.string()
                    break
                case /* string command_id */ 3:
                    message.commandId = reader.string()
                    break
                case /* string submitter */ 4:
                    message.submitter = reader.string()
                    break
                case /* string submission_id */ 5:
                    message.submissionId = reader.string()
                    break
                case /* repeated com.daml.ledger.api.v2.ReassignmentCommand commands */ 6:
                    message.commands.push(
                        ReassignmentCommand.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: ReassignmentCommands,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string workflow_id = 1; */
        if (message.workflowId !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.workflowId)
        /* string user_id = 2; */
        if (message.userId !== '')
            writer.tag(2, WireType.LengthDelimited).string(message.userId)
        /* string command_id = 3; */
        if (message.commandId !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.commandId)
        /* string submitter = 4; */
        if (message.submitter !== '')
            writer.tag(4, WireType.LengthDelimited).string(message.submitter)
        /* string submission_id = 5; */
        if (message.submissionId !== '')
            writer.tag(5, WireType.LengthDelimited).string(message.submissionId)
        /* repeated com.daml.ledger.api.v2.ReassignmentCommand commands = 6; */
        for (let i = 0; i < message.commands.length; i++)
            ReassignmentCommand.internalBinaryWrite(
                message.commands[i],
                writer.tag(6, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.ReassignmentCommands
 */
export const ReassignmentCommands = new ReassignmentCommands$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ReassignmentCommand$Type extends MessageType<ReassignmentCommand> {
    constructor() {
        super('com.daml.ledger.api.v2.ReassignmentCommand', [
            {
                no: 1,
                name: 'unassign_command',
                kind: 'message',
                oneof: 'command',
                T: () => UnassignCommand,
            },
            {
                no: 2,
                name: 'assign_command',
                kind: 'message',
                oneof: 'command',
                T: () => AssignCommand,
            },
        ])
    }
    create(value?: PartialMessage<ReassignmentCommand>): ReassignmentCommand {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.command = { oneofKind: undefined }
        if (value !== undefined)
            reflectionMergePartial<ReassignmentCommand>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ReassignmentCommand
    ): ReassignmentCommand {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.UnassignCommand unassign_command */ 1:
                    message.command = {
                        oneofKind: 'unassignCommand',
                        unassignCommand: UnassignCommand.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.command as any).unassignCommand
                        ),
                    }
                    break
                case /* com.daml.ledger.api.v2.AssignCommand assign_command */ 2:
                    message.command = {
                        oneofKind: 'assignCommand',
                        assignCommand: AssignCommand.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.command as any).assignCommand
                        ),
                    }
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: ReassignmentCommand,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.UnassignCommand unassign_command = 1; */
        if (message.command.oneofKind === 'unassignCommand')
            UnassignCommand.internalBinaryWrite(
                message.command.unassignCommand,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.AssignCommand assign_command = 2; */
        if (message.command.oneofKind === 'assignCommand')
            AssignCommand.internalBinaryWrite(
                message.command.assignCommand,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.ReassignmentCommand
 */
export const ReassignmentCommand = new ReassignmentCommand$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UnassignCommand$Type extends MessageType<UnassignCommand> {
    constructor() {
        super('com.daml.ledger.api.v2.UnassignCommand', [
            {
                no: 1,
                name: 'contract_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'source',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 3,
                name: 'target',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
        ])
    }
    create(value?: PartialMessage<UnassignCommand>): UnassignCommand {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.contractId = ''
        message.source = ''
        message.target = ''
        if (value !== undefined)
            reflectionMergePartial<UnassignCommand>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: UnassignCommand
    ): UnassignCommand {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string contract_id */ 1:
                    message.contractId = reader.string()
                    break
                case /* string source */ 2:
                    message.source = reader.string()
                    break
                case /* string target */ 3:
                    message.target = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: UnassignCommand,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string contract_id = 1; */
        if (message.contractId !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.contractId)
        /* string source = 2; */
        if (message.source !== '')
            writer.tag(2, WireType.LengthDelimited).string(message.source)
        /* string target = 3; */
        if (message.target !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.target)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.UnassignCommand
 */
export const UnassignCommand = new UnassignCommand$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AssignCommand$Type extends MessageType<AssignCommand> {
    constructor() {
        super('com.daml.ledger.api.v2.AssignCommand', [
            {
                no: 1,
                name: 'unassign_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'source',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 3,
                name: 'target',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
        ])
    }
    create(value?: PartialMessage<AssignCommand>): AssignCommand {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.unassignId = ''
        message.source = ''
        message.target = ''
        if (value !== undefined)
            reflectionMergePartial<AssignCommand>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: AssignCommand
    ): AssignCommand {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string unassign_id */ 1:
                    message.unassignId = reader.string()
                    break
                case /* string source */ 2:
                    message.source = reader.string()
                    break
                case /* string target */ 3:
                    message.target = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: AssignCommand,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string unassign_id = 1; */
        if (message.unassignId !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.unassignId)
        /* string source = 2; */
        if (message.source !== '')
            writer.tag(2, WireType.LengthDelimited).string(message.source)
        /* string target = 3; */
        if (message.target !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.target)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.AssignCommand
 */
export const AssignCommand = new AssignCommand$Type()
