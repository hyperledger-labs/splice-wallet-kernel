// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/admin/package_management_service.proto" (package "com.daml.ledger.api.v2.admin", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import type { RpcTransport } from '@protobuf-ts/runtime-rpc'
import type { ServiceInfo } from '@protobuf-ts/runtime-rpc'
import { PackageManagementService } from './package_management_service.js'
import type { ValidateDarFileResponse } from './package_management_service.js'
import type { ValidateDarFileRequest } from './package_management_service.js'
import type { UploadDarFileResponse } from './package_management_service.js'
import type { UploadDarFileRequest } from './package_management_service.js'
import { stackIntercept } from '@protobuf-ts/runtime-rpc'
import type { ListKnownPackagesResponse } from './package_management_service.js'
import type { ListKnownPackagesRequest } from './package_management_service.js'
import type { UnaryCall } from '@protobuf-ts/runtime-rpc'
import type { RpcOptions } from '@protobuf-ts/runtime-rpc'
/**
 * Status: experimental interface, will change before it is deemed production
 * ready
 *
 * Query the Daml-LF packages supported by the ledger participant and upload
 * DAR files. We use 'backing participant' to refer to this specific participant
 * in the methods of this API.
 *
 * @generated from protobuf service com.daml.ledger.api.v2.admin.PackageManagementService
 */
export interface IPackageManagementServiceClient {
    /**
     * Returns the details of all Daml-LF packages known to the backing participant.
     *
     * @generated from protobuf rpc: ListKnownPackages
     */
    listKnownPackages(
        input: ListKnownPackagesRequest,
        options?: RpcOptions
    ): UnaryCall<ListKnownPackagesRequest, ListKnownPackagesResponse>
    /**
     * Upload a DAR file to the backing participant.
     * Depending on the ledger implementation this might also make the package
     * available on the whole ledger. This call might not be supported by some
     * ledger implementations. Canton could be an example, where uploading a DAR
     * is not sufficient to render it usable, it must be activated first.
     * This call may:
     *
     * - Succeed, if the package was successfully uploaded, or if the same package
     *   was already uploaded before.
     * - Respond with a gRPC error
     *
     * @generated from protobuf rpc: UploadDarFile
     */
    uploadDarFile(
        input: UploadDarFileRequest,
        options?: RpcOptions
    ): UnaryCall<UploadDarFileRequest, UploadDarFileResponse>
    /**
     * Performs the same checks that UploadDarFile call perform, but doesn't
     * upload the DAR and does not make it available on the whole ledger.
     * This call may:
     *
     * - Succeed if the package is valid
     * - Respond with a gRPC error if the package is not valid
     *
     * @generated from protobuf rpc: ValidateDarFile
     */
    validateDarFile(
        input: ValidateDarFileRequest,
        options?: RpcOptions
    ): UnaryCall<ValidateDarFileRequest, ValidateDarFileResponse>
}
/**
 * Status: experimental interface, will change before it is deemed production
 * ready
 *
 * Query the Daml-LF packages supported by the ledger participant and upload
 * DAR files. We use 'backing participant' to refer to this specific participant
 * in the methods of this API.
 *
 * @generated from protobuf service com.daml.ledger.api.v2.admin.PackageManagementService
 */
export class PackageManagementServiceClient
    implements IPackageManagementServiceClient, ServiceInfo
{
    typeName = PackageManagementService.typeName
    methods = PackageManagementService.methods
    options = PackageManagementService.options
    constructor(private readonly _transport: RpcTransport) {}
    /**
     * Returns the details of all Daml-LF packages known to the backing participant.
     *
     * @generated from protobuf rpc: ListKnownPackages
     */
    listKnownPackages(
        input: ListKnownPackagesRequest,
        options?: RpcOptions
    ): UnaryCall<ListKnownPackagesRequest, ListKnownPackagesResponse> {
        const method = this.methods[0],
            opt = this._transport.mergeOptions(options)
        return stackIntercept<
            ListKnownPackagesRequest,
            ListKnownPackagesResponse
        >('unary', this._transport, method, opt, input)
    }
    /**
     * Upload a DAR file to the backing participant.
     * Depending on the ledger implementation this might also make the package
     * available on the whole ledger. This call might not be supported by some
     * ledger implementations. Canton could be an example, where uploading a DAR
     * is not sufficient to render it usable, it must be activated first.
     * This call may:
     *
     * - Succeed, if the package was successfully uploaded, or if the same package
     *   was already uploaded before.
     * - Respond with a gRPC error
     *
     * @generated from protobuf rpc: UploadDarFile
     */
    uploadDarFile(
        input: UploadDarFileRequest,
        options?: RpcOptions
    ): UnaryCall<UploadDarFileRequest, UploadDarFileResponse> {
        const method = this.methods[1],
            opt = this._transport.mergeOptions(options)
        return stackIntercept<UploadDarFileRequest, UploadDarFileResponse>(
            'unary',
            this._transport,
            method,
            opt,
            input
        )
    }
    /**
     * Performs the same checks that UploadDarFile call perform, but doesn't
     * upload the DAR and does not make it available on the whole ledger.
     * This call may:
     *
     * - Succeed if the package is valid
     * - Respond with a gRPC error if the package is not valid
     *
     * @generated from protobuf rpc: ValidateDarFile
     */
    validateDarFile(
        input: ValidateDarFileRequest,
        options?: RpcOptions
    ): UnaryCall<ValidateDarFileRequest, ValidateDarFileResponse> {
        const method = this.methods[2],
            opt = this._transport.mergeOptions(options)
        return stackIntercept<ValidateDarFileRequest, ValidateDarFileResponse>(
            'unary',
            this._transport,
            method,
            opt,
            input
        )
    }
}
