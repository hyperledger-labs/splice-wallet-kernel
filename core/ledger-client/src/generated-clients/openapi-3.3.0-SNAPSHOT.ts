/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

/** OneOf type helpers */
type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never }
type XOR<T, U> = T | U extends object
    ? (Without<T, U> & U) | (Without<U, T> & T)
    : T | U
type OneOf<T extends any[]> = T extends [infer Only]
    ? Only
    : T extends [infer A, infer B, ...infer Rest]
      ? OneOf<[XOR<A, B>, ...Rest]>
      : never

export interface paths {
    '/v2/commands/submit-and-wait': {
        /** @description Submit a batch of commands and wait for the completion details */
        post: operations['postV2CommandsSubmit-and-wait']
    }
    '/v2/commands/submit-and-wait-for-transaction': {
        /** @description Submit a batch of commands and wait for the transaction response */
        post: operations['postV2CommandsSubmit-and-wait-for-transaction']
    }
    '/v2/commands/submit-and-wait-for-reassignment': {
        /** @description Submit a batch of reassignment commands and wait for the reassignment response */
        post: operations['postV2CommandsSubmit-and-wait-for-reassignment']
    }
    '/v2/commands/submit-and-wait-for-transaction-tree': {
        /** @description Submit a batch of commands and wait for the transaction trees response */
        post: operations['postV2CommandsSubmit-and-wait-for-transaction-tree']
    }
    '/v2/commands/async/submit': {
        /** @description Submit a command asynchronously */
        post: operations['postV2CommandsAsyncSubmit']
    }
    '/v2/commands/async/submit-reassignment': {
        /** @description Submit reassignment command asynchronously */
        post: operations['postV2CommandsAsyncSubmit-reassignment']
    }
    '/v2/commands/completions': {
        /** @description Query completions list (blocking call) */
        post: operations['postV2CommandsCompletions']
    }
    '/v2/events/events-by-contract-id': {
        /** @description Get events by contract Id */
        post: operations['postV2EventsEvents-by-contract-id']
    }
    '/v2/version': {
        /** @description Get the version details of the participant node */
        get: operations['getV2Version']
    }
    '/v2/packages': {
        /** @description List all packages uploaded on the participant node */
        get: operations['getV2Packages']
        /** @description Upload a DAR to the participant node */
        post: operations['postV2Packages']
    }
    '/v2/packages/{package-id}': {
        /** @description Download the package for the requested package-id */
        get: operations['getV2PackagesPackage-id']
    }
    '/v2/packages/{package-id}/status': {
        /** @description Get package status */
        get: operations['getV2PackagesPackage-idStatus']
    }
    '/v2/parties': {
        /** @description List all known parties. */
        get: operations['getV2Parties']
        /** @description Allocate a new party to the participant node */
        post: operations['postV2Parties']
    }
    '/v2/parties/participant-id': {
        /** @description Get participant id */
        get: operations['getV2PartiesParticipant-id']
    }
    '/v2/parties/{party}': {
        /** @description Get party details */
        get: operations['getV2PartiesParty']
        /** @description Allocate a new party to the participant node */
        patch: operations['patchV2PartiesParty']
    }
    '/v2/state/active-contracts': {
        /** @description Query active contracts list (blocking call) */
        post: operations['postV2StateActive-contracts']
    }
    '/v2/state/connected-synchronizers': {
        /** @description Get connected synchronizers */
        get: operations['getV2StateConnected-synchronizers']
    }
    '/v2/state/ledger-end': {
        /** @description Get ledger end */
        get: operations['getV2StateLedger-end']
    }
    '/v2/state/latest-pruned-offsets': {
        /** @description Get latest pruned offsets */
        get: operations['getV2StateLatest-pruned-offsets']
    }
    '/v2/updates/flats': {
        /** @description Query flat transactions update list (blocking call) */
        post: operations['postV2UpdatesFlats']
    }
    '/v2/updates/trees': {
        /** @description Query update transactions tree list (blocking call) */
        post: operations['postV2UpdatesTrees']
    }
    '/v2/updates/transaction-tree-by-offset/{offset}': {
        /** @description Get transaction tree by offset */
        get: operations['getV2UpdatesTransaction-tree-by-offsetOffset']
    }
    '/v2/updates/transaction-by-offset': {
        /** @description Get transaction by offset */
        post: operations['postV2UpdatesTransaction-by-offset']
    }
    '/v2/updates/update-by-offset': {
        /** @description Get update by offset */
        post: operations['postV2UpdatesUpdate-by-offset']
    }
    '/v2/updates/transaction-by-id': {
        /** @description Get transaction by id */
        post: operations['postV2UpdatesTransaction-by-id']
    }
    '/v2/updates/update-by-id': {
        /** @description Get update by id */
        post: operations['postV2UpdatesUpdate-by-id']
    }
    '/v2/updates/transaction-tree-by-id/{update-id}': {
        /** @description Get transaction tree by  id */
        get: operations['getV2UpdatesTransaction-tree-by-idUpdate-id']
    }
    '/v2/users': {
        /** @description List all users. */
        get: operations['getV2Users']
        /** @description Create user. */
        post: operations['postV2Users']
    }
    '/v2/users/{user-id}': {
        /** @description Get user details. */
        get: operations['getV2UsersUser-id']
        /** @description Delete user. */
        delete: operations['deleteV2UsersUser-id']
        /** @description Update  user. */
        patch: operations['patchV2UsersUser-id']
    }
    '/v2/users/{user-id}/rights': {
        /** @description List user rights. */
        get: operations['getV2UsersUser-idRights']
        /** @description Grant user rights. */
        post: operations['postV2UsersUser-idRights']
        /** @description Revoke user rights. */
        patch: operations['patchV2UsersUser-idRights']
    }
    '/v2/users/{user-id}/identity-provider-id': {
        /** @description Update user identity provider. */
        patch: operations['patchV2UsersUser-idIdentity-provider-id']
    }
    '/v2/idps': {
        /** @description List all identity provider configs */
        get: operations['getV2Idps']
        /** @description Create identity provider configs */
        post: operations['postV2Idps']
    }
    '/v2/idps/{idp-id}': {
        /** @description Get identity provider config */
        get: operations['getV2IdpsIdp-id']
        /** @description Delete identity provider config */
        delete: operations['deleteV2IdpsIdp-id']
        /** @description Update identity provider config */
        patch: operations['patchV2IdpsIdp-id']
    }
    '/v2/interactive-submission/prepare': {
        /** @description Prepare commands for signing */
        post: operations['postV2Interactive-submissionPrepare']
    }
    '/v2/interactive-submission/execute': {
        /** @description Execute a signed transaction */
        post: operations['postV2Interactive-submissionExecute']
    }
    '/v2/interactive-submission/preferred-package-version': {
        /** @description Get the preferred package version for constructing a command submission */
        get: operations['getV2Interactive-submissionPreferred-package-version']
    }
}

export type webhooks = Record<string, never>

export interface components {
    schemas: {
        /**
         * AllocatePartyRequest
         * @description Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
         */
        AllocatePartyRequest: {
            /**
             * @description A hint to the participant which party ID to allocate. It can be
             * ignored.
             * Must be a valid PartyIdString (as described in ``value.proto``).
             * Optional
             */
            partyIdHint: string
            /**
             * @description Formerly "display_name"
             * Participant-local metadata to be stored in the ``PartyDetails`` of this newly allocated party.
             * Optional
             */
            localMetadata?: components['schemas']['ObjectMeta']
            /**
             * @description The id of the ``Identity Provider``
             * Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.
             */
            identityProviderId: string
        }
        /** AllocatePartyResponse */
        AllocatePartyResponse: {
            partyDetails?: components['schemas']['PartyDetails']
        }
        /**
         * ArchivedEvent
         * @description Records that a contract has been archived, and choices may no longer be exercised on it.
         */
        ArchivedEvent: {
            /**
             * Format: int64
             * @description The offset of origin.
             * Offsets are managed by the participant nodes.
             * Transactions can thus NOT be assumed to have the same offsets on different participant nodes.
             * Required, it is a valid absolute offset (positive integer)
             */
            offset: number
            /**
             * Format: int32
             * @description The position of this event in the originating transaction or reassignment.
             * Node IDs are not necessarily equal across participants,
             * as these may see different projections/parts of transactions.
             * Required, must be valid node ID (non-negative integer)
             */
            nodeId: number
            /**
             * @description The ID of the archived contract.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            contractId: string
            /**
             * @description The template of the archived contract.
             * The identifier uses the package-id reference format.
             *
             * Required
             */
            templateId: string
            /**
             * @description The parties that are notified of this event. For an ``ArchivedEvent``,
             * these are the intersection of the stakeholders of the contract in
             * question and the parties specified in the ``TransactionFilter``. The
             * stakeholders are the union of the signatories and the observers of
             * the contract.
             * Each one of its elements must be a valid PartyIdString (as described
             * in ``value.proto``).
             * Required
             */
            witnessParties?: string[]
            /**
             * @description The package name of the contract.
             * Required
             */
            packageName: string
            /**
             * @description The interfaces implemented by the target template that have been
             * matched from the interface filter query.
             * Populated only in case interface filters with include_interface_view set.
             *
             * If defined, the identifier uses the package-id reference format.
             *
             * Optional
             */
            implementedInterfaces?: string[]
        }
        /**
         * AssignCommand
         * @description Assign a contract
         */
        AssignCommand: {
            value: components['schemas']['AssignCommand1']
        }
        /**
         * AssignCommand
         * @description Assign a contract
         */
        AssignCommand1: {
            /**
             * @description The ID from the unassigned event to be completed by this assignment.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            unassignId: string
            /**
             * @description The ID of the source synchronizer
             * Must be a valid synchronizer id
             * Required
             */
            source: string
            /**
             * @description The ID of the target synchronizer
             * Must be a valid synchronizer id
             * Required
             */
            target: string
        }
        /** CanActAs */
        CanActAs: {
            value: components['schemas']['CanActAs1']
        }
        /** CanActAs */
        CanActAs1: {
            party: string
        }
        /** CanReadAs */
        CanReadAs: {
            value: components['schemas']['CanReadAs1']
        }
        /** CanReadAs */
        CanReadAs1: {
            party: string
        }
        /** CanReadAsAnyParty */
        CanReadAsAnyParty: {
            value: components['schemas']['CanReadAsAnyParty1']
        }
        /** CanReadAsAnyParty */
        CanReadAsAnyParty1: Record<string, never>
        /**
         * Command
         * @description A command can either create a new contract or exercise a choice on an existing contract.
         */
        Command: OneOf<
            [
                {
                    CreateAndExerciseCommand: components['schemas']['CreateAndExerciseCommand']
                },
                {
                    CreateCommand: components['schemas']['CreateCommand']
                },
                {
                    ExerciseByKeyCommand: components['schemas']['ExerciseByKeyCommand']
                },
                {
                    ExerciseCommand: components['schemas']['ExerciseCommand']
                },
            ]
        >
        /**
         * Command
         * @description A command can either create a new contract or exercise a choice on an existing contract.
         */
        Command1: OneOf<
            [
                {
                    AssignCommand: components['schemas']['AssignCommand']
                },
                {
                    Empty: components['schemas']['Empty2']
                },
                {
                    UnassignCommand: components['schemas']['UnassignCommand']
                },
            ]
        >
        /**
         * Completion
         * @description A completion represents the status of a submitted command on the ledger: it can be successful or failed.
         */
        Completion: {
            value: components['schemas']['Completion1']
        }
        /**
         * Completion
         * @description A completion represents the status of a submitted command on the ledger: it can be successful or failed.
         */
        Completion1: {
            /**
             * @description The ID of the succeeded or failed command.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            commandId: string
            /**
             * @description Identifies the exact type of the error.
             * It uses the same format of conveying error details as it is used for the RPC responses of the APIs.
             * Optional
             */
            status?: components['schemas']['Status']
            /**
             * @description The update_id of the transaction or reassignment that resulted from the command with command_id.
             * Only set for successfully executed commands.
             * Must be a valid LedgerString (as described in ``value.proto``).
             */
            updateId: string
            /**
             * @description The user-id that was used for the submission, as described in ``commands.proto``.
             * Must be a valid UserIdString (as described in ``value.proto``).
             * Optional for historic completions where this data is not available.
             */
            userId: string
            /**
             * @description The set of parties on whose behalf the commands were executed.
             * Contains the ``act_as`` parties from ``commands.proto``
             * filtered to the requesting parties in CompletionStreamRequest.
             * The order of the parties need not be the same as in the submission.
             * Each element must be a valid PartyIdString (as described in ``value.proto``).
             * Optional for historic completions where this data is not available.
             */
            actAs?: string[]
            /**
             * @description The submission ID this completion refers to, as described in ``commands.proto``.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Optional
             */
            submissionId: string
            deduplicationPeriod: components['schemas']['DeduplicationPeriod1']
            /**
             * @description Optional; ledger API trace context
             *
             * The trace context transported in this message corresponds to the trace context supplied
             * by the client application in a HTTP2 header of the original command submission.
             * We typically use a header to transfer this type of information. Here we use message
             * body, because it is used in gRPC streams which do not support per message headers.
             * This field will be populated with the trace context contained in the original submission.
             * If that was not provided, a unique ledger-api-server generated trace context will be used
             * instead.
             */
            traceContext?: components['schemas']['TraceContext']
            /**
             * Format: int64
             * @description May be used in a subsequent CompletionStreamRequest to resume the consumption of this stream at a later time.
             * Required, must be a valid absolute offset (positive integer).
             */
            offset: number
            /**
             * @description The synchronizer along with its record time.
             * The synchronizer id provided, in case of
             *
             * - successful/failed transactions: identifies the synchronizer of the transaction
             * - for successful/failed unassign commands: identifies the source synchronizer
             * - for successful/failed assign commands: identifies the target synchronizer
             *
             * Required
             */
            synchronizerTime?: components['schemas']['SynchronizerTime']
        }
        /** CompletionResponse */
        CompletionResponse: OneOf<
            [
                {
                    Completion: components['schemas']['Completion']
                },
                {
                    Empty: components['schemas']['Empty4']
                },
                {
                    OffsetCheckpoint: components['schemas']['OffsetCheckpoint']
                },
            ]
        >
        /** CompletionStreamRequest */
        CompletionStreamRequest: {
            /**
             * @description Only completions of commands submitted with the same user_id will be visible in the stream.
             * Must be a valid UserIdString (as described in ``value.proto``).
             * Required unless authentication is used with a user token.
             * In that case, the token's user-id will be used for the request's user_id.
             */
            userId: string
            /**
             * @description Non-empty list of parties whose data should be included.
             * The stream shows only completions of commands for which at least one of the ``act_as`` parties is in the given set of parties.
             * Must be a valid PartyIdString (as described in ``value.proto``).
             * Required
             */
            parties?: string[]
            /**
             * Format: int64
             * @description This optional field indicates the minimum offset for completions. This can be used to resume an earlier completion stream.
             * If not set the ledger uses the ledger begin offset instead.
             * If specified, it must be a valid absolute offset (positive integer) or zero (ledger begin offset).
             * If the ledger has been pruned, this parameter must be specified and greater than the pruning offset.
             */
            beginExclusive: number
        }
        /** CompletionStreamResponse */
        CompletionStreamResponse: {
            completionResponse: components['schemas']['CompletionResponse']
        }
        /** ConnectedSynchronizer */
        ConnectedSynchronizer: {
            synchronizerAlias: string
            synchronizerId: string
            permission: string
        }
        /**
         * CreateAndExerciseCommand
         * @description Create a contract and exercise a choice on it in the same transaction.
         */
        CreateAndExerciseCommand: {
            /**
             * @description The template of the contract the client wants to create.
             * Both package-name and package-id reference identifier formats for the template-id are supported.
             * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
             *
             * Required
             */
            templateId: string
            /**
             * @description The arguments required for creating a contract from this template.
             * Required
             */
            createArguments: unknown
            /**
             * @description The name of the choice the client wants to exercise.
             * Must be a valid NameString (as described in ``value.proto``).
             * Required
             */
            choice: string
            /**
             * @description The argument for this choice.
             * Required
             */
            choiceArgument: unknown
        }
        /**
         * CreateCommand
         * @description Create a new contract instance based on a template.
         */
        CreateCommand: {
            /**
             * @description The template of contract the client wants to create.
             * Both package-name and package-id reference identifier formats for the template-id are supported.
             * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
             *
             * Required
             */
            templateId: string
            /**
             * @description The arguments required for creating a contract from this template.
             * Required
             */
            createArguments: unknown
        }
        /** CreateIdentityProviderConfigRequest */
        CreateIdentityProviderConfigRequest: {
            /** @description Required */
            identityProviderConfig?: components['schemas']['IdentityProviderConfig']
        }
        /** CreateIdentityProviderConfigResponse */
        CreateIdentityProviderConfigResponse: {
            identityProviderConfig?: components['schemas']['IdentityProviderConfig']
        }
        /**
         * CreateUserRequest
         * @description  RPC requests and responses
         * ///////////////////////////
         *  Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(user.identity_provider_id)``
         */
        CreateUserRequest: {
            /**
             * @description The user to create.
             * Required
             */
            user?: components['schemas']['User']
            /**
             * @description The rights to be assigned to the user upon creation,
             * which SHOULD include appropriate rights for the ``user.primary_party``.
             * Optional
             */
            rights?: components['schemas']['Right'][]
        }
        /** CreateUserResponse */
        CreateUserResponse: {
            /** @description Created user. */
            user?: components['schemas']['User']
        }
        /**
         * CreatedEvent
         * @description Records that a contract has been created, and choices may now be exercised on it.
         */
        CreatedEvent: {
            /**
             * Format: int64
             * @description The offset of origin, which has contextual meaning, please see description at messages that include a CreatedEvent.
             * Offsets are managed by the participant nodes.
             * Transactions can thus NOT be assumed to have the same offsets on different participant nodes.
             * Required, it is a valid absolute offset (positive integer)
             */
            offset: number
            /**
             * Format: int32
             * @description The position of this event in the originating transaction or reassignment.
             * The origin has contextual meaning, please see description at messages that include a CreatedEvent.
             * Node IDs are not necessarily equal across participants,
             * as these may see different projections/parts of transactions.
             * Required, must be valid node ID (non-negative integer)
             */
            nodeId: number
            /**
             * @description The ID of the created contract.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            contractId: string
            /**
             * @description The template of the created contract.
             * The identifier uses the package-id reference format.
             *
             * Required
             */
            templateId: string
            /**
             * @description The key of the created contract.
             * This will be set if and only if ``create_arguments`` is set and ``template_id`` defines a contract key.
             * Optional
             */
            contractKey?: unknown
            createArgument?: unknown
            /**
             * @description Opaque representation of contract create event payload intended for forwarding
             * to an API server as a contract disclosed as part of a command
             * submission.
             * Optional
             */
            createdEventBlob: string
            /**
             * @description Interface views specified in the transaction filter.
             * Includes an ``InterfaceView`` for each interface for which there is a ``InterfaceFilter`` with
             *
             * - its party in the ``witness_parties`` of this event,
             * - and which is implemented by the template of this event,
             * - and which has ``include_interface_view`` set.
             *
             * Optional
             */
            interfaceViews?: components['schemas']['JsInterfaceView'][]
            /**
             * @description The parties that are notified of this event. When a ``CreatedEvent``
             * is returned as part of a transaction tree or ledger-effects transaction, this will include all
             * the parties specified in the ``TransactionFilter`` that are informees
             * of the event. If served as part of a ACS delta transaction those will
             * be limited to all parties specified in the ``TransactionFilter`` that
             * are stakeholders of the contract (i.e. either signatories or observers).
             * If the ``CreatedEvent`` is returned as part of an AssignedEvent,
             * ActiveContract or IncompleteUnassigned (so the event is related to
             * an assignment or unassignment): this will include all parties of the
             * ``TransactionFilter`` that are stakeholders of the contract.
             *
             * The behavior of reading create events visible to parties not hosted
             * on the participant node serving the Ledger API is undefined. Concretely,
             * there is neither a guarantee that the participant node will serve all their
             * create events on the ACS stream, nor is there a guarantee that matching archive
             * events are delivered for such create events.
             *
             * For most clients this is not a problem, as they only read events for parties
             * that are hosted on the participant node. If you need to read events
             * for parties that may not be hosted at all times on the participant node,
             * subscribe to the ``TopologyEvent``s for that party by setting a corresponding
             * ``UpdateFormat``.  Using these events, query the ACS as-of an offset where the
             * party is hosted on the participant node, and ignore create events at offsets
             * where the party is not hosted on the participant node.
             * Required
             */
            witnessParties?: string[]
            /**
             * @description The signatories for this contract as specified by the template.
             * Required
             */
            signatories?: string[]
            /**
             * @description The observers for this contract as specified explicitly by the template or implicitly as choice controllers.
             * This field never contains parties that are signatories.
             * Required
             */
            observers?: string[]
            /**
             * @description Ledger effective time of the transaction that created the contract.
             * Required
             */
            createdAt: string
            /**
             * @description The package name of the created contract.
             * Required
             */
            packageName: string
        }
        /** CreatedTreeEvent */
        CreatedTreeEvent: {
            value: components['schemas']['CreatedEvent']
        }
        /**
         * CumulativeFilter
         * @description A filter that matches all contracts that are either an instance of one of
         * the ``template_filters`` or that match one of the ``interface_filters``.
         */
        CumulativeFilter: {
            identifierFilter: components['schemas']['IdentifierFilter']
        }
        /** DeduplicationDuration */
        DeduplicationDuration: {
            value: components['schemas']['Duration']
        }
        /** DeduplicationDuration */
        DeduplicationDuration1: {
            value: components['schemas']['Duration']
        }
        /** DeduplicationDuration */
        DeduplicationDuration2: {
            value: components['schemas']['Duration']
        }
        /** DeduplicationOffset */
        DeduplicationOffset: {
            /** Format: int64 */
            value: number
        }
        /** DeduplicationOffset */
        DeduplicationOffset1: {
            /** Format: int64 */
            value: number
        }
        /** DeduplicationOffset */
        DeduplicationOffset2: {
            /** Format: int64 */
            value: number
        }
        /**
         * DeduplicationPeriod
         * @description Specifies the deduplication period for the change ID.
         * If omitted, the participant will assume the configured maximum deduplication time.
         */
        DeduplicationPeriod: OneOf<
            [
                {
                    DeduplicationDuration: components['schemas']['DeduplicationDuration']
                },
                {
                    DeduplicationOffset: components['schemas']['DeduplicationOffset']
                },
                {
                    Empty: components['schemas']['Empty']
                },
            ]
        >
        /**
         * DeduplicationPeriod
         * @description The actual deduplication window used for the submission, which is derived from
         * ``Commands.deduplication_period``. The ledger may convert the deduplication period into other
         * descriptions and extend the period in implementation-specified ways.
         *
         * Used to audit the deduplication guarantee described in ``commands.proto``.
         *
         * Optional; the deduplication guarantee applies even if the completion omits this field.
         */
        DeduplicationPeriod1: OneOf<
            [
                {
                    DeduplicationDuration: components['schemas']['DeduplicationDuration1']
                },
                {
                    DeduplicationOffset: components['schemas']['DeduplicationOffset1']
                },
                {
                    Empty: components['schemas']['Empty3']
                },
            ]
        >
        /**
         * DeduplicationPeriod
         * @description Specifies the deduplication period for the change ID (See PrepareSubmissionRequest).
         * If omitted, the participant will assume the configured maximum deduplication time.
         */
        DeduplicationPeriod2: OneOf<
            [
                {
                    DeduplicationDuration: components['schemas']['DeduplicationDuration2']
                },
                {
                    DeduplicationOffset: components['schemas']['DeduplicationOffset2']
                },
                {
                    Empty: components['schemas']['Empty7']
                },
            ]
        >
        /**
         * DeleteIdentityProviderConfigResponse
         * @description Does not (yet) contain any data.
         */
        DeleteIdentityProviderConfigResponse: Record<string, never>
        /**
         * DisclosedContract
         * @description An additional contract that is used to resolve
         * contract & contract key lookups.
         */
        DisclosedContract: {
            /**
             * @description The template id of the contract.
             * The identifier uses the package-id reference format.
             *
             * Required
             */
            templateId?: string
            /**
             * @description The contract id
             * Required
             */
            contractId: string
            /**
             * @description Opaque byte string containing the complete payload required by the Daml engine
             * to reconstruct a contract not known to the receiving participant.
             * Required
             */
            createdEventBlob: string
            /**
             * @description The ID of the synchronizer where the contract is currently assigned
             * Optional
             */
            synchronizerId: string
        }
        /** Duration */
        Duration: {
            /** Format: int64 */
            seconds: number
            /** Format: int32 */
            nanos: number
            /** @description This field is automatically added as part of protobuf to json mapping */
            unknownFields?: components['schemas']['UnknownFieldSet']
        }
        /** Empty */
        Empty: Record<string, never>
        /** Empty */
        Empty1: Record<string, never>
        /** Empty */
        Empty2: Record<string, never>
        /** Empty */
        Empty3: Record<string, never>
        /** Empty */
        Empty4: Record<string, never>
        /** Empty */
        Empty5: Record<string, never>
        /** Empty */
        Empty6: Record<string, never>
        /** Empty */
        Empty7: Record<string, never>
        /**
         * Event
         * @description Events in transactions can have two primary shapes:
         *
         * - ACS delta: events can be CreatedEvent or ArchivedEvent
         * - ledger effects: events can be CreatedEvent or ExercisedEvent
         *
         * In the update service the events are restricted to the events
         * visible for the parties specified in the transaction filter. Each
         * event message type below contains a ``witness_parties`` field which
         * indicates the subset of the requested parties that can see the event
         * in question.
         */
        Event: OneOf<
            [
                {
                    ArchivedEvent: components['schemas']['ArchivedEvent']
                },
                {
                    CreatedEvent: components['schemas']['CreatedEvent']
                },
                {
                    ExercisedEvent: components['schemas']['ExercisedEvent']
                },
            ]
        >
        /**
         * EventFormat
         * @description A format for events which defines both which events should be included
         * and what data should be computed and included for them.
         *
         * Note that some of the filtering behavior depends on the `TransactionShape`,
         * which is expected to be specified alongside usages of `EventFormat`.
         */
        EventFormat: {
            /**
             * @description Each key must be a valid PartyIdString (as described in ``value.proto``).
             * The interpretation of the filter depends on the transaction-shape being filtered:
             *
             * 1. For **ledger-effects** create and exercise events are returned, for which the witnesses include at least one of
             *    the listed parties and match the per-party filter.
             * 2. For **transaction and active-contract-set streams** create and archive events are returned for all contracts whose
             *    stakeholders include at least one of the listed parties and match the per-party filter.
             *
             * Optional
             */
            filtersByParty: components['schemas']['Map_Filters']
            /**
             * @description Wildcard filters that apply to all the parties existing on the participant. The interpretation of the filters is the same
             * with the per-party filter as described above.
             * Optional
             */
            filtersForAnyParty?: components['schemas']['Filters']
            /**
             * @description If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
             * In particular, setting the verbose flag to true triggers the ledger to include labels for record fields.
             * Optional
             */
            verbose: boolean
        }
        /** ExecuteSubmissionResponse */
        ExecuteSubmissionResponse: Record<string, never>
        /**
         * ExerciseByKeyCommand
         * @description Exercise a choice on an existing contract specified by its key.
         */
        ExerciseByKeyCommand: {
            /**
             * @description The template of contract the client wants to exercise.
             * Both package-name and package-id reference identifier formats for the template-id are supported.
             * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
             *
             * Required
             */
            templateId: string
            /**
             * @description The key of the contract the client wants to exercise upon.
             * Required
             */
            contractKey: unknown
            /**
             * @description The name of the choice the client wants to exercise.
             * Must be a valid NameString (as described in ``value.proto``)
             * Required
             */
            choice: string
            /**
             * @description The argument for this choice.
             * Required
             */
            choiceArgument: unknown
        }
        /**
         * ExerciseCommand
         * @description Exercise a choice on an existing contract.
         */
        ExerciseCommand: {
            /**
             * @description The template of contract the client wants to exercise.
             * Both package-name and package-id reference identifier formats for the template-id are supported.
             * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
             *
             * Required
             */
            templateId: string
            /**
             * @description The ID of the contract the client wants to exercise upon.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            contractId: string
            /**
             * @description The name of the choice the client wants to exercise.
             * Must be a valid NameString (as described in ``value.proto``)
             * Required
             */
            choice: string
            /**
             * @description The argument for this choice.
             * Required
             */
            choiceArgument: unknown
        }
        /**
         * ExercisedEvent
         * @description Records that a choice has been exercised on a target contract.
         */
        ExercisedEvent: {
            /**
             * Format: int64
             * @description The offset of origin.
             * Offsets are managed by the participant nodes.
             * Transactions can thus NOT be assumed to have the same offsets on different participant nodes.
             * Required, it is a valid absolute offset (positive integer)
             */
            offset: number
            /**
             * Format: int32
             * @description The position of this event in the originating transaction or reassignment.
             * Node IDs are not necessarily equal across participants,
             * as these may see different projections/parts of transactions.
             * Required, must be valid node ID (non-negative integer)
             */
            nodeId: number
            /**
             * @description The ID of the target contract.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            contractId: string
            /**
             * @description The template of the target contract.
             * The identifier uses the package-id reference format.
             *
             * Required
             */
            templateId: string
            /**
             * @description The interface where the choice is defined, if inherited.
             * If defined, the identifier uses the package-id reference format.
             *
             * Optional
             */
            interfaceId?: string
            /**
             * @description The choice that was exercised on the target contract.
             * Must be a valid NameString (as described in ``value.proto``).
             * Required
             */
            choice: string
            /**
             * @description The argument of the exercised choice.
             * Required
             */
            choiceArgument: unknown
            /**
             * @description The parties that exercised the choice.
             * Each element must be a valid PartyIdString (as described in ``value.proto``).
             * Required
             */
            actingParties?: string[]
            /**
             * @description If true, the target contract may no longer be exercised.
             * Required
             */
            consuming: boolean
            /**
             * @description The parties that are notified of this event. The witnesses of an exercise
             * node will depend on whether the exercise was consuming or not.
             * If consuming, the witnesses are the union of the stakeholders and
             * the actors.
             * If not consuming, the witnesses are the union of the signatories and
             * the actors. Note that the actors might not necessarily be observers
             * and thus signatories. This is the case when the controllers of a
             * choice are specified using "flexible controllers", using the
             * ``choice ... controller`` syntax, and said controllers are not
             * explicitly marked as observers.
             * Each element must be a valid PartyIdString (as described in ``value.proto``).
             * Required
             */
            witnessParties?: string[]
            /**
             * Format: int32
             * @description Specifies the upper boundary of the node ids of the events in the same transaction that appeared as a result of
             * this ``ExercisedEvent``. This allows unambiguous identification of all the members of the subtree rooted at this
             * node. A full subtree can be constructed when all descendant nodes are present in the stream. If nodes are heavily
             * filtered, it is only possible to determine if a node is in a consequent subtree or not.
             * Required
             */
            lastDescendantNodeId: number
            /**
             * @description The result of exercising the choice.
             * Required
             */
            exerciseResult: unknown
            /**
             * @description The package name of the contract.
             * Required
             */
            packageName: string
            /**
             * @description If the event is consuming, the interfaces implemented by the target template that have been
             * matched from the interface filter query.
             * Populated only in case interface filters with include_interface_view set.
             *
             * The identifier uses the package-id reference format.
             *
             * Optional
             */
            implementedInterfaces?: string[]
        }
        /** ExercisedTreeEvent */
        ExercisedTreeEvent: {
            value: components['schemas']['ExercisedEvent']
        }
        /**
         * ExperimentalCommandInspectionService
         * @description Whether the Ledger API supports command inspection service
         */
        ExperimentalCommandInspectionService: {
            supported: boolean
        }
        /**
         * ExperimentalFeatures
         * @description See the feature message definitions for descriptions.
         */
        ExperimentalFeatures: {
            staticTime?: components['schemas']['ExperimentalStaticTime']
            commandInspectionService?: components['schemas']['ExperimentalCommandInspectionService']
        }
        /**
         * ExperimentalStaticTime
         * @description Ledger is in the static time mode and exposes a time service.
         */
        ExperimentalStaticTime: {
            supported: boolean
        }
        /** FeaturesDescriptor */
        FeaturesDescriptor: {
            /**
             * @description Features under development or features that are used
             * for ledger implementation testing purposes only.
             *
             * Daml applications SHOULD not depend on these in production.
             */
            experimental?: components['schemas']['ExperimentalFeatures']
            /**
             * @description If set, then the Ledger API server supports user management.
             * It is recommended that clients query this field to gracefully adjust their behavior for
             * ledgers that do not support user management.
             */
            userManagement?: components['schemas']['UserManagementFeature']
            /**
             * @description If set, then the Ledger API server supports party management configurability.
             * It is recommended that clients query this field to gracefully adjust their behavior to
             * maximum party page size.
             */
            partyManagement?: components['schemas']['PartyManagementFeature']
            /** @description It contains the timeouts related to the periodic offset checkpoint emission */
            offsetCheckpoint?: components['schemas']['OffsetCheckpointFeature']
        }
        /** Field */
        Field: {
            varint?: number[]
            fixed64?: number[]
            fixed32?: number[]
            lengthDelimited?: string[]
        }
        /** FieldMask */
        FieldMask: {
            paths?: string[]
            unknownFields: components['schemas']['UnknownFieldSet']
        }
        /**
         * Filters
         * @description The union of a set of template filters, interface filters, or a wildcard.
         */
        Filters: {
            /**
             * @description Every filter in the cumulative list expands the scope of the resulting stream. Each interface,
             * template or wildcard filter means additional events that will match the query.
             * The impact of include_interface_view and include_created_event_blob fields in the filters will
             * also be accumulated.
             * A template or an interface SHOULD NOT appear twice in the accumulative field.
             * A wildcard filter SHOULD NOT be defined more than once in the accumulative field.
             * Optional, if no ``CumulativeFilter`` defined, the default of a single ``WildcardFilter`` with
             * include_created_event_blob unset is used.
             */
            cumulative?: components['schemas']['CumulativeFilter'][]
        }
        /**
         * GetActiveContractsRequest
         * @description If the given offset is different than the ledger end, and there are (un)assignments in-flight at the given offset,
         * the snapshot may fail with "FAILED_PRECONDITION/PARTICIPANT_PRUNED_DATA_ACCESSED".
         * Note that it is ok to request acs snapshots for party migration with offsets other than ledger end, because party
         * migration is not concerned with incomplete (un)assignments.
         */
        GetActiveContractsRequest: {
            /**
             * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
             * Templates to include in the served snapshot, per party.
             * Optional, if specified event_format must be unset, if not specified event_format must be set.
             */
            filter?: components['schemas']['TransactionFilter']
            /**
             * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
             * If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
             * In particular, setting the verbose flag to true triggers the ledger to include labels for record fields.
             * Optional, if specified event_format must be unset.
             */
            verbose: boolean
            /**
             * Format: int64
             * @description The offset at which the snapshot of the active contracts will be computed.
             * Must be no greater than the current ledger end offset.
             * Must be greater than or equal to the last pruning offset.
             * Required, must be a valid absolute offset (positive integer) or ledger begin offset (zero).
             * If zero, the empty set will be returned.
             */
            activeAtOffset: number
            /**
             * @description Format of the contract_entries in the result. In case of CreatedEvent the presentation will be of
             * TRANSACTION_SHAPE_ACS_DELTA.
             * Optional for backwards compatibility, defaults to an EventFormat where:
             *
             * - filters_by_party is the filter.filters_by_party from this request
             * - filters_for_any_party is the filter.filters_for_any_party from this request
             * - verbose is the verbose field from this request
             */
            eventFormat?: components['schemas']['EventFormat']
        }
        /** GetConnectedSynchronizersResponse */
        GetConnectedSynchronizersResponse: {
            connectedSynchronizers?: components['schemas']['ConnectedSynchronizer'][]
        }
        /** GetEventsByContractIdRequest */
        GetEventsByContractIdRequest: {
            /**
             * @description The contract id being queried.
             * Required
             */
            contractId: string
            /**
             * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
             * The parties whose events the client expects to see.
             * The events associated with the contract id will only be returned if the requesting parties includes
             * at least one party that is a stakeholder of the event. For a definition of stakeholders see
             * https://docs.daml.com/concepts/ledger-model/ledger-privacy.html#contract-observers-and-stakeholders
             * Optional, if some parties specified, event_format needs to be unset.
             */
            requestingParties?: string[]
            /**
             * @description Format of the events in the result, the presentation will be of TRANSACTION_SHAPE_ACS_DELTA.
             * Optional for backwards compatibility, defaults to an EventFormat where:
             *
             * - filters_by_party is a template-wildcard filter for all requesting_parties
             * - filters_for_any_party is unset
             * - verbose is set
             */
            eventFormat?: components['schemas']['EventFormat']
        }
        /** GetIdentityProviderConfigResponse */
        GetIdentityProviderConfigResponse: {
            identityProviderConfig?: components['schemas']['IdentityProviderConfig']
        }
        /** GetLatestPrunedOffsetsResponse */
        GetLatestPrunedOffsetsResponse: {
            /**
             * Format: int64
             * @description It will always be a non-negative integer.
             * If positive, the absolute offset up to which the ledger has been pruned,
             * disregarding the state of all divulged contracts pruning.
             * If zero, the ledger has not been pruned yet.
             */
            participantPrunedUpToInclusive: number
            /**
             * Format: int64
             * @description It will always be a non-negative integer.
             * If positive, the absolute offset up to which all divulged events have been pruned on the ledger.
             * It can be at or before the ``participant_pruned_up_to_inclusive`` offset.
             * For more details about all divulged events pruning,
             * see ``PruneRequest.prune_all_divulged_contracts`` in ``participant_pruning_service.proto``.
             * If zero, the divulged events have not been pruned yet.
             */
            allDivulgedContractsPrunedUpToInclusive: number
        }
        /** GetLedgerApiVersionResponse */
        GetLedgerApiVersionResponse: {
            /** @description The version of the ledger API. */
            version: string
            /**
             * @description The features supported by this Ledger API endpoint.
             *
             * Daml applications CAN use the feature descriptor on top of
             * version constraints on the Ledger API version to determine
             * whether a given Ledger API endpoint supports the features
             * required to run the application.
             *
             * See the feature descriptions themselves for the relation between
             * Ledger API versions and feature presence.
             */
            features?: components['schemas']['FeaturesDescriptor']
        }
        /** GetLedgerEndResponse */
        GetLedgerEndResponse: {
            /**
             * Format: int64
             * @description It will always be a non-negative integer.
             * If zero, the participant view of the ledger is empty.
             * If positive, the absolute offset of the ledger as viewed by the participant.
             */
            offset: number
        }
        /** GetPackageStatusResponse */
        GetPackageStatusResponse: {
            /** @description The status of the package. */
            packageStatus: string
        }
        /** GetParticipantIdResponse */
        GetParticipantIdResponse: {
            /**
             * @description Identifier of the participant, which SHOULD be globally unique.
             * Must be a valid LedgerString (as describe in ``value.proto``).
             */
            participantId: string
        }
        /** GetPartiesResponse */
        GetPartiesResponse: {
            /**
             * @description The details of the requested Daml parties by the participant, if known.
             * The party details may not be in the same order as requested.
             * Required
             */
            partyDetails?: components['schemas']['PartyDetails'][]
        }
        /** GetPreferredPackageVersionResponse */
        GetPreferredPackageVersionResponse: {
            /**
             * @description Not populated when no preferred package is found
             * Optional
             */
            packagePreference?: components['schemas']['PackagePreference']
        }
        /**
         * GetTransactionByIdRequest
         * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
         */
        GetTransactionByIdRequest: {
            /**
             * @description The ID of a particular transaction.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            updateId: string
            /**
             * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
             * The parties whose events the client expects to see.
             * Events that are not visible for the parties in this collection will not be present in the response.
             * Each element must be a valid PartyIdString (as described in ``value.proto``).
             * Must be set for GetTransactionTreeById request.
             * Optional for backwards compatibility for GetTransactionById request: if defined transaction_format must be
             * unset (falling back to defaults).
             */
            requestingParties?: string[]
            /**
             * @description Must be unset for GetTransactionTreeById request.
             * Optional for GetTransactionById request for backwards compatibility: defaults to a transaction_format, where:
             *
             * - event_format.filters_by_party will have template-wildcard filters for all the requesting_parties
             * - event_format.filters_for_any_party is unset
             * - event_format.verbose = true
             * - transaction_shape = TRANSACTION_SHAPE_ACS_DELTA
             */
            transactionFormat?: components['schemas']['TransactionFormat']
        }
        /**
         * GetTransactionByOffsetRequest
         * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
         */
        GetTransactionByOffsetRequest: {
            /**
             * Format: int64
             * @description The offset of the transaction being looked up.
             * Must be a valid absolute offset (positive integer).
             * Required
             */
            offset: number
            /**
             * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
             * The parties whose events the client expects to see.
             * Events that are not visible for the parties in this collection will not be present in the response.
             * Each element must be a valid PartyIdString (as described in ``value.proto``).
             * Must be set for GetTransactionTreeByOffset request.
             * Optional for backwards compatibility for GetTransactionByOffset request: if defined transaction_format must be
             * unset (falling back to defaults).
             */
            requestingParties?: string[]
            /**
             * @description Must be unset for GetTransactionTreeByOffset request.
             * Optional for GetTransactionByOffset request for backwards compatibility: defaults to a TransactionFormat, where:
             *
             * - event_format.filters_by_party will have template-wildcard filters for all the requesting_parties
             * - event_format.filters_for_any_party is unset
             * - event_format.verbose = true
             * - transaction_shape = TRANSACTION_SHAPE_ACS_DELTA
             */
            transactionFormat?: components['schemas']['TransactionFormat']
        }
        /** GetUpdateByIdRequest */
        GetUpdateByIdRequest: {
            /**
             * @description The ID of a particular update.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            updateId: string
            /**
             * @description The format for the update.
             * Required
             */
            updateFormat?: components['schemas']['UpdateFormat']
        }
        /** GetUpdateByOffsetRequest */
        GetUpdateByOffsetRequest: {
            /**
             * Format: int64
             * @description The offset of the update being looked up.
             * Must be a valid absolute offset (positive integer).
             * Required
             */
            offset: number
            /**
             * @description The format for the update.
             * Required
             */
            updateFormat?: components['schemas']['UpdateFormat']
        }
        /** GetUpdatesRequest */
        GetUpdatesRequest: {
            /**
             * Format: int64
             * @description Beginning of the requested ledger section (non-negative integer).
             * The response will only contain transactions whose offset is strictly greater than this.
             * If zero, the stream will start from the beginning of the ledger.
             * If positive, the streaming will start after this absolute offset.
             * If the ledger has been pruned, this parameter must be specified and be greater than the pruning offset.
             */
            beginExclusive: number
            /**
             * Format: int64
             * @description End of the requested ledger section.
             * The response will only contain transactions whose offset is less than or equal to this.
             * Optional, if empty, the stream will not terminate.
             * If specified, the stream will terminate after this absolute offset (positive integer) is reached.
             */
            endInclusive?: number
            /**
             * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
             * Requesting parties with template filters.
             * Template filters must be empty for GetUpdateTrees requests.
             * Optional for backwards compatibility, if defined update_format must be unset
             */
            filter?: components['schemas']['TransactionFilter']
            /**
             * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
             * If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
             * In particular, setting the verbose flag to true triggers the ledger to include labels, record and variant type ids
             * for record fields.
             * Optional for backwards compatibility, if defined update_format must be unset
             */
            verbose: boolean
            /**
             * @description Must be unset for GetUpdateTrees request.
             * Optional for backwards compatibility for GetUpdates request: defaults to an UpdateFormat where:
             *
             * - include_transactions.event_format.filters_by_party = the filter.filters_by_party on this request
             * - include_transactions.event_format.filters_for_any_party = the filter.filters_for_any_party on this request
             * - include_transactions.event_format.verbose = the same flag specified on this request
             * - include_transactions.transaction_shape = TRANSACTION_SHAPE_ACS_DELTA
             * - include_reassignments.filter = the same filter specified on this request
             * - include_reassignments.verbose = the same flag specified on this request
             * - include_topology_events.include_participant_authorization_events.parties = all the parties specified in filter
             */
            updateFormat?: components['schemas']['UpdateFormat']
        }
        /** GetUserResponse */
        GetUserResponse: {
            /** @description Retrieved user. */
            user?: components['schemas']['User']
        }
        /**
         * GrantUserRightsRequest
         * @description Add the rights to the set of rights granted to the user.
         *
         * Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
         */
        GrantUserRightsRequest: {
            /**
             * @description The user to whom to grant rights.
             * Required
             */
            userId: string
            /**
             * @description The rights to grant.
             * Optional
             */
            rights?: components['schemas']['Right'][]
            /**
             * @description The id of the ``Identity Provider``
             * Optional, if not set, assume the user is managed by the default identity provider.
             */
            identityProviderId: string
        }
        /** GrantUserRightsResponse */
        GrantUserRightsResponse: {
            /** @description The rights that were newly granted by the request. */
            newlyGrantedRights?: components['schemas']['Right'][]
        }
        /** Identifier */
        Identifier: {
            packageId: string
            moduleName: string
            entityName: string
        }
        /** IdentifierFilter */
        IdentifierFilter: OneOf<
            [
                {
                    Empty: components['schemas']['Empty1']
                },
                {
                    InterfaceFilter: components['schemas']['InterfaceFilter']
                },
                {
                    TemplateFilter: components['schemas']['TemplateFilter']
                },
                {
                    WildcardFilter: components['schemas']['WildcardFilter']
                },
            ]
        >
        /** IdentityProviderAdmin */
        IdentityProviderAdmin: {
            value: components['schemas']['IdentityProviderAdmin1']
        }
        /** IdentityProviderAdmin */
        IdentityProviderAdmin1: Record<string, never>
        /** IdentityProviderConfig */
        IdentityProviderConfig: {
            /**
             * @description The identity provider identifier
             * Must be a valid LedgerString (as describe in ``value.proto``).
             * Required
             */
            identityProviderId: string
            /**
             * @description When set, the callers using JWT tokens issued by this identity provider are denied all access
             * to the Ledger API.
             * Optional,
             * Modifiable
             */
            isDeactivated: boolean
            /**
             * @description Specifies the issuer of the JWT token.
             * The issuer value is a case sensitive URL using the https scheme that contains scheme, host,
             * and optionally, port number and path components and no query or fragment components.
             * Required
             * Modifiable
             */
            issuer: string
            /**
             * @description The JWKS (JSON Web Key Set) URL.
             * The Ledger API uses JWKs (JSON Web Keys) from the provided URL to verify that the JWT has been
             * signed with the loaded JWK. Only RS256 (RSA Signature with SHA-256) signing algorithm is supported.
             * Required
             * Modifiable
             */
            jwksUrl: string
            /**
             * @description Specifies the audience of the JWT token.
             * When set, the callers using JWT tokens issued by this identity provider are allowed to get an access
             * only if the "aud" claim includes the string specified here
             * Optional,
             * Modifiable
             */
            audience: string
        }
        /**
         * InterfaceFilter
         * @description This filter matches contracts that implement a specific interface.
         */
        InterfaceFilter: {
            value: components['schemas']['InterfaceFilter1']
        }
        /**
         * InterfaceFilter
         * @description This filter matches contracts that implement a specific interface.
         */
        InterfaceFilter1: {
            /**
             * @description The interface that a matching contract must implement.
             * The ``interface_id`` needs to be valid: corresponding interface should be defined in
             * one of the available packages at the time of the query.
             * Both package-name and package-id reference formats for the identifier are supported.
             * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
             *
             * Required
             */
            interfaceId?: string
            /**
             * @description Whether to include the interface view on the contract in the returned ``CreatedEvent``.
             * Use this to access contract data in a uniform manner in your API client.
             * Optional
             */
            includeInterfaceView: boolean
            /**
             * @description Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
             * Use this to access the contract create event payload in your API client
             * for submitting it as a disclosed contract with future commands.
             * Optional
             */
            includeCreatedEventBlob: boolean
        }
        /** JsActiveContract */
        JsActiveContract: {
            /**
             * @description Required
             * The event as it appeared in the context of its last update (i.e. daml transaction or
             * reassignment). In particular, the last offset, node_id pair is preserved.
             * The last update is the most recent update created or assigned this contract on synchronizer_id synchronizer.
             * The offset of the CreatedEvent might point to an already pruned update, therefore it cannot necessarily be used
             * for lookups.
             */
            createdEvent: components['schemas']['CreatedEvent']
            /**
             * @description A valid synchronizer id
             * Required
             */
            synchronizerId: string
            /**
             * Format: int64
             * @description Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
             * with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
             * equals zero.
             * This field will be the reassignment_counter of the latest observable activation event on this synchronizer, which is
             * before the active_at_offset.
             * Required
             */
            reassignmentCounter: number
        }
        /** JsArchived */
        JsArchived: {
            /** @description Required */
            archivedEvent: components['schemas']['ArchivedEvent']
            /**
             * @description Required
             * The synchronizer which sequenced the archival of the contract
             */
            synchronizerId: string
        }
        /**
         * JsAssignedEvent
         * @description Records that a contract has been assigned, and it can be used on the target synchronizer.
         */
        JsAssignedEvent: {
            /**
             * @description The ID of the source synchronizer.
             * Must be a valid synchronizer id.
             * Required
             */
            source: string
            /**
             * @description The ID of the target synchronizer.
             * Must be a valid synchronizer id.
             * Required
             */
            target: string
            /**
             * @description The ID from the unassigned event.
             * For correlation capabilities.
             * For one contract the (unassign_id, source synchronizer) pair is unique.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            unassignId: string
            /**
             * @description Party on whose behalf the assign command was executed.
             * Empty if the assignment happened offline via the repair service.
             * Must be a valid PartyIdString (as described in ``value.proto``).
             * Optional
             */
            submitter: string
            /**
             * Format: int64
             * @description Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
             * with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
             * equals zero.
             * Required
             */
            reassignmentCounter: number
            /**
             * @description Required
             * The offset of this event refers to the offset of the assignment,
             * while the node_id is the index of within the batch.
             */
            createdEvent: components['schemas']['CreatedEvent']
        }
        /** JsAssignmentEvent */
        JsAssignmentEvent: {
            source: string
            target: string
            unassignId: string
            submitter: string
            /** Format: int64 */
            reassignmentCounter: number
            createdEvent: components['schemas']['CreatedEvent']
        }
        /** JsCantonError */
        JsCantonError: {
            code: string
            cause: string
            correlationId?: string
            traceId?: string
            context: components['schemas']['Map_String']
            resources?: components['schemas']['Tuple2_String_String'][]
            /** Format: int32 */
            errorCategory: number
            /** Format: int32 */
            grpcCodeValue?: number
            retryInfo?: string
            definiteAnswer?: boolean
        }
        /**
         * JsCommands
         * @description A composite command that groups multiple commands together.
         */
        JsCommands: {
            /**
             * @description Individual elements of this atomic command. Must be non-empty.
             * Required
             */
            commands?: components['schemas']['Command'][]
            /**
             * @description Uniquely identifies the command.
             * The triple (user_id, act_as, command_id) constitutes the change ID for the intended ledger change,
             * where act_as is interpreted as a set of party names.
             * The change ID can be used for matching the intended ledger changes with all their completions.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            commandId: string
            /**
             * @description Set of parties on whose behalf the command should be executed.
             * If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
             * to act on behalf of each of the given parties.
             * Each element must be a valid PartyIdString (as described in ``value.proto``).
             * Required, must be non-empty.
             */
            actAs?: string[]
            /**
             * @description Uniquely identifies the participant user that issued the command.
             * Must be a valid UserIdString (as described in ``value.proto``).
             * Required unless authentication is used with a user token.
             * In that case, the token's user-id will be used for the request's user_id.
             */
            userId?: string
            /**
             * @description Set of parties on whose behalf (in addition to all parties listed in ``act_as``) contracts can be retrieved.
             * This affects Daml operations such as ``fetch``, ``fetchByKey``, ``lookupByKey``, ``exercise``, and ``exerciseByKey``.
             * Note: A participant node of a Daml network can host multiple parties. Each contract present on the participant
             * node is only visible to a subset of these parties. A command can only use contracts that are visible to at least
             * one of the parties in ``act_as`` or ``read_as``. This visibility check is independent from the Daml authorization
             * rules for fetch operations.
             * If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
             * to read contract data on behalf of each of the given parties.
             * Optional
             */
            readAs?: string[]
            /**
             * @description Identifier of the on-ledger workflow that this command is a part of.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Optional
             */
            workflowId?: string
            deduplicationPeriod?: components['schemas']['DeduplicationPeriod']
            /**
             * @description Lower bound for the ledger time assigned to the resulting transaction.
             * Note: The ledger time of a transaction is assigned as part of command interpretation.
             * Use this property if you expect that command interpretation will take a considerate amount of time, such that by
             * the time the resulting transaction is sequenced, its assigned ledger time is not valid anymore.
             * Must not be set at the same time as min_ledger_time_rel.
             * Optional
             */
            minLedgerTimeAbs?: string
            /**
             * @description Same as min_ledger_time_abs, but specified as a duration, starting from the time the command is received by the server.
             * Must not be set at the same time as min_ledger_time_abs.
             * Optional
             */
            minLedgerTimeRel?: components['schemas']['Duration']
            /**
             * @description A unique identifier to distinguish completions for different submissions with the same change ID.
             * Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
             * with the same change ID.
             * Must be a valid LedgerString (as described in ``value.proto``).
             *
             * If omitted, the participant or the committer may set a value of their choice.
             * Optional
             */
            submissionId?: string
            /**
             * @description Additional contracts used to resolve contract & contract key lookups.
             * Optional
             */
            disclosedContracts?: components['schemas']['DisclosedContract'][]
            /**
             * @description Must be a valid synchronizer id
             * Optional
             */
            synchronizerId?: string
            /**
             * @description The package-id selection preference of the client for resolving
             * package names and interface instances in command submission and interpretation
             */
            packageIdSelectionPreference?: string[]
        }
        /**
         * JsContractEntry
         * @description For a contract there could be multiple contract_entry-s in the entire snapshot. These together define
         * the state of one contract in the snapshot.
         * A contract_entry is included in the result, if and only if there is at least one stakeholder party of the contract
         * that is hosted on the synchronizer at the time of the event and the party satisfies the
         * ``TransactionFilter`` in the query.
         */
        JsContractEntry: OneOf<
            [
                {
                    JsActiveContract: components['schemas']['JsActiveContract']
                },
                {
                    JsEmpty: components['schemas']['JsEmpty']
                },
                {
                    JsIncompleteAssigned: components['schemas']['JsIncompleteAssigned']
                },
                {
                    JsIncompleteUnassigned: components['schemas']['JsIncompleteUnassigned']
                },
            ]
        >
        /** JsCreated */
        JsCreated: {
            /**
             * @description Required
             * The event as it appeared in the context of its original update (i.e. daml transaction or
             * reassignment) on this participant node. You can use its offset and node_id to find the
             * corresponding update and the node within it.
             */
            createdEvent: components['schemas']['CreatedEvent']
            /**
             * @description The synchronizer which sequenced the creation of the contract
             * Required
             */
            synchronizerId: string
        }
        /** JsEmpty */
        JsEmpty: Record<string, never>
        /** JsExecuteSubmissionRequest */
        JsExecuteSubmissionRequest: {
            /**
             * @description the prepared transaction
             * Typically this is the value of the `prepared_transaction` field in `PrepareSubmissionResponse`
             * obtained from calling `prepareSubmission`.
             */
            preparedTransaction?: string
            /**
             * @description The party(ies) signatures that authorize the prepared submission to be executed by this node.
             * Each party can provide one or more signatures..
             * and one or more parties can sign.
             * Note that currently, only single party submissions are supported.
             */
            partySignatures?: components['schemas']['PartySignatures']
            deduplicationPeriod: components['schemas']['DeduplicationPeriod2']
            /**
             * @description A unique identifier to distinguish completions for different submissions with the same change ID.
             * Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
             * with the same change ID.
             * Must be a valid LedgerString (as described in ``value.proto``).
             *
             * Required
             */
            submissionId: string
            /** @description See [PrepareSubmissionRequest.user_id] */
            userId: string
            /** @description The hashing scheme version used when building the hash */
            hashingSchemeVersion: string
            /**
             * @description If set will influence the chosen ledger effective time but will not result in a submission delay so any override
             * should be scheduled to executed within the window allowed by synchronizer.
             * Optional
             */
            minLedgerTime?: components['schemas']['MinLedgerTime']
        }
        /** JsGetActiveContractsResponse */
        JsGetActiveContractsResponse: {
            /**
             * @description The workflow ID used in command submission which corresponds to the contract_entry. Only set if
             * the ``workflow_id`` for the command was set.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Optional
             */
            workflowId: string
            contractEntry: components['schemas']['JsContractEntry']
        }
        /** JsGetEventsByContractIdResponse */
        JsGetEventsByContractIdResponse: {
            /**
             * @description The create event for the contract with the ``contract_id`` given in the request
             * provided it exists and has not yet been pruned.
             * Optional
             */
            created?: components['schemas']['JsCreated']
            /**
             * @description The archive event for the contract with the ``contract_id`` given in the request
             * provided such an archive event exists and it has not yet been pruned.
             * Optional
             */
            archived?: components['schemas']['JsArchived']
        }
        /**
         * JsGetTransactionResponse
         * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
         */
        JsGetTransactionResponse: {
            /** @description Required */
            transaction: components['schemas']['JsTransaction']
        }
        /**
         * JsGetTransactionTreeResponse
         * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
         */
        JsGetTransactionTreeResponse: {
            /** @description Required */
            transaction: components['schemas']['JsTransactionTree']
        }
        /** JsGetUpdateResponse */
        JsGetUpdateResponse: {
            update: components['schemas']['Update']
        }
        /**
         * JsGetUpdateTreesResponse
         * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
         */
        JsGetUpdateTreesResponse: {
            update: components['schemas']['Update1']
        }
        /** JsGetUpdatesResponse */
        JsGetUpdatesResponse: {
            update: components['schemas']['Update']
        }
        /** JsIncompleteAssigned */
        JsIncompleteAssigned: {
            /** @description Required */
            assignedEvent: components['schemas']['JsAssignedEvent']
        }
        /** JsIncompleteUnassigned */
        JsIncompleteUnassigned: {
            /**
             * @description Required
             * The event as it appeared in the context of its last activation update (i.e. daml transaction or
             * reassignment). In particular, the last activation offset, node_id pair is preserved.
             * The last activation update is the most recent update created or assigned this contract on synchronizer_id synchronizer before
             * the unassigned_event.
             * The offset of the CreatedEvent might point to an already pruned update, therefore it cannot necessarily be used
             * for lookups.
             */
            createdEvent: components['schemas']['CreatedEvent']
            /** @description Required */
            unassignedEvent: components['schemas']['UnassignedEvent']
        }
        /**
         * JsInterfaceView
         * @description View of a create event matched by an interface filter.
         */
        JsInterfaceView: {
            /**
             * @description The interface implemented by the matched event.
             * The identifier uses the package-id reference format.
             *
             * Required
             */
            interfaceId: string
            /**
             * @description Whether the view was successfully computed, and if not,
             * the reason for the error. The error is reported using the same rules
             * for error codes and messages as the errors returned for API requests.
             * Required
             */
            viewStatus: components['schemas']['JsStatus']
            /**
             * @description The value of the interface's view method on this event.
             * Set if it was requested in the ``InterfaceFilter`` and it could be
             * sucessfully computed.
             * Optional
             */
            viewValue?: unknown
        }
        /** JsPrepareSubmissionRequest */
        JsPrepareSubmissionRequest: {
            /**
             * @description Uniquely identifies the participant user that prepares the transaction.
             * Must be a valid UserIdString (as described in ``value.proto``).
             * Required unless authentication is used with a user token.
             * In that case, the token's user-id will be used for the request's user_id.
             */
            userId: string
            /**
             * @description Uniquely identifies the command.
             * The triple (user_id, act_as, command_id) constitutes the change ID for the intended ledger change,
             * where act_as is interpreted as a set of party names.
             * The change ID can be used for matching the intended ledger changes with all their completions.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            commandId: string
            /**
             * @description Individual elements of this atomic command. Must be non-empty.
             * Required
             */
            commands?: components['schemas']['Command'][]
            /** @description Optional */
            minLedgerTime?: components['schemas']['MinLedgerTime']
            /**
             * @description Set of parties on whose behalf the command should be executed, if submitted.
             * If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
             * to **read** (not act) on behalf of each of the given parties. This is because this RPC merely prepares a transaction
             * and does not execute it. Therefore read authorization is sufficient even for actAs parties.
             * Note: This may change, and more specific authorization scope may be introduced in the future.
             * Each element must be a valid PartyIdString (as described in ``value.proto``).
             * Required, must be non-empty.
             */
            actAs?: string[]
            /**
             * @description Set of parties on whose behalf (in addition to all parties listed in ``act_as``) contracts can be retrieved.
             * This affects Daml operations such as ``fetch``, ``fetchByKey``, ``lookupByKey``, ``exercise``, and ``exerciseByKey``.
             * Note: A command can only use contracts that are visible to at least
             * one of the parties in ``act_as`` or ``read_as``. This visibility check is independent from the Daml authorization
             * rules for fetch operations.
             * If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
             * to read contract data on behalf of each of the given parties.
             * Optional
             */
            readAs?: string[]
            /**
             * @description Additional contracts used to resolve contract & contract key lookups.
             * Optional
             */
            disclosedContracts?: components['schemas']['DisclosedContract'][]
            /**
             * @description Must be a valid synchronizer id
             * Required
             */
            synchronizerId: string
            /**
             * @description The package-id selection preference of the client for resolving
             * package names and interface instances in command submission and interpretation
             */
            packageIdSelectionPreference?: string[]
            /**
             * @description When true, the response will contain additional details on how the transaction was encoded and hashed
             * This can be useful for troubleshooting of hash mismatches. Should only be used for debugging.
             */
            verboseHashing: boolean
        }
        /**
         * JsPrepareSubmissionResponse
         * @description [docs-entry-end: HashingSchemeVersion]
         */
        JsPrepareSubmissionResponse: {
            /**
             * @description The interpreted transaction, it represents the ledger changes necessary to execute the commands specified in the request.
             * Clients MUST display the content of the transaction to the user for them to validate before signing the hash if the preparing participant is not trusted.
             */
            preparedTransaction?: string
            /**
             * @description Hash of the transaction, this is what needs to be signed by the party to authorize the transaction.
             * Only provided for convenience, clients MUST recompute the hash from the raw transaction if the preparing participant is not trusted.
             * May be removed in future versions
             */
            preparedTransactionHash: string
            /** @description The hashing scheme version used when building the hash */
            hashingSchemeVersion: string
            /**
             * @description Optional additional details on how the transaction was encoded and hashed. Only set if verbose_hashing = true in the request
             * Note that there are no guarantees on the stability of the format or content of this field.
             * Its content should NOT be parsed and should only be used for troubleshooting purposes.
             */
            hashingDetails?: string
        }
        /**
         * JsReassignment
         * @description Complete view of an on-ledger reassignment.
         */
        JsReassignment: {
            /**
             * @description Assigned by the server. Useful for correlating logs.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            updateId: string
            /**
             * @description The ID of the command which resulted in this reassignment. Missing for everyone except the submitting party on the submitting participant.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Optional
             */
            commandId: string
            /**
             * @description The workflow ID used in reassignment command submission. Only set if the ``workflow_id`` for the command was set.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Optional
             */
            workflowId: string
            /**
             * Format: int64
             * @description The participant's offset. The details of this field are described in ``community/ledger-api/README.md``.
             * Required, must be a valid absolute offset (positive integer).
             */
            offset: number
            /** @description The collection of reassignment events. Required. */
            events?: components['schemas']['JsReassignmentEvent'][]
            /**
             * @description Optional; ledger API trace context
             *
             * The trace context transported in this message corresponds to the trace context supplied
             * by the client application in a HTTP2 header of the original command submission.
             * We typically use a header to transfer this type of information. Here we use message
             * body, because it is used in gRPC streams which do not support per message headers.
             * This field will be populated with the trace context contained in the original submission.
             * If that was not provided, a unique ledger-api-server generated trace context will be used
             * instead.
             */
            traceContext?: components['schemas']['TraceContext']
            /**
             * @description The time at which the reassignment was recorded. The record time refers to the source/target
             * synchronizer for an unassign/assign event respectively.
             * Required
             */
            recordTime: string
        }
        /** JsReassignmentEvent */
        JsReassignmentEvent: OneOf<
            [
                {
                    JsAssignmentEvent: components['schemas']['JsAssignmentEvent']
                },
                {
                    JsUnassignedEvent: components['schemas']['JsUnassignedEvent']
                },
            ]
        >
        /** JsStatus */
        JsStatus: {
            /** Format: int32 */
            code: number
            message: string
            details?: components['schemas']['ProtoAny'][]
        }
        /** JsSubmitAndWaitForReassignmentResponse */
        JsSubmitAndWaitForReassignmentResponse: {
            /**
             * @description The reassignment that resulted from the submitted reassignment command.
             * The reassignment might contain no events (request conditions result in filtering out all of them).
             * Required
             */
            reassignment: components['schemas']['JsReassignment']
        }
        /**
         * JsSubmitAndWaitForTransactionRequest
         * @description These commands are executed as a single atomic transaction.
         */
        JsSubmitAndWaitForTransactionRequest: {
            /**
             * @description The commands to be submitted.
             * Required
             */
            commands: components['schemas']['JsCommands']
            /**
             * @description If no ``transaction_format`` is provided, a default will be used where ``transaction_shape`` is set to
             * TRANSACTION_SHAPE_ACS_DELTA, ``event_format`` is defined with ``filters_by_party`` containing wildcard-template
             * filter for all original ``act_as`` and ``read_as`` parties and the ``verbose`` flag is set.
             * Optional
             */
            transactionFormat?: components['schemas']['TransactionFormat']
        }
        /** JsSubmitAndWaitForTransactionResponse */
        JsSubmitAndWaitForTransactionResponse: {
            /**
             * @description The transaction that resulted from the submitted command.
             * The transaction might contain no events (request conditions result in filtering out all of them).
             * Required
             */
            transaction: components['schemas']['JsTransaction']
        }
        /**
         * JsSubmitAndWaitForTransactionTreeResponse
         * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
         */
        JsSubmitAndWaitForTransactionTreeResponse: {
            transactionTree: components['schemas']['JsTransactionTree']
        }
        /** JsTopologyTransaction */
        JsTopologyTransaction: {
            /**
             * @description Assigned by the server. Useful for correlating logs.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            updateId: string
            /**
             * @description A non-empty list of topology events.
             * Required
             */
            events?: components['schemas']['TopologyEvent'][]
            /**
             * Format: int64
             * @description The absolute offset. The details of this field are described in ``community/ledger-api/README.md``.
             * Required, it is a valid absolute offset (positive integer).
             */
            offset: number
            /**
             * @description A valid synchronizer id.
             * Identifies the synchronizer that synchronized the topology transaction.
             * Required
             */
            synchronizerId: string
            /**
             * @description Optional; ledger API trace context
             *
             * The trace context transported in this message corresponds to the trace context supplied
             * by the client application in a HTTP2 header of the original command submission.
             * We typically use a header to transfer this type of information. Here we use message
             * body, because it is used in gRPC streams which do not support per message headers.
             * This field will be populated with the trace context contained in the original submission.
             * If that was not provided, a unique ledger-api-server generated trace context will be used
             * instead.
             */
            traceContext?: components['schemas']['TraceContext']
            /**
             * @description The time at which the changes in the topology transaction become effective. There is a small delay between a
             * topology transaction being sequenced and the changes it contains becoming effective. Topology transactions appear
             * in order relative to a synchronizer based on their effective time rather than their sequencing time.
             * Required
             */
            recordTime: string
        }
        /**
         * JsTransaction
         * @description Filtered view of an on-ledger transaction's create and archive events.
         */
        JsTransaction: {
            /**
             * @description Assigned by the server. Useful for correlating logs.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            updateId: string
            /**
             * @description The ID of the command which resulted in this transaction. Missing for everyone except the submitting party.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Optional
             */
            commandId: string
            /**
             * @description The workflow ID used in command submission.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Optional
             */
            workflowId: string
            /**
             * @description Ledger effective time.
             * Required
             */
            effectiveAt: string
            /**
             * @description The collection of events.
             * Contains:
             *
             * - ``CreatedEvent`` or ``ArchivedEvent`` in case of ACS_DELTA transaction shape
             * - ``CreatedEvent`` or ``ExercisedEvent`` in case of LEDGER_EFFECTS transaction shape
             *
             * Required
             */
            events?: components['schemas']['Event'][]
            /**
             * Format: int64
             * @description The absolute offset. The details of this field are described in ``community/ledger-api/README.md``.
             * Required, it is a valid absolute offset (positive integer).
             */
            offset: number
            /**
             * @description A valid synchronizer id.
             * Identifies the synchronizer that synchronized the transaction.
             * Required
             */
            synchronizerId: string
            /**
             * @description Optional; ledger API trace context
             *
             * The trace context transported in this message corresponds to the trace context supplied
             * by the client application in a HTTP2 header of the original command submission.
             * We typically use a header to transfer this type of information. Here we use message
             * body, because it is used in gRPC streams which do not support per message headers.
             * This field will be populated with the trace context contained in the original submission.
             * If that was not provided, a unique ledger-api-server generated trace context will be used
             * instead.
             */
            traceContext?: components['schemas']['TraceContext']
            /**
             * @description The time at which the transaction was recorded. The record time refers to the synchronizer
             * which synchronized the transaction.
             * Required
             */
            recordTime: string
        }
        /**
         * JsTransactionTree
         * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
         * Complete view of an on-ledger transaction.
         */
        JsTransactionTree: {
            /**
             * @description Assigned by the server. Useful for correlating logs.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            updateId: string
            /**
             * @description The ID of the command which resulted in this transaction. Missing for everyone except the submitting party.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Optional
             */
            commandId: string
            /**
             * @description The workflow ID used in command submission. Only set if the ``workflow_id`` for the command was set.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Optional
             */
            workflowId: string
            /**
             * @description Ledger effective time.
             * Required
             */
            effectiveAt?: string
            /**
             * Format: int64
             * @description The absolute offset. The details of this field are described in ``community/ledger-api/README.md``.
             * Required, it is a valid absolute offset (positive integer).
             */
            offset: number
            /**
             * @description Changes to the ledger that were caused by this transaction. Nodes of the transaction tree.
             * Each key must be a valid node ID (non-negative integer).
             * Required
             */
            eventsById: components['schemas']['Map_Int_TreeEvent']
            /**
             * @description A valid synchronizer id.
             * Identifies the synchronizer that synchronized the transaction.
             * Required
             */
            synchronizerId: string
            /**
             * @description Optional; ledger API trace context
             *
             * The trace context transported in this message corresponds to the trace context supplied
             * by the client application in a HTTP2 header of the original command submission.
             * We typically use a header to transfer this type of information. Here we use message
             * body, because it is used in gRPC streams which do not support per message headers.
             * This field will be populated with the trace context contained in the original submission.
             * If that was not provided, a unique ledger-api-server generated trace context will be used
             * instead.
             */
            traceContext?: components['schemas']['TraceContext']
            /**
             * @description The time at which the transaction was recorded. The record time refers to the synchronizer
             * which synchronized the transaction.
             * Required
             */
            recordTime: string
        }
        /**
         * JsUnassignedEvent
         * @description Records that a contract has been unassigned, and it becomes unusable on the source synchronizer
         */
        JsUnassignedEvent: {
            value: components['schemas']['UnassignedEvent']
        }
        /**
         * Kind
         * @description Required
         */
        Kind:
            | {
                  CanActAs: components['schemas']['CanActAs']
              }
            | {
                  CanReadAs: components['schemas']['CanReadAs']
              }
            | {
                  CanReadAsAnyParty: components['schemas']['CanReadAsAnyParty']
              }
            | {
                  Empty: components['schemas']['Empty5']
              }
            | {
                  IdentityProviderAdmin: components['schemas']['IdentityProviderAdmin']
              }
            | {
                  ParticipantAdmin: components['schemas']['ParticipantAdmin']
              }
        /** ListIdentityProviderConfigsResponse */
        ListIdentityProviderConfigsResponse: {
            identityProviderConfigs?: components['schemas']['IdentityProviderConfig'][]
        }
        /** ListKnownPartiesResponse */
        ListKnownPartiesResponse: {
            /**
             * @description The details of all Daml parties known by the participant.
             * Required
             */
            partyDetails?: components['schemas']['PartyDetails'][]
            /**
             * @description Pagination token to retrieve the next page.
             * Empty, if there are no further results.
             */
            nextPageToken: string
        }
        /** ListPackagesResponse */
        ListPackagesResponse: {
            /**
             * @description The IDs of all Daml-LF packages supported by the server.
             * Each element must be a valid PackageIdString (as described in ``value.proto``).
             * Required
             */
            packageIds?: string[]
        }
        /** ListUserRightsResponse */
        ListUserRightsResponse: {
            /** @description All rights of the user. */
            rights?: components['schemas']['Right'][]
        }
        /** ListUsersResponse */
        ListUsersResponse: {
            /** @description A subset of users of the participant node that fit into this page. */
            users?: components['schemas']['User'][]
            /**
             * @description Pagination token to retrieve the next page.
             * Empty, if there are no further results.
             */
            nextPageToken: string
        }
        /** Map_Filters */
        Map_Filters: {
            [key: string]: components['schemas']['Filters']
        }
        /** Map_Int_Field */
        Map_Int_Field: {
            [key: string]: components['schemas']['Field']
        }
        /** Map_Int_TreeEvent */
        Map_Int_TreeEvent: {
            [key: string]: components['schemas']['TreeEvent']
        }
        /** Map_String */
        Map_String: {
            [key: string]: string
        }
        /** MinLedgerTime */
        MinLedgerTime: {
            time: components['schemas']['Time']
        }
        /** MinLedgerTimeAbs */
        MinLedgerTimeAbs: {
            value: string
        }
        /** MinLedgerTimeRel */
        MinLedgerTimeRel: {
            value: components['schemas']['Duration']
        }
        /**
         * ObjectMeta
         * @description Represents metadata corresponding to a participant resource (e.g. a participant user or participant local information about a party).
         *
         * Based on ``ObjectMeta`` meta used in Kubernetes API.
         * See https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/generated.proto#L640
         */
        ObjectMeta: {
            /**
             * @description An opaque, non-empty value, populated by a participant server which represents the internal version of the resource
             * this ``ObjectMeta`` message is attached to. The participant server will change it to a unique value each time the corresponding resource is updated.
             * You must not rely on the format of resource version. The participant server might change it without notice.
             * You can obtain the newest resource version value by issuing a read request.
             * You may use it for concurrent change detection by passing it back unmodified in an update request.
             * The participant server will then compare the passed value with the value maintained by the system to determine
             * if any other updates took place since you had read the resource version.
             * Upon a successful update you are guaranteed that no other update took place during your read-modify-write sequence.
             * However, if another update took place during your read-modify-write sequence then your update will fail with an appropriate error.
             * Concurrent change control is optional. It will be applied only if you include a resource version in an update request.
             * When creating a new instance of a resource you must leave the resource version empty.
             * Its value will be populated by the participant server upon successful resource creation.
             * Optional
             */
            resourceVersion: string
            /**
             * @description A set of modifiable key-value pairs that can be used to represent arbitrary, client-specific metadata.
             * Constraints:
             *
             * 1. The total size over all keys and values cannot exceed 256kb in UTF-8 encoding.
             * 2. Keys are composed of an optional prefix segment and a required name segment such that:
             *
             *    - key prefix, when present, must be a valid DNS subdomain with at most 253 characters, followed by a '/' (forward slash) character,
             *    - name segment must have at most 63 characters that are either alphanumeric ([a-z0-9A-Z]), or a '.' (dot), '-' (dash) or '_' (underscore);
             *      and it must start and end with an alphanumeric character.
             *
             * 3. Values can be any non-empty strings.
             *
             * Keys with empty prefix are reserved for end-users.
             * Properties set by external tools or internally by the participant server must use non-empty key prefixes.
             * Duplicate keys are disallowed by the semantics of the protobuf3 maps.
             * See: https://developers.google.com/protocol-buffers/docs/proto3#maps
             * Annotations may be a part of a modifiable resource.
             * Use the resource's update RPC to update its annotations.
             * In order to add a new annotation or update an existing one using an update RPC, provide the desired annotation in the update request.
             * In order to remove an annotation using an update RPC, provide the target annotation's key but set its value to the empty string in the update request.
             * Optional
             * Modifiable
             */
            annotations: components['schemas']['Map_String']
        }
        /**
         * OffsetCheckpoint
         * @description OffsetCheckpoints may be used to:
         *
         * - detect time out of commands.
         * - provide an offset which can be used to restart consumption.
         */
        OffsetCheckpoint: {
            value: components['schemas']['OffsetCheckpoint1']
        }
        /**
         * OffsetCheckpoint
         * @description OffsetCheckpoints may be used to:
         *
         * - detect time out of commands.
         * - provide an offset which can be used to restart consumption.
         */
        OffsetCheckpoint1: {
            /**
             * Format: int64
             * @description The participant's offset, the details of the offset field are described in ``community/ledger-api/README.md``.
             * Required, must be a valid absolute offset (positive integer).
             */
            offset: number
            synchronizerTimes?: components['schemas']['SynchronizerTime'][]
        }
        /**
         * OffsetCheckpoint
         * @description OffsetCheckpoints may be used to:
         *
         * - detect time out of commands.
         * - provide an offset which can be used to restart consumption.
         */
        OffsetCheckpoint2: {
            value: components['schemas']['OffsetCheckpoint1']
        }
        /**
         * OffsetCheckpoint
         * @description OffsetCheckpoints may be used to:
         *
         * - detect time out of commands.
         * - provide an offset which can be used to restart consumption.
         */
        OffsetCheckpoint3: {
            value: components['schemas']['OffsetCheckpoint1']
        }
        /** OffsetCheckpointFeature */
        OffsetCheckpointFeature: {
            /** @description The maximum delay to emmit a new OffsetCheckpoint if it exists */
            maxOffsetCheckpointEmissionDelay?: components['schemas']['Duration']
        }
        /** PackagePreference */
        PackagePreference: {
            /**
             * @description The package reference of the preferred package.
             * Required
             */
            packageReference?: components['schemas']['PackageReference']
            /**
             * @description The synchronizer for which the preferred package was computed.
             * If the synchronizer_id was specified in the request, then it matches the request synchronizer_id.
             * Required
             */
            synchronizerId: string
        }
        /** PackageReference */
        PackageReference: {
            /** @description Required */
            packageId: string
            /** @description Required */
            packageName: string
            /** @description Required */
            packageVersion: string
        }
        /** ParticipantAdmin */
        ParticipantAdmin: {
            value: components['schemas']['ParticipantAdmin1']
        }
        /** ParticipantAdmin */
        ParticipantAdmin1: Record<string, never>
        /** ParticipantAuthorizationAdded */
        ParticipantAuthorizationAdded: {
            /** @description Required */
            partyId: string
            /** @description Required */
            participantId: string
            /**
             * Format: int32
             * @description Required
             */
            participantPermission: number
        }
        /** ParticipantAuthorizationChanged */
        ParticipantAuthorizationChanged: {
            /** @description Required */
            partyId: string
            /** @description Required */
            participantId: string
            /**
             * Format: int32
             * @description Required
             */
            participantPermission: number
        }
        /** ParticipantAuthorizationRevoked */
        ParticipantAuthorizationRevoked: {
            /** @description Required */
            partyId: string
            /** @description Required */
            participantId: string
        }
        /**
         * ParticipantAuthorizationTopologyFormat
         * @description A format specifying which participant authorization topology transactions to include and how to render them.
         */
        ParticipantAuthorizationTopologyFormat: {
            /**
             * @description List of parties for which the topology transactions should be sent.
             * Empty means: for all parties.
             */
            parties?: string[]
        }
        /** PartyDetails */
        PartyDetails: {
            /**
             * @description The stable unique identifier of a Daml party.
             * Must be a valid PartyIdString (as described in ``value.proto``).
             * Required
             */
            party: string
            /**
             * @description true if party is hosted by the participant and the party shares the same identity provider as the user issuing the request.
             * Optional
             */
            isLocal: boolean
            /**
             * @description Participant-local metadata of this party.
             * Optional,
             * Modifiable
             */
            localMetadata?: components['schemas']['ObjectMeta']
            /**
             * @description The id of the ``Identity Provider``
             * Optional, if not set, there could be 3 options:
             *
             * 1. the party is managed by the default identity provider.
             * 2. party is not hosted by the participant.
             * 3. party is hosted by the participant, but is outside of the user's identity provider.
             */
            identityProviderId: string
        }
        /** PartyManagementFeature */
        PartyManagementFeature: {
            /**
             * Format: int32
             * @description The maximum number of parties the server can return in a single response (page).
             */
            maxPartiesPageSize: number
        }
        /**
         * PartySignatures
         * @description Additional signatures provided by the submitting parties
         */
        PartySignatures: {
            /** @description Additional signatures provided by all individual parties */
            signatures?: components['schemas']['SinglePartySignatures'][]
        }
        /** ProtoAny */
        ProtoAny: {
            typeUrl: string
            value: string
            unknownFields: components['schemas']['UnknownFieldSet']
        }
        /**
         * Reassignment
         * @description Complete view of an on-ledger reassignment.
         */
        Reassignment: {
            value: components['schemas']['JsReassignment']
        }
        /**
         * Reassignment
         * @description Complete view of an on-ledger reassignment.
         */
        Reassignment1: {
            value: components['schemas']['JsReassignment']
        }
        /** ReassignmentCommand */
        ReassignmentCommand: {
            command: components['schemas']['Command1']
        }
        /** ReassignmentCommands */
        ReassignmentCommands: {
            /**
             * @description Identifier of the on-ledger workflow that this command is a part of.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Optional
             */
            workflowId: string
            /**
             * @description Uniquely identifies the participant user that issued the command.
             * Must be a valid UserIdString (as described in ``value.proto``).
             * Required unless authentication is used with a user token.
             * In that case, the token's user-id will be used for the request's user_id.
             */
            userId: string
            /**
             * @description Uniquely identifies the command.
             * The triple (user_id, submitter, command_id) constitutes the change ID for the intended ledger change.
             * The change ID can be used for matching the intended ledger changes with all their completions.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            commandId: string
            /**
             * @description Party on whose behalf the command should be executed.
             * If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
             * to act on behalf of the given party.
             * Must be a valid PartyIdString (as described in ``value.proto``).
             * Required
             */
            submitter: string
            /**
             * @description A unique identifier to distinguish completions for different submissions with the same change ID.
             * Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
             * with the same change ID.
             * Must be a valid LedgerString (as described in ``value.proto``).
             *
             * If omitted, the participant or the committer may set a value of their choice.
             * Optional
             */
            submissionId: string
            /** @description Individual elements of this reassignment. Must be non-empty. */
            commands?: components['schemas']['ReassignmentCommand'][]
        }
        /**
         * RevokeUserRightsRequest
         * @description Remove the rights from the set of rights granted to the user.
         *
         * Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
         */
        RevokeUserRightsRequest: {
            /**
             * @description The user from whom to revoke rights.
             * Required
             */
            userId: string
            /**
             * @description The rights to revoke.
             * Optional
             */
            rights?: components['schemas']['Right'][]
            /**
             * @description The id of the ``Identity Provider``
             * Optional, if not set, assume the user is managed by the default identity provider.
             */
            identityProviderId: string
        }
        /** RevokeUserRightsResponse */
        RevokeUserRightsResponse: {
            /** @description The rights that were actually revoked by the request. */
            newlyRevokedRights?: components['schemas']['Right'][]
        }
        /**
         * Right
         * @description A right granted to a user.
         */
        Right: {
            kind: components['schemas']['Kind']
        }
        /** Signature */
        Signature: {
            format: string
            signature: string
            /** @description The fingerprint/id of the keypair used to create this signature and needed to verify. */
            signedBy: string
            /** @description The signing algorithm specification used to produce this signature */
            signingAlgorithmSpec: string
        }
        /**
         * SinglePartySignatures
         * @description Signatures provided by a single party
         */
        SinglePartySignatures: {
            /** @description Submitting party */
            party: string
            /** @description Signatures */
            signatures?: components['schemas']['Signature'][]
        }
        /** Status */
        Status: {
            /** Format: int32 */
            code: number
            message: string
            details?: components['schemas']['ProtoAny'][]
            unknownFields: components['schemas']['UnknownFieldSet']
        }
        /**
         * SubmitAndWaitForReassignmentRequest
         * @description This reassignment is executed as a single atomic update.
         */
        SubmitAndWaitForReassignmentRequest: {
            /**
             * @description The reassignment commands to be submitted.
             * Required
             */
            reassignmentCommands?: components['schemas']['ReassignmentCommands']
            /**
             * @description Optional
             * If no event_format provided, the result will contain no events.
             * The events in the result, will take shape TRANSACTION_SHAPE_ACS_DELTA.
             */
            eventFormat?: components['schemas']['EventFormat']
        }
        /** SubmitAndWaitResponse */
        SubmitAndWaitResponse: {
            /**
             * @description The id of the transaction that resulted from the submitted command.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            updateId: string
            /**
             * Format: int64
             * @description The details of the offset field are described in ``community/ledger-api/README.md``.
             * Required
             */
            completionOffset: number
        }
        /** SubmitReassignmentRequest */
        SubmitReassignmentRequest: {
            /**
             * @description The reassignment command to be submitted.
             * Required
             */
            reassignmentCommands?: components['schemas']['ReassignmentCommands']
        }
        /** SubmitReassignmentResponse */
        SubmitReassignmentResponse: Record<string, never>
        /** SubmitResponse */
        SubmitResponse: Record<string, never>
        /** SynchronizerTime */
        SynchronizerTime: {
            /**
             * @description The id of the synchronizer.
             * Required
             */
            synchronizerId: string
            /**
             * @description All commands with a maximum record time below this value MUST be considered lost if their completion has not arrived before this checkpoint.
             * Required
             */
            recordTime?: string
        }
        /**
         * TemplateFilter
         * @description This filter matches contracts of a specific template.
         */
        TemplateFilter: {
            value: components['schemas']['TemplateFilter1']
        }
        /**
         * TemplateFilter
         * @description This filter matches contracts of a specific template.
         */
        TemplateFilter1: {
            /**
             * @description A template for which the payload should be included in the response.
             * The ``template_id`` needs to be valid: corresponding template should be defined in
             * one of the available packages at the time of the query.
             * Both package-name and package-id reference formats for the identifier are supported.
             * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
             *
             * Required
             */
            templateId?: string
            /**
             * @description Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
             * Use this to access the contract event payload in your API client
             * for submitting it as a disclosed contract with future commands.
             * Optional
             */
            includeCreatedEventBlob: boolean
        }
        /** Time */
        Time: OneOf<
            [
                {
                    Empty: components['schemas']['Empty6']
                },
                {
                    MinLedgerTimeAbs: components['schemas']['MinLedgerTimeAbs']
                },
                {
                    MinLedgerTimeRel: components['schemas']['MinLedgerTimeRel']
                },
            ]
        >
        /** TopologyEvent */
        TopologyEvent: OneOf<
            [
                {
                    ParticipantAuthorizationAdded: components['schemas']['ParticipantAuthorizationAdded']
                },
                {
                    ParticipantAuthorizationChanged: components['schemas']['ParticipantAuthorizationChanged']
                },
                {
                    ParticipantAuthorizationRevoked: components['schemas']['ParticipantAuthorizationRevoked']
                },
            ]
        >
        /**
         * TopologyFormat
         * @description A format specifying which topology transactions to include and how to render them.
         */
        TopologyFormat: {
            /**
             * @description Include participant authorization topology events in streams.
             * Optional, if unset no participant authorization topology events are emitted in the stream.
             */
            includeParticipantAuthorizationEvents?: components['schemas']['ParticipantAuthorizationTopologyFormat']
        }
        /** TopologyTransaction */
        TopologyTransaction: {
            value: components['schemas']['JsTopologyTransaction']
        }
        /** TraceContext */
        TraceContext: {
            /** @description https://www.w3.org/TR/trace-context/ */
            traceparent?: string
            tracestate?: string
        }
        /**
         * Transaction
         * @description Filtered view of an on-ledger transaction's create and archive events.
         */
        Transaction: {
            value: components['schemas']['JsTransaction']
        }
        /**
         * TransactionFilter
         * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
         * Used both for filtering create and archive events as well as for filtering transaction trees.
         */
        TransactionFilter: {
            /**
             * @description Each key must be a valid PartyIdString (as described in ``value.proto``).
             * The interpretation of the filter depends on the transaction-shape being filtered:
             *
             * 1. For **transaction trees** (used in GetUpdateTreesResponse for backwards compatibility) all party keys used as
             *    wildcard filters, and all subtrees whose root has one of the listed parties as an informee are returned.
             *    If there are ``CumulativeFilter``s, those will control returned ``CreatedEvent`` fields where applicable, but will
             *    not be used for template/interface filtering.
             * 2. For **ledger-effects** create and exercise events are returned, for which the witnesses include at least one of
             *    the listed parties and match the per-party filter.
             * 3. For **transaction and active-contract-set streams** create and archive events are returned for all contracts whose
             *    stakeholders include at least one of the listed parties and match the per-party filter.
             *
             * Required
             */
            filtersByParty: components['schemas']['Map_Filters']
            /**
             * @description Wildcard filters that apply to all the parties existing on the participant. The interpretation of the filters is the same
             * with the per-party filter as described above.
             */
            filtersForAnyParty?: components['schemas']['Filters']
        }
        /**
         * TransactionFormat
         * @description A format that specifies what events to include in Daml transactions
         * and what data to compute and include for them.
         */
        TransactionFormat: {
            /** @description Required */
            eventFormat?: components['schemas']['EventFormat']
            /**
             * @description What transaction shape to use for interpreting the filters of the event format.
             * Required
             */
            transactionShape: string
        }
        /**
         * TransactionTree
         * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
         * Complete view of an on-ledger transaction.
         */
        TransactionTree: {
            value: components['schemas']['JsTransactionTree']
        }
        /**
         * TreeEvent
         * @description Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
         * Each tree event message type below contains a ``witness_parties`` field which
         * indicates the subset of the requested parties that can see the event
         * in question.
         *
         * Note that transaction trees might contain events with
         * _no_ witness parties, which were included simply because they were
         * children of events which have witnesses.
         */
        TreeEvent: OneOf<
            [
                {
                    CreatedTreeEvent: components['schemas']['CreatedTreeEvent']
                },
                {
                    ExercisedTreeEvent: components['schemas']['ExercisedTreeEvent']
                },
            ]
        >
        /** Tuple2_String_String */
        Tuple2_String_String: string[]
        /**
         * UnassignCommand
         * @description Unassign a contract
         */
        UnassignCommand: {
            value: components['schemas']['UnassignCommand1']
        }
        /**
         * UnassignCommand
         * @description Unassign a contract
         */
        UnassignCommand1: {
            /**
             * @description The ID of the contract the client wants to unassign.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            contractId: string
            /**
             * @description The ID of the source synchronizer
             * Must be a valid synchronizer id
             * Required
             */
            source: string
            /**
             * @description The ID of the target synchronizer
             * Must be a valid synchronizer id
             * Required
             */
            target: string
        }
        /**
         * UnassignedEvent
         * @description Records that a contract has been unassigned, and it becomes unusable on the source synchronizer
         */
        UnassignedEvent: {
            /**
             * @description The ID of the unassignment. This needs to be used as an input for a assign ReassignmentCommand.
             * For one contract the (unassign_id, source synchronizer) pair is unique.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            unassignId: string
            /**
             * @description The ID of the reassigned contract.
             * Must be a valid LedgerString (as described in ``value.proto``).
             * Required
             */
            contractId: string
            /**
             * @description The template of the reassigned contract.
             * The identifier uses the package-id reference format.
             *
             * Required
             */
            templateId?: string
            /**
             * @description The ID of the source synchronizer
             * Must be a valid synchronizer id
             * Required
             */
            source: string
            /**
             * @description The ID of the target synchronizer
             * Must be a valid synchronizer id
             * Required
             */
            target: string
            /**
             * @description Party on whose behalf the unassign command was executed.
             * Empty if the unassignment happened offline via the repair service.
             * Must be a valid PartyIdString (as described in ``value.proto``).
             * Optional
             */
            submitter: string
            /**
             * Format: int64
             * @description Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
             * with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
             * equals zero.
             * Required
             */
            reassignmentCounter: number
            /**
             * @description Assignment exclusivity
             * Before this time (measured on the target synchronizer), only the submitter of the unassignment can initiate the assignment
             * Defined for reassigning participants.
             * Optional
             */
            assignmentExclusivity?: string
            /**
             * @description The parties that are notified of this event.
             * Required
             */
            witnessParties?: string[]
            /**
             * @description The package name of the contract.
             * Required
             */
            packageName: string
            /**
             * Format: int64
             * @description The offset of origin.
             * Offsets are managed by the participant nodes.
             * Reassignments can thus NOT be assumed to have the same offsets on different participant nodes.
             * Required, it is a valid absolute offset (positive integer)
             */
            offset: number
            /**
             * Format: int32
             * @description The position of this event in the originating reassignment.
             * Node IDs are not necessarily equal across participants,
             * as these may see different projections/parts of reassignments.
             * Required, must be valid node ID (non-negative integer)
             */
            nodeId: number
        }
        /** UnknownFieldSet */
        UnknownFieldSet: {
            fields: components['schemas']['Map_Int_Field']
        }
        /** Update */
        Update: OneOf<
            [
                {
                    OffsetCheckpoint: components['schemas']['OffsetCheckpoint2']
                },
                {
                    Reassignment: components['schemas']['Reassignment']
                },
                {
                    TopologyTransaction: components['schemas']['TopologyTransaction']
                },
                {
                    Transaction: components['schemas']['Transaction']
                },
            ]
        >
        /**
         * Update
         * @description The update that matches the filter in the request.
         */
        Update1: OneOf<
            [
                {
                    OffsetCheckpoint: components['schemas']['OffsetCheckpoint3']
                },
                {
                    Reassignment: components['schemas']['Reassignment1']
                },
                {
                    TransactionTree: components['schemas']['TransactionTree']
                },
            ]
        >
        /**
         * UpdateFormat
         * @description A format specifying what updates to include and how to render them.
         */
        UpdateFormat: {
            /**
             * @description Include Daml transactions in streams.
             * Optional, if unset, no transactions are emitted in the stream.
             */
            includeTransactions?: components['schemas']['TransactionFormat']
            /**
             * @description Include (un)assignments in the stream.
             * The events in the result take the shape TRANSACTION_SHAPE_ACS_DELTA.
             * Optional, if unset, no (un)assignments are emitted in the stream.
             */
            includeReassignments?: components['schemas']['EventFormat']
            /**
             * @description Include topology events in streams.
             * Optional, if unset no topology events are emitted in the stream.
             */
            includeTopologyEvents?: components['schemas']['TopologyFormat']
        }
        /** UpdateIdentityProviderConfigRequest */
        UpdateIdentityProviderConfigRequest: {
            /**
             * @description The identity provider config to update.
             * Required,
             * Modifiable
             */
            identityProviderConfig?: components['schemas']['IdentityProviderConfig']
            /**
             * @description An update mask specifies how and which properties of the ``IdentityProviderConfig`` message are to be updated.
             * An update mask consists of a set of update paths.
             * A valid update path points to a field or a subfield relative to the ``IdentityProviderConfig`` message.
             * A valid update mask must:
             *
             * 1. contain at least one update path,
             * 2. contain only valid update paths.
             *
             * Fields that can be updated are marked as ``Modifiable``.
             * For additional information see the documentation for standard protobuf3's ``google.protobuf.FieldMask``.
             * Required
             */
            updateMask?: components['schemas']['FieldMask']
        }
        /** UpdateIdentityProviderConfigResponse */
        UpdateIdentityProviderConfigResponse: {
            /** @description Updated identity provider config */
            identityProviderConfig?: components['schemas']['IdentityProviderConfig']
        }
        /**
         * UpdatePartyDetailsRequest
         * @description Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(party_details.identity_provider_id)``
         */
        UpdatePartyDetailsRequest: {
            /**
             * @description Party to be updated
             * Required,
             * Modifiable
             */
            partyDetails?: components['schemas']['PartyDetails']
            /**
             * @description An update mask specifies how and which properties of the ``PartyDetails`` message are to be updated.
             * An update mask consists of a set of update paths.
             * A valid update path points to a field or a subfield relative to the ``PartyDetails`` message.
             * A valid update mask must:
             *
             * 1. contain at least one update path,
             * 2. contain only valid update paths.
             *
             * Fields that can be updated are marked as ``Modifiable``.
             * An update path can also point to non-``Modifiable`` fields such as 'party' and 'local_metadata.resource_version'
             * because they are used:
             *
             * 1. to identify the party details resource subject to the update,
             * 2. for concurrent change control.
             *
             * An update path can also point to non-``Modifiable`` fields such as 'is_local'
             * as long as the values provided in the update request match the server values.
             * Examples of update paths: 'local_metadata.annotations', 'local_metadata'.
             * For additional information see the documentation for standard protobuf3's ``google.protobuf.FieldMask``.
             * For similar Ledger API see ``com.daml.ledger.api.v2.admin.UpdateUserRequest``.
             * Required
             */
            updateMask?: components['schemas']['FieldMask']
        }
        /** UpdatePartyDetailsResponse */
        UpdatePartyDetailsResponse: {
            /** @description Updated party details */
            partyDetails?: components['schemas']['PartyDetails']
        }
        /**
         * UpdateUserIdentityProviderIdRequest
         * @description Required authorization: ``HasRight(ParticipantAdmin)``
         */
        UpdateUserIdentityProviderIdRequest: {
            /** @description User to update */
            userId: string
            /** @description Current identity provider ID of the user */
            sourceIdentityProviderId: string
            /** @description Target identity provider ID of the user */
            targetIdentityProviderId: string
        }
        /** UpdateUserIdentityProviderIdResponse */
        UpdateUserIdentityProviderIdResponse: Record<string, never>
        /**
         * UpdateUserRequest
         * @description Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(user.identity_provider_id)``
         */
        UpdateUserRequest: {
            /**
             * @description The user to update.
             * Required,
             * Modifiable
             */
            user?: components['schemas']['User']
            /**
             * @description An update mask specifies how and which properties of the ``User`` message are to be updated.
             * An update mask consists of a set of update paths.
             * A valid update path points to a field or a subfield relative to the ``User`` message.
             * A valid update mask must:
             *
             * 1. contain at least one update path,
             * 2. contain only valid update paths.
             *
             * Fields that can be updated are marked as ``Modifiable``.
             * An update path can also point to a non-``Modifiable`` fields such as 'id' and 'metadata.resource_version'
             * because they are used:
             *
             * 1. to identify the user resource subject to the update,
             * 2. for concurrent change control.
             *
             * Examples of valid update paths: 'primary_party', 'metadata', 'metadata.annotations'.
             * For additional information see the documentation for standard protobuf3's ``google.protobuf.FieldMask``.
             * For similar Ledger API see ``com.daml.ledger.api.v2.admin.UpdatePartyDetailsRequest``.
             * Required
             */
            updateMask?: components['schemas']['FieldMask']
        }
        /** UpdateUserResponse */
        UpdateUserResponse: {
            /** @description Updated user */
            user?: components['schemas']['User']
        }
        /**
         * UploadDarFileResponse
         * @description A message that is received when the upload operation succeeded.
         */
        UploadDarFileResponse: Record<string, never>
        /**
         * User
         * @description  Users and rights
         * /////////////////
         *  Users are used to dynamically manage the rights given to Daml applications.
         *  They are stored and managed per participant node.
         */
        User: {
            /**
             * @description The user identifier, which must be a non-empty string of at most 128
             * characters that are either alphanumeric ASCII characters or one of the symbols "@^$.!`-#+'~_|:".
             * Required
             */
            id: string
            /**
             * @description The primary party as which this user reads and acts by default on the ledger
             * *provided* it has the corresponding ``CanReadAs(primary_party)`` or
             * ``CanActAs(primary_party)`` rights.
             * Ledger API clients SHOULD set this field to a non-empty value for all users to
             * enable the users to act on the ledger using their own Daml party.
             * Users for participant administrators MAY have an associated primary party.
             * Optional,
             * Modifiable
             */
            primaryParty: string
            /**
             * @description When set, then the user is denied all access to the Ledger API.
             * Otherwise, the user has access to the Ledger API as per the user's rights.
             * Optional,
             * Modifiable
             */
            isDeactivated: boolean
            /**
             * @description The metadata of this user.
             * Note that the ``metadata.resource_version`` tracks changes to the properties described by the ``User`` message and not the user's rights.
             * Optional,
             * Modifiable
             */
            metadata?: components['schemas']['ObjectMeta']
            /**
             * @description The ID of the identity provider configured by ``Identity Provider Config``
             * Optional, if not set, assume the user is managed by the default identity provider.
             */
            identityProviderId: string
        }
        /** UserManagementFeature */
        UserManagementFeature: {
            /** @description Whether the Ledger API server provides the user management service. */
            supported: boolean
            /**
             * Format: int32
             * @description The maximum number of rights that can be assigned to a single user.
             * Servers MUST support at least 100 rights per user.
             * A value of 0 means that the server enforces no rights per user limit.
             */
            maxRightsPerUser: number
            /**
             * Format: int32
             * @description The maximum number of users the server can return in a single response (page).
             * Servers MUST support at least a 100 users per page.
             * A value of 0 means that the server enforces no page size limit.
             */
            maxUsersPageSize: number
        }
        /**
         * WildcardFilter
         * @description This filter matches all templates.
         */
        WildcardFilter: {
            value: components['schemas']['WildcardFilter1']
        }
        /**
         * WildcardFilter
         * @description This filter matches all templates.
         */
        WildcardFilter1: {
            /**
             * @description Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
             * Use this to access the contract create event payload in your API client
             * for submitting it as a disclosed contract with future commands.
             * Optional
             */
            includeCreatedEventBlob: boolean
        }
    }
    responses: never
    parameters: never
    requestBodies: never
    headers: never
    pathItems: never
}

export type $defs = Record<string, never>

export type external = Record<string, never>

export interface operations {
    /** @description Submit a batch of commands and wait for the completion details */
    'postV2CommandsSubmit-and-wait': {
        requestBody: {
            content: {
                'application/json': components['schemas']['JsCommands']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['SubmitAndWaitResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Submit a batch of commands and wait for the transaction response */
    'postV2CommandsSubmit-and-wait-for-transaction': {
        requestBody: {
            content: {
                'application/json': components['schemas']['JsSubmitAndWaitForTransactionRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['JsSubmitAndWaitForTransactionResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Submit a batch of reassignment commands and wait for the reassignment response */
    'postV2CommandsSubmit-and-wait-for-reassignment': {
        requestBody: {
            content: {
                'application/json': components['schemas']['SubmitAndWaitForReassignmentRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['JsSubmitAndWaitForReassignmentResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Submit a batch of commands and wait for the transaction trees response */
    'postV2CommandsSubmit-and-wait-for-transaction-tree': {
        requestBody: {
            content: {
                'application/json': components['schemas']['JsCommands']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['JsSubmitAndWaitForTransactionTreeResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Submit a command asynchronously */
    postV2CommandsAsyncSubmit: {
        requestBody: {
            content: {
                'application/json': components['schemas']['JsCommands']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['SubmitResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Submit reassignment command asynchronously */
    'postV2CommandsAsyncSubmit-reassignment': {
        requestBody: {
            content: {
                'application/json': components['schemas']['SubmitReassignmentRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['SubmitReassignmentResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Query completions list (blocking call) */
    postV2CommandsCompletions: {
        parameters: {
            query?: {
                /** @description maximum number of elements to return, this param is ignored if is bigger than server setting */
                limit?: number
                /** @description timeout to complete and send result if no new elements are received (for open ended streams) */
                stream_idle_timeout_ms?: number
            }
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['CompletionStreamRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['CompletionStreamResponse'][]
                }
            }
            /** @description Invalid value for: body, Invalid value for: query parameter limit, Invalid value for: query parameter stream_idle_timeout_ms, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get events by contract Id */
    'postV2EventsEvents-by-contract-id': {
        requestBody: {
            content: {
                'application/json': components['schemas']['GetEventsByContractIdRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['JsGetEventsByContractIdResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get the version details of the participant node */
    getV2Version: {
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['GetLedgerApiVersionResponse']
                }
            }
            /** @description Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description List all packages uploaded on the participant node */
    getV2Packages: {
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['ListPackagesResponse']
                }
            }
            /** @description Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Upload a DAR to the participant node */
    postV2Packages: {
        requestBody: {
            content: {
                'application/octet-stream': string
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['UploadDarFileResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Download the package for the requested package-id */
    'getV2PackagesPackage-id': {
        parameters: {
            path: {
                'package-id': string
            }
        }
        responses: {
            200: {
                headers: {
                    'Canton-Package-Hash': string
                }
                content: {
                    'application/octet-stream': string
                }
            }
            /** @description Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get package status */
    'getV2PackagesPackage-idStatus': {
        parameters: {
            path: {
                'package-id': string
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['GetPackageStatusResponse']
                }
            }
            /** @description Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description List all known parties. */
    getV2Parties: {
        parameters: {
            query?: {
                /** @description maximum number of elements in a returned page */
                pageSize?: number
                /** @description token - to continue results from a given page, leave empty to start from the beginning of the list, obtain token from the result of previous page */
                pageToken?: string
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['ListKnownPartiesResponse']
                }
            }
            /** @description Invalid value for: query parameter pageSize, Invalid value for: query parameter pageToken, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Allocate a new party to the participant node */
    postV2Parties: {
        requestBody: {
            content: {
                'application/json': components['schemas']['AllocatePartyRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['AllocatePartyResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get participant id */
    'getV2PartiesParticipant-id': {
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['GetParticipantIdResponse']
                }
            }
            /** @description Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get party details */
    getV2PartiesParty: {
        parameters: {
            query?: {
                'identity-provider-id'?: string
                parties?: string[]
            }
            path: {
                party: string
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['GetPartiesResponse']
                }
            }
            /** @description Invalid value for: query parameter identity-provider-id, Invalid value for: query parameter parties, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Allocate a new party to the participant node */
    patchV2PartiesParty: {
        parameters: {
            path: {
                party: string
            }
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdatePartyDetailsRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['UpdatePartyDetailsResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Query active contracts list (blocking call) */
    'postV2StateActive-contracts': {
        parameters: {
            query?: {
                /** @description maximum number of elements to return, this param is ignored if is bigger than server setting */
                limit?: number
                /** @description timeout to complete and send result if no new elements are received (for open ended streams) */
                stream_idle_timeout_ms?: number
            }
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['GetActiveContractsRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['JsGetActiveContractsResponse'][]
                }
            }
            /** @description Invalid value for: body, Invalid value for: query parameter limit, Invalid value for: query parameter stream_idle_timeout_ms, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get connected synchronizers */
    'getV2StateConnected-synchronizers': {
        parameters: {
            query: {
                party: string
                participantId?: string
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['GetConnectedSynchronizersResponse']
                }
            }
            /** @description Invalid value for: query parameter party, Invalid value for: query parameter participantId, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get ledger end */
    'getV2StateLedger-end': {
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['GetLedgerEndResponse']
                }
            }
            /** @description Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get latest pruned offsets */
    'getV2StateLatest-pruned-offsets': {
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['GetLatestPrunedOffsetsResponse']
                }
            }
            /** @description Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Query flat transactions update list (blocking call) */
    postV2UpdatesFlats: {
        parameters: {
            query?: {
                /** @description maximum number of elements to return, this param is ignored if is bigger than server setting */
                limit?: number
                /** @description timeout to complete and send result if no new elements are received (for open ended streams) */
                stream_idle_timeout_ms?: number
            }
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['GetUpdatesRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['JsGetUpdatesResponse'][]
                }
            }
            /** @description Invalid value for: body, Invalid value for: query parameter limit, Invalid value for: query parameter stream_idle_timeout_ms, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Query update transactions tree list (blocking call) */
    postV2UpdatesTrees: {
        parameters: {
            query?: {
                /** @description maximum number of elements to return, this param is ignored if is bigger than server setting */
                limit?: number
                /** @description timeout to complete and send result if no new elements are received (for open ended streams) */
                stream_idle_timeout_ms?: number
            }
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['GetUpdatesRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['JsGetUpdateTreesResponse'][]
                }
            }
            /** @description Invalid value for: body, Invalid value for: query parameter limit, Invalid value for: query parameter stream_idle_timeout_ms, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get transaction tree by offset */
    'getV2UpdatesTransaction-tree-by-offsetOffset': {
        parameters: {
            query?: {
                parties?: string[]
            }
            path: {
                offset: number
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['JsGetTransactionTreeResponse']
                }
            }
            /** @description Invalid value for: path parameter offset, Invalid value for: query parameter parties, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get transaction by offset */
    'postV2UpdatesTransaction-by-offset': {
        requestBody: {
            content: {
                'application/json': components['schemas']['GetTransactionByOffsetRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['JsGetTransactionResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get update by offset */
    'postV2UpdatesUpdate-by-offset': {
        requestBody: {
            content: {
                'application/json': components['schemas']['GetUpdateByOffsetRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['JsGetUpdateResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get transaction by id */
    'postV2UpdatesTransaction-by-id': {
        requestBody: {
            content: {
                'application/json': components['schemas']['GetTransactionByIdRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['JsGetTransactionResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get update by id */
    'postV2UpdatesUpdate-by-id': {
        requestBody: {
            content: {
                'application/json': components['schemas']['GetUpdateByIdRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['JsGetUpdateResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get transaction tree by  id */
    'getV2UpdatesTransaction-tree-by-idUpdate-id': {
        parameters: {
            query?: {
                parties?: string[]
            }
            path: {
                'update-id': string
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['JsGetTransactionTreeResponse']
                }
            }
            /** @description Invalid value for: query parameter parties, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description List all users. */
    getV2Users: {
        parameters: {
            query?: {
                /** @description maximum number of elements in a returned page */
                pageSize?: number
                /** @description token - to continue results from a given page, leave empty to start from the beginning of the list, obtain token from the result of previous page */
                pageToken?: string
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['ListUsersResponse']
                }
            }
            /** @description Invalid value for: query parameter pageSize, Invalid value for: query parameter pageToken, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Create user. */
    postV2Users: {
        requestBody: {
            content: {
                'application/json': components['schemas']['CreateUserRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['CreateUserResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get user details. */
    'getV2UsersUser-id': {
        parameters: {
            path: {
                'user-id': string
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['GetUserResponse']
                }
            }
            /** @description Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Delete user. */
    'deleteV2UsersUser-id': {
        parameters: {
            path: {
                'user-id': string
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': Record<string, never>
                }
            }
            /** @description Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Update  user. */
    'patchV2UsersUser-id': {
        parameters: {
            path: {
                'user-id': string
            }
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateUserRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['UpdateUserResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description List user rights. */
    'getV2UsersUser-idRights': {
        parameters: {
            path: {
                'user-id': string
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['ListUserRightsResponse']
                }
            }
            /** @description Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Grant user rights. */
    'postV2UsersUser-idRights': {
        parameters: {
            path: {
                'user-id': string
            }
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['GrantUserRightsRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['GrantUserRightsResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Revoke user rights. */
    'patchV2UsersUser-idRights': {
        parameters: {
            path: {
                'user-id': string
            }
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['RevokeUserRightsRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['RevokeUserRightsResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Update user identity provider. */
    'patchV2UsersUser-idIdentity-provider-id': {
        parameters: {
            path: {
                'user-id': string
            }
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateUserIdentityProviderIdRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['UpdateUserIdentityProviderIdResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description List all identity provider configs */
    getV2Idps: {
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['ListIdentityProviderConfigsResponse']
                }
            }
            /** @description Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Create identity provider configs */
    postV2Idps: {
        requestBody: {
            content: {
                'application/json': components['schemas']['CreateIdentityProviderConfigRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['CreateIdentityProviderConfigResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get identity provider config */
    'getV2IdpsIdp-id': {
        parameters: {
            path: {
                'idp-id': string
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['GetIdentityProviderConfigResponse']
                }
            }
            /** @description Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Delete identity provider config */
    'deleteV2IdpsIdp-id': {
        parameters: {
            path: {
                'idp-id': string
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['DeleteIdentityProviderConfigResponse']
                }
            }
            /** @description Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Update identity provider config */
    'patchV2IdpsIdp-id': {
        parameters: {
            path: {
                'idp-id': string
            }
        }
        requestBody: {
            content: {
                'application/json': components['schemas']['UpdateIdentityProviderConfigRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['UpdateIdentityProviderConfigResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Prepare commands for signing */
    'postV2Interactive-submissionPrepare': {
        requestBody: {
            content: {
                'application/json': components['schemas']['JsPrepareSubmissionRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['JsPrepareSubmissionResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Execute a signed transaction */
    'postV2Interactive-submissionExecute': {
        requestBody: {
            content: {
                'application/json': components['schemas']['JsExecuteSubmissionRequest']
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['ExecuteSubmissionResponse']
                }
            }
            /** @description Invalid value for: body, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
    /** @description Get the preferred package version for constructing a command submission */
    'getV2Interactive-submissionPreferred-package-version': {
        parameters: {
            query: {
                parties?: string[]
                'package-name': string
                vetting_valid_at?: string
                'synchronizer-id'?: string
            }
        }
        responses: {
            200: {
                content: {
                    'application/json': components['schemas']['GetPreferredPackageVersionResponse']
                }
            }
            /** @description Invalid value for: query parameter parties, Invalid value for: query parameter package-name, Invalid value for: query parameter vetting_valid_at, Invalid value for: query parameter synchronizer-id, Invalid value for: headers */
            400: {
                content: {
                    'text/plain': string
                }
            }
            default: {
                content: {
                    'application/json': components['schemas']['JsCantonError']
                }
            }
        }
    }
}
