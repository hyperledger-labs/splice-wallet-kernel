// Code generated by @open-rpc/generator DO NOT EDIT.
import {
    RequestManager,
    PostMessageWindowTransport,
    PostMessageIframeTransport,
    WebSocketTransport,
    HTTPTransport,
    Client,
    JSONRPCError,
} from '@open-rpc/client-js'
import _ from 'lodash'
import { OpenrpcDocument as OpenRPC, MethodObject } from '@open-rpc/meta-schema'
import {
    MethodCallValidator,
    MethodNotFoundError,
    parseOpenRPCDocument,
} from '@open-rpc/schema-utils-js'

export type StringDoaGddGA = string
/**
 *
 * Structure representing JS commands for transaction execution
 *
 */
export interface JsCommands {
    [key: string]: any
}
export type StringMo3KZIJp = 'GET' | 'POST' | 'PUT' | 'DELETE'
/**
 *
 * CAIP-2 compliant chain ID, e.g. 'canton:da-mainnet'
 *
 */
export type StringYkM1EZ9K = string
export type UnorderedSetOfStringDoaGddGADvj0XlFa = StringDoaGddGA[]
export interface AddNetworkParams {
    [key: string]: any
}
export interface AllocatePartyParams {
    hint: StringDoaGddGA
    [k: string]: any
}
export interface RemovePartyParams {
    hint: StringDoaGddGA
    [k: string]: any
}
export interface SignParams {
    data: StringDoaGddGA
    party?: StringDoaGddGA
    [k: string]: any
}
export interface PrepareReturnParams {
    commands: JsCommands
    [k: string]: any
}
export interface PrepareExecuteParams {
    commands: JsCommands
    [k: string]: any
}
export interface LedgerApiParams {
    requestMethod: StringMo3KZIJp
    resource: StringDoaGddGA
    body?: StringDoaGddGA
    [k: string]: any
}
export interface ConnectResponse {
    chainId: StringYkM1EZ9K
    [k: string]: any
}
/**
 *
 * A response that contains no data.
 *
 */
export type Null = null
export interface AllocatePartyResponse {
    [key: string]: any
}
export interface RemovePartyResponse {
    [key: string]: any
}
export interface SignResponse {
    signature: StringDoaGddGA
    party: StringDoaGddGA
    signedBy: StringDoaGddGA
    [k: string]: any
}
/**
 *
 * Structure representing the result of a prepareReturn call
 *
 */
export interface JsPrepareSubmissionResponse {
    [key: string]: any
}
export interface LedgerApiResponse {
    response: StringDoaGddGA
    [k: string]: any
}
export interface DarsAvailableResponse {
    dars: UnorderedSetOfStringDoaGddGADvj0XlFa
    [k: string]: any
}
/**
 *
 * Generated! Represents an alias to any of the provided schemas
 *
 */
export type AnyOfAddNetworkParamsAllocatePartyParamsRemovePartyParamsSignParamsPrepareReturnParamsPrepareExecuteParamsLedgerApiParamsConnectResponseNullAllocatePartyResponseRemovePartyResponseSignResponseJsPrepareSubmissionResponseNullLedgerApiResponseDarsAvailableResponse =

        | AddNetworkParams
        | AllocatePartyParams
        | RemovePartyParams
        | SignParams
        | PrepareReturnParams
        | PrepareExecuteParams
        | LedgerApiParams
        | ConnectResponse
        | Null
        | AllocatePartyResponse
        | RemovePartyResponse
        | SignResponse
        | JsPrepareSubmissionResponse
        | LedgerApiResponse
        | DarsAvailableResponse
export type Connect = () => Promise<ConnectResponse>
export type AddNetwork = (network: AddNetworkParams) => Promise<Null>
export type AllocateParty = (
    params: AllocatePartyParams
) => Promise<AllocatePartyResponse>
export type RemoveParty = (
    params: RemovePartyParams
) => Promise<RemovePartyResponse>
export type Sign = (params: SignParams) => Promise<SignResponse>
export type PrepareReturn = (
    params: PrepareReturnParams
) => Promise<JsPrepareSubmissionResponse>
export type PrepareExecute = (params: PrepareExecuteParams) => Promise<Null>
export type LedgerApi = (params: LedgerApiParams) => Promise<LedgerApiResponse>
export type DarsAvailable = () => Promise<DarsAvailableResponse>

export interface Options {
    transport: {
        type:
            | 'websocket'
            | 'http'
            | 'https'
            | 'postmessagewindow'
            | 'postmessageiframe'
        host: string
        port: number
        path?: string
        protocol?: string
    }
}

export class CantonJSONRPCWalletAPI {
    public rpc: Client
    public static openrpcDocument: OpenRPC = {
        openrpc: '1.2.6',
        info: {
            title: 'Canton JSON-RPC Wallet API',
            version: '1.0.0',
            description:
                'An OpenRPC specification for interacting with a Canton wallet over JSON-RPC.',
        },
        methods: [
            {
                name: 'connect',
                params: [],
                result: {
                    name: 'result',
                    schema: {
                        title: 'ConnectResponse',
                        type: 'object',
                        properties: {
                            chainId: {
                                type: 'string',
                                description:
                                    "CAIP-2 compliant chain ID, e.g. 'canton:da-mainnet'",
                            },
                        },
                        required: ['chainId'],
                    },
                },
                description:
                    'Ensures ledger connectivity. Returns the current chainId.',
            },
            {
                name: 'addNetwork',
                params: [
                    {
                        name: 'network',
                        schema: { title: 'AddNetworkParams', type: 'object' },
                    },
                ],
                result: {
                    name: 'result',
                    schema: { $ref: '#/components/schemas/Null' },
                },
                description:
                    'Adds a new network configuration (similar to EIP-3085).',
            },
            {
                name: 'allocateParty',
                params: [
                    {
                        name: 'params',
                        schema: {
                            title: 'AllocatePartyParams',
                            type: 'object',
                            properties: { hint: { type: 'string' } },
                            required: ['hint'],
                        },
                    },
                ],
                result: {
                    name: 'result',
                    schema: { title: 'AllocatePartyResponse', type: 'object' },
                },
                description: 'Allocates a new party with the given hint.',
            },
            {
                name: 'removeParty',
                params: [
                    {
                        name: 'params',
                        schema: {
                            title: 'RemovePartyParams',
                            type: 'object',
                            properties: { hint: { type: 'string' } },
                            required: ['hint'],
                        },
                    },
                ],
                result: {
                    name: 'result',
                    schema: { title: 'RemovePartyResponse', type: 'object' },
                },
                description: 'Removes a party with the given hint.',
            },
            {
                name: 'sign',
                params: [
                    {
                        name: 'params',
                        schema: {
                            title: 'SignParams',
                            type: 'object',
                            properties: {
                                data: { type: 'string' },
                                party: { type: 'string' },
                            },
                            required: ['data'],
                        },
                    },
                ],
                result: {
                    name: 'result',
                    schema: {
                        title: 'SignResponse',
                        type: 'object',
                        properties: {
                            signature: { type: 'string' },
                            party: { type: 'string' },
                            signedBy: { type: 'string' },
                        },
                        required: ['signature', 'party', 'signedBy'],
                    },
                },
                description:
                    'Signs the provided data with the private key of the specified or active party.',
            },
            {
                name: 'prepareReturn',
                params: [
                    {
                        name: 'params',
                        schema: {
                            title: 'PrepareReturnParams',
                            type: 'object',
                            properties: {
                                commands: {
                                    $ref: '#/components/schemas/JsCommands',
                                },
                            },
                            required: ['commands'],
                        },
                    },
                ],
                result: {
                    name: 'result',
                    schema: {
                        $ref: '#/components/schemas/JsPrepareSubmissionResponse',
                    },
                },
                description:
                    'Processes the prepare step and returns submission data.',
            },
            {
                name: 'prepareExecute',
                params: [
                    {
                        name: 'params',
                        schema: {
                            title: 'PrepareExecuteParams',
                            type: 'object',
                            properties: {
                                commands: {
                                    $ref: '#/components/schemas/JsCommands',
                                },
                            },
                            required: ['commands'],
                        },
                    },
                ],
                result: {
                    name: 'result',
                    schema: { $ref: '#/components/schemas/Null' },
                },
                description: 'Prepares, signs, and executes a transaction.',
            },
            {
                name: 'ledgerApi',
                params: [
                    {
                        name: 'params',
                        schema: {
                            title: 'LedgerApiParams',
                            type: 'object',
                            properties: {
                                requestMethod: {
                                    type: 'string',
                                    enum: ['GET', 'POST', 'PUT', 'DELETE'],
                                },
                                resource: { type: 'string' },
                                body: { type: 'string' },
                            },
                            required: ['requestMethod', 'resource'],
                        },
                    },
                ],
                result: {
                    name: 'result',
                    schema: {
                        title: 'LedgerApiResponse',
                        type: 'object',
                        properties: { response: { type: 'string' } },
                        required: ['response'],
                    },
                },
                description:
                    'Proxy for the JSON-API endpoints. Injects authorization headers automatically.',
            },
            {
                name: 'darsAvailable',
                params: [],
                result: {
                    name: 'result',
                    schema: {
                        title: 'DarsAvailableResponse',
                        type: 'object',
                        properties: {
                            dars: { type: 'array', items: { type: 'string' } },
                        },
                        required: ['dars'],
                    },
                },
                description:
                    'Lists DARs currently available on the connected Canton node.',
            },
        ],
        components: {
            schemas: {
                Null: {
                    title: 'Null',
                    type: 'null',
                    description: 'A response that contains no data.',
                },
                JsCommands: {
                    title: 'JsCommands',
                    type: 'object',
                    description:
                        'Structure representing JS commands for transaction execution',
                },
                JsPrepareSubmissionResponse: {
                    title: 'JsPrepareSubmissionResponse',
                    type: 'object',
                    description:
                        'Structure representing the result of a prepareReturn call',
                },
            },
        },
    }
    public dereffedDocument: OpenRPC | undefined
    public transport:
        | HTTPTransport
        | WebSocketTransport
        | PostMessageWindowTransport
        | PostMessageIframeTransport
    private validator: MethodCallValidator | undefined
    private timeout: number | undefined

    constructor(options: Options) {
        if (
            options.transport === undefined ||
            options.transport.type === undefined
        ) {
            throw new Error('Invalid constructor params')
        }
        const { type, host, port, protocol } = options.transport
        let path = options.transport.path || ''
        if (path && path[0] !== '/') {
            path = '/' + path
        }
        switch (type) {
            case 'http':
            case 'https':
                this.transport = new HTTPTransport(
                    (protocol || type) + '://' + host + ':' + port + path
                )
                break
            case 'websocket':
                this.transport = new WebSocketTransport(
                    (protocol || 'ws://') + host + ':' + port + path
                )
                break
            case 'postmessageiframe':
                this.transport = new PostMessageIframeTransport(
                    protocol + '://' + host + ':' + port + path
                )
                break
            case 'postmessagewindow':
                this.transport = new PostMessageWindowTransport(
                    protocol + '://' + host + ':' + port + path
                )
                break
            default:
                throw new Error('unsupported transport')
        }
        this.rpc = new Client(new RequestManager([this.transport]))
    }

    /**
     * Adds a JSONRPC notification handler to handle receiving notifications.
     * @example
     * myClient.onNotification((data)=>console.log(data));
     */
    private async initialize() {
        if (this.validator) {
            return
        }
        this.dereffedDocument = await parseOpenRPCDocument(
            CantonJSONRPCWalletAPI.openrpcDocument
        )
        this.validator = new MethodCallValidator(this.dereffedDocument)
    }

    /**
     * Adds a JSONRPC notification handler to handle receiving notifications.
     * @example
     * myClient.onNotification((data)=>console.log(data));
     */
    public onNotification(callback: (data: any) => void) {
        this.rpc.onNotification(callback)
    }

    /**
     * Adds an optional JSONRPCError handler to handle receiving errors that cannot be resolved to a specific request
     * @example
     * myClient.onError((err: JSONRPCError)=>console.log(err.message));
     */
    public onError(callback: (data: JSONRPCError) => void) {
        this.rpc.onError(callback)
    }

    /**
     * Sets a default timeout in ms for all requests excluding notifications.
     * @example
     * // 20s timeout
     * myClient.setDefaultTimeout(20000);
     * // Removes timeout from request
     * myClient.setDefaultTimeout(undefined);
     */
    public setDefaultTimeout(ms?: number) {
        this.timeout = ms
    }

    /**
     * Initiates [[CantonJSONRPCWalletAPI.startBatch]] in order to build a batch call.
     *
     * Subsequent calls to [[CantonJSONRPCWalletAPI.request]] will be added to the batch.
     * Once [[CantonJSONRPCWalletAPI.stopBatch]] is called, the promises for the [[CantonJSONRPCWalletAPI.request]]
     * will then be resolved.  If there is already a batch in progress this method is a noop.
     *
     * @example
     * myClient.startBatch();
     * myClient.foo().then(() => console.log("foobar"))
     * myClient.bar().then(() => console.log("foobarbaz"))
     * myClient.stopBatch();
     */
    public startBatch(): void {
        return this.rpc.startBatch()
    }

    /**
     * Initiates [[Client.stopBatch]] in order to finalize and send the batch to the underlying transport.
     *
     * stopBatch will send the [[CantonJSONRPCWalletAPI]] calls made since the last [[CantonJSONRPCWalletAPI.startBatch]] call. For
     * that reason, [[CantonJSONRPCWalletAPI.startBatch]] MUST be called before [[CantonJSONRPCWalletAPI.stopBatch]].
     *
     * @example
     * myClient.startBatch();
     * myClient.foo().then(() => console.log("foobar"))
     * myClient.bar().then(() => console.log("foobarbaz"))
     * myClient.stopBatch();
     */
    public stopBatch(): void {
        return this.rpc.stopBatch()
    }

    private async request(methodName: string, params: any[]): Promise<any> {
        await this.initialize()
        if (this.validator === undefined) {
            throw new Error('internal error')
        }
        const methodObject = _.find(
            CantonJSONRPCWalletAPI.openrpcDocument.methods as MethodObject[],
            ({ name }) => name === methodName
        ) as MethodObject
        const notification = methodObject.result ? false : true
        const openRpcMethodValidationErrors = this.validator.validate(
            methodName,
            params
        )
        if (
            openRpcMethodValidationErrors instanceof MethodNotFoundError ||
            openRpcMethodValidationErrors.length > 0
        ) {
            return Promise.reject(openRpcMethodValidationErrors)
        }

        let rpcParams
        if (
            methodObject.paramStructure &&
            methodObject.paramStructure === 'by-name'
        ) {
            rpcParams = _.zipObject(_.map(methodObject.params, 'name'), params)
        } else {
            rpcParams = params
        }
        if (notification) {
            return this.rpc.notify({ method: methodName, params: rpcParams })
        }
        return this.rpc.request(
            { method: methodName, params: rpcParams },
            this.timeout
        )
    }

    /**
     *
     */
    // tslint:disable-next-line:max-line-length
    public connect: Connect = (...params) => {
        return this.request('connect', params)
    }

    /**
     *
     */
    // tslint:disable-next-line:max-line-length
    public addNetwork: AddNetwork = (...params) => {
        return this.request('addNetwork', params)
    }

    /**
     *
     */
    // tslint:disable-next-line:max-line-length
    public allocateParty: AllocateParty = (...params) => {
        return this.request('allocateParty', params)
    }

    /**
     *
     */
    // tslint:disable-next-line:max-line-length
    public removeParty: RemoveParty = (...params) => {
        return this.request('removeParty', params)
    }

    /**
     *
     */
    // tslint:disable-next-line:max-line-length
    public sign: Sign = (...params) => {
        return this.request('sign', params)
    }

    /**
     *
     */
    // tslint:disable-next-line:max-line-length
    public prepareReturn: PrepareReturn = (...params) => {
        return this.request('prepareReturn', params)
    }

    /**
     *
     */
    // tslint:disable-next-line:max-line-length
    public prepareExecute: PrepareExecute = (...params) => {
        return this.request('prepareExecute', params)
    }

    /**
     *
     */
    // tslint:disable-next-line:max-line-length
    public ledgerApi: LedgerApi = (...params) => {
        return this.request('ledgerApi', params)
    }

    /**
     *
     */
    // tslint:disable-next-line:max-line-length
    public darsAvailable: DarsAvailable = (...params) => {
        return this.request('darsAvailable', params)
    }
}
export default CantonJSONRPCWalletAPI
