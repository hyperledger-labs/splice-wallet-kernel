// Code generated by @open-rpc/generator DO NOT EDIT.
import {
    RequestManager,
    PostMessageWindowTransport,
    PostMessageIframeTransport,
    WebSocketTransport,
    HTTPTransport,
    Client,
} from '@open-rpc/client-js'
import _ from 'lodash'
import {
    MethodCallValidator,
    MethodNotFoundError,
    parseOpenRPCDocument,
} from '@open-rpc/schema-utils-js'
export class WalletJSONRPCDAppAPI {
    rpc
    static openrpcDocument = {
        openrpc: '1.2.6',
        info: {
            title: 'Wallet JSON-RPC dApp API',
            version: '1.0.0',
            description:
                'An OpenRPC specification for dApp clients interacting with a wallet kernel over JSON-RPC.',
        },
        methods: [
            {
                name: 'connect',
                params: [],
                result: {
                    name: 'result',
                    schema: {
                        title: 'ConnectResult',
                        type: 'object',
                        properties: {
                            chainId: {
                                type: 'string',
                                description:
                                    "A CAIP-2 compliant chain ID, e.g. 'canton:da-mainnet'.",
                            },
                            userUrl: { $ref: '#/components/schemas/UserUrl' },
                        },
                        required: ['userUrl'],
                    },
                },
                description:
                    'Ensures ledger connectivity. Returns the current chainId if connected, or the user url if disconnected.',
            },
            {
                name: 'darsAvailable',
                params: [],
                result: {
                    name: 'result',
                    schema: {
                        title: 'darsAvailableResult',
                        type: 'object',
                        properties: {
                            dars: { type: 'array', items: { type: 'string' } },
                        },
                        required: ['dars'],
                    },
                },
                description:
                    'Lists DARs currently available on the connected Canton node.',
            },
            {
                name: 'prepareReturn',
                params: [
                    {
                        name: 'params',
                        schema: {
                            title: 'prepareReturnParams',
                            type: 'object',
                            properties: {
                                commands: {
                                    $ref: '#/components/schemas/JsCommands',
                                },
                            },
                            required: ['commands'],
                        },
                    },
                ],
                result: {
                    name: 'result',
                    schema: {
                        title: 'prepareReturnResult',
                        properties: {
                            response: {
                                $ref: '#/components/schemas/JsPrepareSubmissionResponse',
                            },
                        },
                        required: ['response'],
                    },
                },
                description:
                    'Processes the prepare step and returns the data to sign.',
            },
            {
                name: 'prepareExecute',
                params: [
                    {
                        name: 'params',
                        schema: {
                            title: 'prepareExecuteParams',
                            type: 'object',
                            properties: {
                                commands: {
                                    $ref: '#/components/schemas/JsCommands',
                                },
                            },
                            required: ['commands'],
                        },
                    },
                ],
                result: {
                    name: 'result',
                    schema: {
                        title: 'prepareExecuteResult',
                        properties: {
                            userUrl: { $ref: '#/components/schemas/UserUrl' },
                        },
                        required: ['userUrl'],
                    },
                },
                description: 'Prepares, signs, and executes a transaction.',
            },
            {
                name: 'ledgerApi',
                params: [
                    {
                        name: 'params',
                        schema: {
                            title: 'ledgerApiParams',
                            type: 'object',
                            properties: {
                                requestMethod: {
                                    type: 'string',
                                    enum: ['GET', 'POST', 'PUT', 'DELETE'],
                                },
                                resource: { type: 'string' },
                                body: { type: 'string' },
                            },
                            required: ['requestMethod', 'resource'],
                        },
                    },
                ],
                result: {
                    name: 'result',
                    schema: {
                        title: 'ledgerApiResult',
                        type: 'object',
                        properties: { response: { type: 'string' } },
                        required: ['response'],
                    },
                },
                description:
                    'Proxy for the JSON-API endpoints. Injects authorization headers automatically.',
            },
        ],
        components: {
            schemas: {
                Null: {
                    title: 'Null',
                    type: 'null',
                    description:
                        'Represents a null value, used in responses where no data is returned.',
                },
                UserUrl: {
                    title: 'UserUrl',
                    type: 'string',
                    format: 'uri',
                    description: 'A URL that points to a user interface.',
                },
                JsCommands: {
                    title: 'JsCommands',
                    type: 'object',
                    description:
                        'Structure representing JS commands for transaction execution',
                },
                JsPrepareSubmissionResponse: {
                    title: 'JsPrepareSubmissionResponse',
                    type: 'object',
                    description:
                        'Structure representing the result of a prepareReturn call',
                    properties: {
                        preparedTransaction: {
                            type: 'string',
                            description: 'The prepared transaction data.',
                        },
                        preparedTransactionHash: {
                            type: 'string',
                            description:
                                'The hash of the prepared transaction.',
                        },
                    },
                },
            },
        },
    }
    dereffedDocument
    transport
    validator
    timeout
    constructor(options) {
        if (
            options.transport === undefined ||
            options.transport.type === undefined
        ) {
            throw new Error('Invalid constructor params')
        }
        const { type, host, port, protocol } = options.transport
        let path = options.transport.path || ''
        if (path && path[0] !== '/') {
            path = '/' + path
        }
        switch (type) {
            case 'http':
            case 'https':
                this.transport = new HTTPTransport(
                    (protocol || type) + '://' + host + ':' + port + path
                )
                break
            case 'websocket':
                this.transport = new WebSocketTransport(
                    (protocol || 'ws://') + host + ':' + port + path
                )
                break
            case 'postmessageiframe':
                this.transport = new PostMessageIframeTransport(
                    protocol + '://' + host + ':' + port + path
                )
                break
            case 'postmessagewindow':
                this.transport = new PostMessageWindowTransport(
                    protocol + '://' + host + ':' + port + path
                )
                break
            default:
                throw new Error('unsupported transport')
        }
        this.rpc = new Client(new RequestManager([this.transport]))
    }
    /**
     * Adds a JSONRPC notification handler to handle receiving notifications.
     * @example
     * myClient.onNotification((data)=>console.log(data));
     */
    async initialize() {
        if (this.validator) {
            return
        }
        this.dereffedDocument = await parseOpenRPCDocument(
            WalletJSONRPCDAppAPI.openrpcDocument
        )
        this.validator = new MethodCallValidator(this.dereffedDocument)
    }
    /**
     * Adds a JSONRPC notification handler to handle receiving notifications.
     * @example
     * myClient.onNotification((data)=>console.log(data));
     */
    onNotification(callback) {
        this.rpc.onNotification(callback)
    }
    /**
     * Adds an optional JSONRPCError handler to handle receiving errors that cannot be resolved to a specific request
     * @example
     * myClient.onError((err: JSONRPCError)=>console.log(err.message));
     */
    onError(callback) {
        this.rpc.onError(callback)
    }
    /**
     * Sets a default timeout in ms for all requests excluding notifications.
     * @example
     * // 20s timeout
     * myClient.setDefaultTimeout(20000);
     * // Removes timeout from request
     * myClient.setDefaultTimeout(undefined);
     */
    setDefaultTimeout(ms) {
        this.timeout = ms
    }
    /**
     * Initiates [[WalletJSONRPCDAppAPI.startBatch]] in order to build a batch call.
     *
     * Subsequent calls to [[WalletJSONRPCDAppAPI.request]] will be added to the batch.
     * Once [[WalletJSONRPCDAppAPI.stopBatch]] is called, the promises for the [[WalletJSONRPCDAppAPI.request]]
     * will then be resolved.  If there is already a batch in progress this method is a noop.
     *
     * @example
     * myClient.startBatch();
     * myClient.foo().then(() => console.log("foobar"))
     * myClient.bar().then(() => console.log("foobarbaz"))
     * myClient.stopBatch();
     */
    startBatch() {
        return this.rpc.startBatch()
    }
    /**
     * Initiates [[Client.stopBatch]] in order to finalize and send the batch to the underlying transport.
     *
     * stopBatch will send the [[WalletJSONRPCDAppAPI]] calls made since the last [[WalletJSONRPCDAppAPI.startBatch]] call. For
     * that reason, [[WalletJSONRPCDAppAPI.startBatch]] MUST be called before [[WalletJSONRPCDAppAPI.stopBatch]].
     *
     * @example
     * myClient.startBatch();
     * myClient.foo().then(() => console.log("foobar"))
     * myClient.bar().then(() => console.log("foobarbaz"))
     * myClient.stopBatch();
     */
    stopBatch() {
        return this.rpc.stopBatch()
    }
    async request(methodName, params) {
        await this.initialize()
        if (this.validator === undefined) {
            throw new Error('internal error')
        }
        const methodObject = _.find(
            WalletJSONRPCDAppAPI.openrpcDocument.methods,
            ({ name }) => name === methodName
        )
        const notification = methodObject.result ? false : true
        const openRpcMethodValidationErrors = this.validator.validate(
            methodName,
            params
        )
        if (
            openRpcMethodValidationErrors instanceof MethodNotFoundError ||
            openRpcMethodValidationErrors.length > 0
        ) {
            return Promise.reject(openRpcMethodValidationErrors)
        }
        let rpcParams
        if (
            methodObject.paramStructure &&
            methodObject.paramStructure === 'by-name'
        ) {
            rpcParams = _.zipObject(_.map(methodObject.params, 'name'), params)
        } else {
            rpcParams = params
        }
        if (notification) {
            return this.rpc.notify({ method: methodName, params: rpcParams })
        }
        return this.rpc.request(
            { method: methodName, params: rpcParams },
            this.timeout
        )
    }
    /**
     *
     */
    // tslint:disable-next-line:max-line-length
    connect = (...params) => {
        return this.request('connect', params)
    }
    /**
     *
     */
    // tslint:disable-next-line:max-line-length
    darsAvailable = (...params) => {
        return this.request('darsAvailable', params)
    }
    /**
     *
     */
    // tslint:disable-next-line:max-line-length
    prepareReturn = (...params) => {
        return this.request('prepareReturn', params)
    }
    /**
     *
     */
    // tslint:disable-next-line:max-line-length
    prepareExecute = (...params) => {
        return this.request('prepareExecute', params)
    }
    /**
     *
     */
    // tslint:disable-next-line:max-line-length
    ledgerApi = (...params) => {
        return this.request('ledgerApi', params)
    }
}
export default WalletJSONRPCDAppAPI
//# sourceMappingURL=index.js.map
