// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "scalapb/scalapb.proto" (package "scalapb", syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { FieldOptions as FieldOptions$ } from "../google/protobuf/descriptor";
import { FieldDescriptorProto } from "../google/protobuf/descriptor";
/**
 * @generated from protobuf message scalapb.ScalaPbOptions
 */
export interface ScalaPbOptions {
    /**
     * If set then it overrides the java_package and package.
     *
     * @generated from protobuf field: optional string package_name = 1
     */
    packageName?: string;
    /**
     * If true, the compiler does not append the proto base file name
     * into the generated package name. If false (the default), the
     * generated scala package name is the package_name.basename where
     * basename is the proto file name without the .proto extension.
     *
     * @generated from protobuf field: optional bool flat_package = 2
     */
    flatPackage?: boolean;
    /**
     * Adds the following imports at the top of the file (this is meant
     * to provide implicit TypeMappers)
     *
     * @generated from protobuf field: repeated string import = 3
     */
    import: string[];
    /**
     * Text to add to the generated scala file.  This can be used only
     * when single_file is true.
     *
     * @generated from protobuf field: repeated string preamble = 4
     */
    preamble: string[];
    /**
     * If true, all messages and enums (but not services) will be written
     * to a single Scala file.
     *
     * @generated from protobuf field: optional bool single_file = 5
     */
    singleFile?: boolean;
    /**
     * By default, wrappers defined at
     * https://github.com/google/protobuf/blob/master/src/google/protobuf/wrappers.proto,
     * are mapped to an Option[T] where T is a primitive type. When this field
     * is set to true, we do not perform this transformation.
     *
     * @generated from protobuf field: optional bool no_primitive_wrappers = 7
     */
    noPrimitiveWrappers?: boolean;
    /**
     * DEPRECATED. In ScalaPB <= 0.5.47, it was necessary to explicitly enable
     * primitive_wrappers. This field remains here for backwards compatibility,
     * but it has no effect on generated code. It is an error to set both
     * `primitive_wrappers` and `no_primitive_wrappers`.
     *
     * @generated from protobuf field: optional bool primitive_wrappers = 6
     */
    primitiveWrappers?: boolean;
    /**
     * Scala type to be used for repeated fields. If unspecified,
     * `scala.collection.Seq` will be used.
     *
     * @generated from protobuf field: optional string collection_type = 8
     */
    collectionType?: string;
    /**
     * If set to true, all generated messages in this file will preserve unknown
     * fields.
     *
     * @generated from protobuf field: optional bool preserve_unknown_fields = 9 [default = true]
     */
    preserveUnknownFields?: boolean;
    /**
     * If defined, sets the name of the file-level object that would be generated. This
     * object extends `GeneratedFileObject` and contains descriptors, and list of message
     * and enum companions.
     *
     * @generated from protobuf field: optional string object_name = 10
     */
    objectName?: string;
    /**
     * Experimental: scope to apply the given options.
     *
     * @generated from protobuf field: optional scalapb.ScalaPbOptions.OptionsScope scope = 11
     */
    scope?: ScalaPbOptions_OptionsScope;
    /**
     * If true, lenses will be generated.
     *
     * @generated from protobuf field: optional bool lenses = 12 [default = true]
     */
    lenses?: boolean;
    /**
     * If true, then source-code info information will be included in the
     * generated code - normally the source code info is cleared out to reduce
     * code size.  The source code info is useful for extracting source code
     * location from the descriptors as well as comments.
     *
     * @generated from protobuf field: optional bool retain_source_code_info = 13
     */
    retainSourceCodeInfo?: boolean;
    /**
     * Scala type to be used for maps. If unspecified,
     * `scala.collection.immutable.Map` will be used.
     *
     * @generated from protobuf field: optional string map_type = 14
     */
    mapType?: string;
    /**
     * If true, no default values will be generated in message constructors.
     * This setting can be overridden at the message-level and for individual
     * fields.
     *
     * @generated from protobuf field: optional bool no_default_values_in_constructor = 15
     */
    noDefaultValuesInConstructor?: boolean;
    /**
     * @generated from protobuf field: optional scalapb.ScalaPbOptions.EnumValueNaming enum_value_naming = 16
     */
    enumValueNaming?: ScalaPbOptions_EnumValueNaming;
    /**
     * Indicate if prefix (enum name + optional underscore) should be removed in scala code
     * Strip is applied before enum value naming changes.
     *
     * @generated from protobuf field: optional bool enum_strip_prefix = 17 [default = false]
     */
    enumStripPrefix?: boolean;
    /**
     * Scala type to use for bytes fields.
     *
     * @generated from protobuf field: optional string bytes_type = 21
     */
    bytesType?: string;
    /**
     * Enable java conversions for this file.
     *
     * @generated from protobuf field: optional bool java_conversions = 23
     */
    javaConversions?: boolean;
    /**
     * List of message options to apply to some messages.
     *
     * @generated from protobuf field: repeated scalapb.ScalaPbOptions.AuxMessageOptions aux_message_options = 18
     */
    auxMessageOptions: ScalaPbOptions_AuxMessageOptions[];
    /**
     * List of message options to apply to some fields.
     *
     * @generated from protobuf field: repeated scalapb.ScalaPbOptions.AuxFieldOptions aux_field_options = 19
     */
    auxFieldOptions: ScalaPbOptions_AuxFieldOptions[];
    /**
     * List of message options to apply to some enums.
     *
     * @generated from protobuf field: repeated scalapb.ScalaPbOptions.AuxEnumOptions aux_enum_options = 20
     */
    auxEnumOptions: ScalaPbOptions_AuxEnumOptions[];
    /**
     * List of enum value options to apply to some enum values.
     *
     * @generated from protobuf field: repeated scalapb.ScalaPbOptions.AuxEnumValueOptions aux_enum_value_options = 22
     */
    auxEnumValueOptions: ScalaPbOptions_AuxEnumValueOptions[];
    /**
     * List of preprocessors to apply.
     *
     * @generated from protobuf field: repeated string preprocessors = 24
     */
    preprocessors: string[];
    /**
     * @generated from protobuf field: repeated scalapb.FieldTransformation field_transformations = 25
     */
    fieldTransformations: FieldTransformation[];
    /**
     * Ignores all transformations for this file. This is meant to allow specific files to
     * opt out from transformations inherited through package-scoped options.
     *
     * @generated from protobuf field: optional bool ignore_all_transformations = 26
     */
    ignoreAllTransformations?: boolean;
    /**
     * If true, getters will be generated.
     *
     * @generated from protobuf field: optional bool getters = 27 [default = true]
     */
    getters?: boolean;
    /**
     * Generate sources that are compatible with Scala 3
     *
     * @generated from protobuf field: optional bool scala3_sources = 28
     */
    scala3Sources?: boolean;
    /**
     * For use in tests only. Inhibit Java conversions even when when generator parameters
     * request for it.
     *
     * @generated from protobuf field: optional bool test_only_no_java_conversions = 999
     */
    testOnlyNoJavaConversions?: boolean;
}
/**
 * AuxMessageOptions enables you to set message-level options through package-scoped options.
 * This is useful when you can't add a dependency on scalapb.proto from the proto file that
 * defines the message.
 *
 * @generated from protobuf message scalapb.ScalaPbOptions.AuxMessageOptions
 */
export interface ScalaPbOptions_AuxMessageOptions {
    /**
     * The fully-qualified name of the message in the proto name space. Set to `*` to apply to all
     * messages in scope.
     *
     * @generated from protobuf field: optional string target = 1
     */
    target?: string;
    /**
     * Options to apply to the message. If there are any options defined on the target message
     * they take precedence over the options.
     *
     * @generated from protobuf field: optional scalapb.MessageOptions options = 2
     */
    options?: MessageOptions;
}
/**
 * AuxFieldOptions enables you to set field-level options through package-scoped options.
 * This is useful when you can't add a dependency on scalapb.proto from the proto file that
 * defines the field.
 *
 * @generated from protobuf message scalapb.ScalaPbOptions.AuxFieldOptions
 */
export interface ScalaPbOptions_AuxFieldOptions {
    /**
     * The fully-qualified name of the field in the proto name space. Set to `*` to apply to all
     * fields in scope.
     *
     * @generated from protobuf field: optional string target = 1
     */
    target?: string;
    /**
     * Options to apply to the field. If there are any options defined on the target message
     * they take precedence over the options.
     *
     * @generated from protobuf field: optional scalapb.FieldOptions options = 2
     */
    options?: FieldOptions;
}
/**
 * AuxEnumOptions enables you to set enum-level options through package-scoped options.
 * This is useful when you can't add a dependency on scalapb.proto from the proto file that
 * defines the enum.
 *
 * @generated from protobuf message scalapb.ScalaPbOptions.AuxEnumOptions
 */
export interface ScalaPbOptions_AuxEnumOptions {
    /**
     * The fully-qualified name of the enum in the proto name space. Set to `*` to apply to
     * all enums in scope.
     *
     * @generated from protobuf field: optional string target = 1
     */
    target?: string;
    /**
     * Options to apply to the enum. If there are any options defined on the target enum
     * they take precedence over the options.
     *
     * @generated from protobuf field: optional scalapb.EnumOptions options = 2
     */
    options?: EnumOptions;
}
/**
 * AuxEnumValueOptions enables you to set enum value level options through package-scoped
 * options.  This is useful when you can't add a dependency on scalapb.proto from the proto
 * file that defines the enum.
 *
 * @generated from protobuf message scalapb.ScalaPbOptions.AuxEnumValueOptions
 */
export interface ScalaPbOptions_AuxEnumValueOptions {
    /**
     * The fully-qualified name of the enum value in the proto name space. Set to `*` to apply
     * to all enum values in scope.
     *
     * @generated from protobuf field: optional string target = 1
     */
    target?: string;
    /**
     * Options to apply to the enum value. If there are any options defined on
     * the target enum value they take precedence over the options.
     *
     * @generated from protobuf field: optional scalapb.EnumValueOptions options = 2
     */
    options?: EnumValueOptions;
}
/**
 * Whether to apply the options only to this file, or for the entire package (and its subpackages)
 *
 * @generated from protobuf enum scalapb.ScalaPbOptions.OptionsScope
 */
export enum ScalaPbOptions_OptionsScope {
    /**
     * Apply the options for this file only (default)
     *
     * @generated from protobuf enum value: FILE = 0;
     */
    FILE = 0,
    /**
     * Apply the options for the entire package and its subpackages.
     *
     * @generated from protobuf enum value: PACKAGE = 1;
     */
    PACKAGE = 1
}
/**
 * Naming convention for generated enum values
 *
 * @generated from protobuf enum scalapb.ScalaPbOptions.EnumValueNaming
 */
export enum ScalaPbOptions_EnumValueNaming {
    /**
     * Enum value names in Scala use the same name as in the proto
     *
     * @generated from protobuf enum value: AS_IN_PROTO = 0;
     */
    AS_IN_PROTO = 0,
    /**
     * Convert enum values to CamelCase in Scala.
     *
     * @generated from protobuf enum value: CAMEL_CASE = 1;
     */
    CAMEL_CASE = 1
}
/**
 * @generated from protobuf message scalapb.MessageOptions
 */
export interface MessageOptions {
    /**
     * Additional classes and traits to mix in to the case class.
     *
     * @generated from protobuf field: repeated string extends = 1
     */
    extends: string[];
    /**
     * Additional classes and traits to mix in to the companion object.
     *
     * @generated from protobuf field: repeated string companion_extends = 2
     */
    companionExtends: string[];
    /**
     * Custom annotations to add to the generated case class.
     *
     * @generated from protobuf field: repeated string annotations = 3
     */
    annotations: string[];
    /**
     * All instances of this message will be converted to this type. An implicit TypeMapper
     * must be present.
     *
     * @generated from protobuf field: optional string type = 4
     */
    type?: string;
    /**
     * Custom annotations to add to the companion object of the generated class.
     *
     * @generated from protobuf field: repeated string companion_annotations = 5
     */
    companionAnnotations: string[];
    /**
     * Additional classes and traits to mix in to generated sealed_oneof base trait.
     *
     * @generated from protobuf field: repeated string sealed_oneof_extends = 6
     */
    sealedOneofExtends: string[];
    /**
     * If true, when this message is used as an optional field, do not wrap it in an `Option`.
     * This is equivalent of setting `(field).no_box` to true on each field with the message type.
     *
     * @generated from protobuf field: optional bool no_box = 7
     */
    noBox?: boolean;
    /**
     * Custom annotations to add to the generated `unknownFields` case class field.
     *
     * @generated from protobuf field: repeated string unknown_fields_annotations = 8
     */
    unknownFieldsAnnotations: string[];
    /**
     * If true, no default values will be generated in message constructors.
     * If set (to true or false), the message-level setting overrides the
     * file-level value, and can be overridden by the field-level setting.
     *
     * @generated from protobuf field: optional bool no_default_values_in_constructor = 9
     */
    noDefaultValuesInConstructor?: boolean;
    /**
     * Additional classes and traits to mix in to generated sealed oneof base trait's companion object.
     *
     * @generated from protobuf field: repeated string sealed_oneof_companion_extends = 10
     */
    sealedOneofCompanionExtends: string[];
    /**
     * Adds a derives clause to the message case class
     *
     * @generated from protobuf field: repeated string derives = 11
     */
    derives: string[];
    /**
     * Additional classes and traits to add to the derives clause of a sealed oneof.
     *
     * @generated from protobuf field: repeated string sealed_oneof_derives = 12
     */
    sealedOneofDerives: string[];
}
/**
 * Represents a custom Collection type in Scala. This allows ScalaPB to integrate with
 * collection types that are different enough from the ones in the standard library.
 *
 * @generated from protobuf message scalapb.Collection
 */
export interface Collection {
    /**
     * Type of the collection
     *
     * @generated from protobuf field: optional string type = 1
     */
    type?: string;
    /**
     * Set to true if this collection type is not allowed to be empty, for example
     * cats.data.NonEmptyList.  When true, ScalaPB will not generate `clearX` for the repeated
     * field and not provide a default argument in the constructor.
     *
     * @generated from protobuf field: optional bool non_empty = 2
     */
    nonEmpty?: boolean;
    /**
     * An Adapter is a Scala object available at runtime that provides certain static methods
     * that can operate on this collection type.
     *
     * @generated from protobuf field: optional string adapter = 3
     */
    adapter?: string;
}
/**
 * @generated from protobuf message scalapb.FieldOptions
 */
export interface FieldOptions {
    /**
     * @generated from protobuf field: optional string type = 1
     */
    type?: string;
    /**
     * @generated from protobuf field: optional string scala_name = 2
     */
    scalaName?: string;
    /**
     * Can be specified only if this field is repeated. If unspecified,
     * it falls back to the file option named `collection_type`, which defaults
     * to `scala.collection.Seq`.
     *
     * @generated from protobuf field: optional string collection_type = 3
     */
    collectionType?: string;
    /**
     * @generated from protobuf field: optional scalapb.Collection collection = 8
     */
    collection?: Collection;
    /**
     * If the field is a map, you can specify custom Scala types for the key
     * or value.
     *
     * @generated from protobuf field: optional string key_type = 4
     */
    keyType?: string;
    /**
     * @generated from protobuf field: optional string value_type = 5
     */
    valueType?: string;
    /**
     * Custom annotations to add to the field.
     *
     * @generated from protobuf field: repeated string annotations = 6
     */
    annotations: string[];
    /**
     * Can be specified only if this field is a map. If unspecified,
     * it falls back to the file option named `map_type` which defaults to
     * `scala.collection.immutable.Map`
     *
     * @generated from protobuf field: optional string map_type = 7
     */
    mapType?: string;
    /**
     * If true, no default value will be generated for this field in the message
     * constructor. If this field is set, it has the highest precedence and overrides the
     * values at the message-level and file-level.
     *
     * @generated from protobuf field: optional bool no_default_value_in_constructor = 9
     */
    noDefaultValueInConstructor?: boolean;
    /**
     * Do not box this value in Option[T]. If set, this overrides MessageOptions.no_box
     *
     * @generated from protobuf field: optional bool no_box = 30
     */
    noBox?: boolean;
    /**
     * Like no_box it does not box a value in Option[T], but also fails parsing when a value
     * is not provided. This enables to emulate required fields in proto3.
     *
     * @generated from protobuf field: optional bool required = 31
     */
    required?: boolean;
}
/**
 * @generated from protobuf message scalapb.EnumOptions
 */
export interface EnumOptions {
    /**
     * Additional classes and traits to mix in to the base trait
     *
     * @generated from protobuf field: repeated string extends = 1
     */
    extends: string[];
    /**
     * Additional classes and traits to mix in to the companion object.
     *
     * @generated from protobuf field: repeated string companion_extends = 2
     */
    companionExtends: string[];
    /**
     * All instances of this enum will be converted to this type. An implicit TypeMapper
     * must be present.
     *
     * @generated from protobuf field: optional string type = 3
     */
    type?: string;
    /**
     * Custom annotations to add to the generated enum's base class.
     *
     * @generated from protobuf field: repeated string base_annotations = 4
     */
    baseAnnotations: string[];
    /**
     * Custom annotations to add to the generated trait.
     *
     * @generated from protobuf field: repeated string recognized_annotations = 5
     */
    recognizedAnnotations: string[];
    /**
     * Custom annotations to add to the generated Unrecognized case class.
     *
     * @generated from protobuf field: repeated string unrecognized_annotations = 6
     */
    unrecognizedAnnotations: string[];
}
/**
 * @generated from protobuf message scalapb.EnumValueOptions
 */
export interface EnumValueOptions {
    /**
     * Additional classes and traits to mix in to an individual enum value.
     *
     * @generated from protobuf field: repeated string extends = 1
     */
    extends: string[];
    /**
     * Name in Scala to use for this enum value.
     *
     * @generated from protobuf field: optional string scala_name = 2
     */
    scalaName?: string;
    /**
     * Custom annotations to add to the generated case object for this enum value.
     *
     * @generated from protobuf field: repeated string annotations = 3
     */
    annotations: string[];
}
/**
 * @generated from protobuf message scalapb.OneofOptions
 */
export interface OneofOptions {
    /**
     * Additional traits to mix in to a oneof.
     *
     * @generated from protobuf field: repeated string extends = 1
     */
    extends: string[];
    /**
     * Name in Scala to use for this oneof field.
     *
     * @generated from protobuf field: optional string scala_name = 2
     */
    scalaName?: string;
}
/**
 * @generated from protobuf message scalapb.FieldTransformation
 */
export interface FieldTransformation {
    /**
     * @generated from protobuf field: optional google.protobuf.FieldDescriptorProto when = 1
     */
    when?: FieldDescriptorProto;
    /**
     * @generated from protobuf field: optional scalapb.MatchType match_type = 2 [default = CONTAINS]
     */
    matchType?: MatchType;
    /**
     * @generated from protobuf field: optional google.protobuf.FieldOptions set = 3
     */
    set?: FieldOptions$;
}
/**
 * @generated from protobuf message scalapb.PreprocessorOutput
 */
export interface PreprocessorOutput {
    /**
     * @generated from protobuf field: map<string, scalapb.ScalaPbOptions> options_by_file = 1
     */
    optionsByFile: {
        [key: string]: ScalaPbOptions;
    };
}
/**
 * @generated from protobuf enum scalapb.MatchType
 */
export enum MatchType {
    /**
     * @generated from protobuf enum value: CONTAINS = 0;
     */
    CONTAINS = 0,
    /**
     * @generated from protobuf enum value: EXACT = 1;
     */
    EXACT = 1,
    /**
     * @generated from protobuf enum value: PRESENCE = 2;
     */
    PRESENCE = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class ScalaPbOptions$Type extends MessageType<ScalaPbOptions> {
    constructor() {
        super("scalapb.ScalaPbOptions", [
            { no: 1, name: "package_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "flat_package", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "import", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "preamble", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "single_file", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "no_primitive_wrappers", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "primitive_wrappers", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "collection_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "preserve_unknown_fields", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "object_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "scope", kind: "enum", opt: true, T: () => ["scalapb.ScalaPbOptions.OptionsScope", ScalaPbOptions_OptionsScope] },
            { no: 12, name: "lenses", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 13, name: "retain_source_code_info", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 14, name: "map_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 15, name: "no_default_values_in_constructor", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 16, name: "enum_value_naming", kind: "enum", opt: true, T: () => ["scalapb.ScalaPbOptions.EnumValueNaming", ScalaPbOptions_EnumValueNaming] },
            { no: 17, name: "enum_strip_prefix", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 21, name: "bytes_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 23, name: "java_conversions", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 18, name: "aux_message_options", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ScalaPbOptions_AuxMessageOptions },
            { no: 19, name: "aux_field_options", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ScalaPbOptions_AuxFieldOptions },
            { no: 20, name: "aux_enum_options", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ScalaPbOptions_AuxEnumOptions },
            { no: 22, name: "aux_enum_value_options", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ScalaPbOptions_AuxEnumValueOptions },
            { no: 24, name: "preprocessors", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 25, name: "field_transformations", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FieldTransformation },
            { no: 26, name: "ignore_all_transformations", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 27, name: "getters", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 28, name: "scala3_sources", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 999, name: "test_only_no_java_conversions", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ScalaPbOptions>): ScalaPbOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.import = [];
        message.preamble = [];
        message.auxMessageOptions = [];
        message.auxFieldOptions = [];
        message.auxEnumOptions = [];
        message.auxEnumValueOptions = [];
        message.preprocessors = [];
        message.fieldTransformations = [];
        if (value !== undefined)
            reflectionMergePartial<ScalaPbOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScalaPbOptions): ScalaPbOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string package_name */ 1:
                    message.packageName = reader.string();
                    break;
                case /* optional bool flat_package */ 2:
                    message.flatPackage = reader.bool();
                    break;
                case /* repeated string import */ 3:
                    message.import.push(reader.string());
                    break;
                case /* repeated string preamble */ 4:
                    message.preamble.push(reader.string());
                    break;
                case /* optional bool single_file */ 5:
                    message.singleFile = reader.bool();
                    break;
                case /* optional bool no_primitive_wrappers */ 7:
                    message.noPrimitiveWrappers = reader.bool();
                    break;
                case /* optional bool primitive_wrappers */ 6:
                    message.primitiveWrappers = reader.bool();
                    break;
                case /* optional string collection_type */ 8:
                    message.collectionType = reader.string();
                    break;
                case /* optional bool preserve_unknown_fields = 9 [default = true] */ 9:
                    message.preserveUnknownFields = reader.bool();
                    break;
                case /* optional string object_name */ 10:
                    message.objectName = reader.string();
                    break;
                case /* optional scalapb.ScalaPbOptions.OptionsScope scope */ 11:
                    message.scope = reader.int32();
                    break;
                case /* optional bool lenses = 12 [default = true] */ 12:
                    message.lenses = reader.bool();
                    break;
                case /* optional bool retain_source_code_info */ 13:
                    message.retainSourceCodeInfo = reader.bool();
                    break;
                case /* optional string map_type */ 14:
                    message.mapType = reader.string();
                    break;
                case /* optional bool no_default_values_in_constructor */ 15:
                    message.noDefaultValuesInConstructor = reader.bool();
                    break;
                case /* optional scalapb.ScalaPbOptions.EnumValueNaming enum_value_naming */ 16:
                    message.enumValueNaming = reader.int32();
                    break;
                case /* optional bool enum_strip_prefix = 17 [default = false] */ 17:
                    message.enumStripPrefix = reader.bool();
                    break;
                case /* optional string bytes_type */ 21:
                    message.bytesType = reader.string();
                    break;
                case /* optional bool java_conversions */ 23:
                    message.javaConversions = reader.bool();
                    break;
                case /* repeated scalapb.ScalaPbOptions.AuxMessageOptions aux_message_options */ 18:
                    message.auxMessageOptions.push(ScalaPbOptions_AuxMessageOptions.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated scalapb.ScalaPbOptions.AuxFieldOptions aux_field_options */ 19:
                    message.auxFieldOptions.push(ScalaPbOptions_AuxFieldOptions.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated scalapb.ScalaPbOptions.AuxEnumOptions aux_enum_options */ 20:
                    message.auxEnumOptions.push(ScalaPbOptions_AuxEnumOptions.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated scalapb.ScalaPbOptions.AuxEnumValueOptions aux_enum_value_options */ 22:
                    message.auxEnumValueOptions.push(ScalaPbOptions_AuxEnumValueOptions.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string preprocessors */ 24:
                    message.preprocessors.push(reader.string());
                    break;
                case /* repeated scalapb.FieldTransformation field_transformations */ 25:
                    message.fieldTransformations.push(FieldTransformation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool ignore_all_transformations */ 26:
                    message.ignoreAllTransformations = reader.bool();
                    break;
                case /* optional bool getters = 27 [default = true] */ 27:
                    message.getters = reader.bool();
                    break;
                case /* optional bool scala3_sources */ 28:
                    message.scala3Sources = reader.bool();
                    break;
                case /* optional bool test_only_no_java_conversions */ 999:
                    message.testOnlyNoJavaConversions = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScalaPbOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string package_name = 1; */
        if (message.packageName !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.packageName);
        /* optional bool flat_package = 2; */
        if (message.flatPackage !== undefined)
            writer.tag(2, WireType.Varint).bool(message.flatPackage);
        /* repeated string import = 3; */
        for (let i = 0; i < message.import.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.import[i]);
        /* repeated string preamble = 4; */
        for (let i = 0; i < message.preamble.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.preamble[i]);
        /* optional bool single_file = 5; */
        if (message.singleFile !== undefined)
            writer.tag(5, WireType.Varint).bool(message.singleFile);
        /* optional bool primitive_wrappers = 6; */
        if (message.primitiveWrappers !== undefined)
            writer.tag(6, WireType.Varint).bool(message.primitiveWrappers);
        /* optional bool no_primitive_wrappers = 7; */
        if (message.noPrimitiveWrappers !== undefined)
            writer.tag(7, WireType.Varint).bool(message.noPrimitiveWrappers);
        /* optional string collection_type = 8; */
        if (message.collectionType !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.collectionType);
        /* optional bool preserve_unknown_fields = 9 [default = true]; */
        if (message.preserveUnknownFields !== undefined)
            writer.tag(9, WireType.Varint).bool(message.preserveUnknownFields);
        /* optional string object_name = 10; */
        if (message.objectName !== undefined)
            writer.tag(10, WireType.LengthDelimited).string(message.objectName);
        /* optional scalapb.ScalaPbOptions.OptionsScope scope = 11; */
        if (message.scope !== undefined)
            writer.tag(11, WireType.Varint).int32(message.scope);
        /* optional bool lenses = 12 [default = true]; */
        if (message.lenses !== undefined)
            writer.tag(12, WireType.Varint).bool(message.lenses);
        /* optional bool retain_source_code_info = 13; */
        if (message.retainSourceCodeInfo !== undefined)
            writer.tag(13, WireType.Varint).bool(message.retainSourceCodeInfo);
        /* optional string map_type = 14; */
        if (message.mapType !== undefined)
            writer.tag(14, WireType.LengthDelimited).string(message.mapType);
        /* optional bool no_default_values_in_constructor = 15; */
        if (message.noDefaultValuesInConstructor !== undefined)
            writer.tag(15, WireType.Varint).bool(message.noDefaultValuesInConstructor);
        /* optional scalapb.ScalaPbOptions.EnumValueNaming enum_value_naming = 16; */
        if (message.enumValueNaming !== undefined)
            writer.tag(16, WireType.Varint).int32(message.enumValueNaming);
        /* optional bool enum_strip_prefix = 17 [default = false]; */
        if (message.enumStripPrefix !== undefined)
            writer.tag(17, WireType.Varint).bool(message.enumStripPrefix);
        /* repeated scalapb.ScalaPbOptions.AuxMessageOptions aux_message_options = 18; */
        for (let i = 0; i < message.auxMessageOptions.length; i++)
            ScalaPbOptions_AuxMessageOptions.internalBinaryWrite(message.auxMessageOptions[i], writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* repeated scalapb.ScalaPbOptions.AuxFieldOptions aux_field_options = 19; */
        for (let i = 0; i < message.auxFieldOptions.length; i++)
            ScalaPbOptions_AuxFieldOptions.internalBinaryWrite(message.auxFieldOptions[i], writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* repeated scalapb.ScalaPbOptions.AuxEnumOptions aux_enum_options = 20; */
        for (let i = 0; i < message.auxEnumOptions.length; i++)
            ScalaPbOptions_AuxEnumOptions.internalBinaryWrite(message.auxEnumOptions[i], writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* optional string bytes_type = 21; */
        if (message.bytesType !== undefined)
            writer.tag(21, WireType.LengthDelimited).string(message.bytesType);
        /* repeated scalapb.ScalaPbOptions.AuxEnumValueOptions aux_enum_value_options = 22; */
        for (let i = 0; i < message.auxEnumValueOptions.length; i++)
            ScalaPbOptions_AuxEnumValueOptions.internalBinaryWrite(message.auxEnumValueOptions[i], writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* optional bool java_conversions = 23; */
        if (message.javaConversions !== undefined)
            writer.tag(23, WireType.Varint).bool(message.javaConversions);
        /* repeated string preprocessors = 24; */
        for (let i = 0; i < message.preprocessors.length; i++)
            writer.tag(24, WireType.LengthDelimited).string(message.preprocessors[i]);
        /* repeated scalapb.FieldTransformation field_transformations = 25; */
        for (let i = 0; i < message.fieldTransformations.length; i++)
            FieldTransformation.internalBinaryWrite(message.fieldTransformations[i], writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* optional bool ignore_all_transformations = 26; */
        if (message.ignoreAllTransformations !== undefined)
            writer.tag(26, WireType.Varint).bool(message.ignoreAllTransformations);
        /* optional bool getters = 27 [default = true]; */
        if (message.getters !== undefined)
            writer.tag(27, WireType.Varint).bool(message.getters);
        /* optional bool scala3_sources = 28; */
        if (message.scala3Sources !== undefined)
            writer.tag(28, WireType.Varint).bool(message.scala3Sources);
        /* optional bool test_only_no_java_conversions = 999; */
        if (message.testOnlyNoJavaConversions !== undefined)
            writer.tag(999, WireType.Varint).bool(message.testOnlyNoJavaConversions);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message scalapb.ScalaPbOptions
 */
export const ScalaPbOptions = new ScalaPbOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScalaPbOptions_AuxMessageOptions$Type extends MessageType<ScalaPbOptions_AuxMessageOptions> {
    constructor() {
        super("scalapb.ScalaPbOptions.AuxMessageOptions", [
            { no: 1, name: "target", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "options", kind: "message", T: () => MessageOptions }
        ]);
    }
    create(value?: PartialMessage<ScalaPbOptions_AuxMessageOptions>): ScalaPbOptions_AuxMessageOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ScalaPbOptions_AuxMessageOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScalaPbOptions_AuxMessageOptions): ScalaPbOptions_AuxMessageOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string target */ 1:
                    message.target = reader.string();
                    break;
                case /* optional scalapb.MessageOptions options */ 2:
                    message.options = MessageOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScalaPbOptions_AuxMessageOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string target = 1; */
        if (message.target !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.target);
        /* optional scalapb.MessageOptions options = 2; */
        if (message.options)
            MessageOptions.internalBinaryWrite(message.options, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message scalapb.ScalaPbOptions.AuxMessageOptions
 */
export const ScalaPbOptions_AuxMessageOptions = new ScalaPbOptions_AuxMessageOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScalaPbOptions_AuxFieldOptions$Type extends MessageType<ScalaPbOptions_AuxFieldOptions> {
    constructor() {
        super("scalapb.ScalaPbOptions.AuxFieldOptions", [
            { no: 1, name: "target", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "options", kind: "message", T: () => FieldOptions }
        ]);
    }
    create(value?: PartialMessage<ScalaPbOptions_AuxFieldOptions>): ScalaPbOptions_AuxFieldOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ScalaPbOptions_AuxFieldOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScalaPbOptions_AuxFieldOptions): ScalaPbOptions_AuxFieldOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string target */ 1:
                    message.target = reader.string();
                    break;
                case /* optional scalapb.FieldOptions options */ 2:
                    message.options = FieldOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScalaPbOptions_AuxFieldOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string target = 1; */
        if (message.target !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.target);
        /* optional scalapb.FieldOptions options = 2; */
        if (message.options)
            FieldOptions.internalBinaryWrite(message.options, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message scalapb.ScalaPbOptions.AuxFieldOptions
 */
export const ScalaPbOptions_AuxFieldOptions = new ScalaPbOptions_AuxFieldOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScalaPbOptions_AuxEnumOptions$Type extends MessageType<ScalaPbOptions_AuxEnumOptions> {
    constructor() {
        super("scalapb.ScalaPbOptions.AuxEnumOptions", [
            { no: 1, name: "target", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "options", kind: "message", T: () => EnumOptions }
        ]);
    }
    create(value?: PartialMessage<ScalaPbOptions_AuxEnumOptions>): ScalaPbOptions_AuxEnumOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ScalaPbOptions_AuxEnumOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScalaPbOptions_AuxEnumOptions): ScalaPbOptions_AuxEnumOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string target */ 1:
                    message.target = reader.string();
                    break;
                case /* optional scalapb.EnumOptions options */ 2:
                    message.options = EnumOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScalaPbOptions_AuxEnumOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string target = 1; */
        if (message.target !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.target);
        /* optional scalapb.EnumOptions options = 2; */
        if (message.options)
            EnumOptions.internalBinaryWrite(message.options, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message scalapb.ScalaPbOptions.AuxEnumOptions
 */
export const ScalaPbOptions_AuxEnumOptions = new ScalaPbOptions_AuxEnumOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ScalaPbOptions_AuxEnumValueOptions$Type extends MessageType<ScalaPbOptions_AuxEnumValueOptions> {
    constructor() {
        super("scalapb.ScalaPbOptions.AuxEnumValueOptions", [
            { no: 1, name: "target", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "options", kind: "message", T: () => EnumValueOptions }
        ]);
    }
    create(value?: PartialMessage<ScalaPbOptions_AuxEnumValueOptions>): ScalaPbOptions_AuxEnumValueOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ScalaPbOptions_AuxEnumValueOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ScalaPbOptions_AuxEnumValueOptions): ScalaPbOptions_AuxEnumValueOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string target */ 1:
                    message.target = reader.string();
                    break;
                case /* optional scalapb.EnumValueOptions options */ 2:
                    message.options = EnumValueOptions.internalBinaryRead(reader, reader.uint32(), options, message.options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ScalaPbOptions_AuxEnumValueOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string target = 1; */
        if (message.target !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.target);
        /* optional scalapb.EnumValueOptions options = 2; */
        if (message.options)
            EnumValueOptions.internalBinaryWrite(message.options, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message scalapb.ScalaPbOptions.AuxEnumValueOptions
 */
export const ScalaPbOptions_AuxEnumValueOptions = new ScalaPbOptions_AuxEnumValueOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MessageOptions$Type extends MessageType<MessageOptions> {
    constructor() {
        super("scalapb.MessageOptions", [
            { no: 1, name: "extends", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "companion_extends", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "annotations", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "companion_annotations", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "sealed_oneof_extends", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "no_box", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "unknown_fields_annotations", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "no_default_values_in_constructor", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "sealed_oneof_companion_extends", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "derives", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 12, name: "sealed_oneof_derives", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MessageOptions>): MessageOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.extends = [];
        message.companionExtends = [];
        message.annotations = [];
        message.companionAnnotations = [];
        message.sealedOneofExtends = [];
        message.unknownFieldsAnnotations = [];
        message.sealedOneofCompanionExtends = [];
        message.derives = [];
        message.sealedOneofDerives = [];
        if (value !== undefined)
            reflectionMergePartial<MessageOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MessageOptions): MessageOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string extends */ 1:
                    message.extends.push(reader.string());
                    break;
                case /* repeated string companion_extends */ 2:
                    message.companionExtends.push(reader.string());
                    break;
                case /* repeated string annotations */ 3:
                    message.annotations.push(reader.string());
                    break;
                case /* optional string type */ 4:
                    message.type = reader.string();
                    break;
                case /* repeated string companion_annotations */ 5:
                    message.companionAnnotations.push(reader.string());
                    break;
                case /* repeated string sealed_oneof_extends */ 6:
                    message.sealedOneofExtends.push(reader.string());
                    break;
                case /* optional bool no_box */ 7:
                    message.noBox = reader.bool();
                    break;
                case /* repeated string unknown_fields_annotations */ 8:
                    message.unknownFieldsAnnotations.push(reader.string());
                    break;
                case /* optional bool no_default_values_in_constructor */ 9:
                    message.noDefaultValuesInConstructor = reader.bool();
                    break;
                case /* repeated string sealed_oneof_companion_extends */ 10:
                    message.sealedOneofCompanionExtends.push(reader.string());
                    break;
                case /* repeated string derives */ 11:
                    message.derives.push(reader.string());
                    break;
                case /* repeated string sealed_oneof_derives */ 12:
                    message.sealedOneofDerives.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MessageOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string extends = 1; */
        for (let i = 0; i < message.extends.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.extends[i]);
        /* repeated string companion_extends = 2; */
        for (let i = 0; i < message.companionExtends.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.companionExtends[i]);
        /* repeated string annotations = 3; */
        for (let i = 0; i < message.annotations.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.annotations[i]);
        /* optional string type = 4; */
        if (message.type !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.type);
        /* repeated string companion_annotations = 5; */
        for (let i = 0; i < message.companionAnnotations.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.companionAnnotations[i]);
        /* repeated string sealed_oneof_extends = 6; */
        for (let i = 0; i < message.sealedOneofExtends.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.sealedOneofExtends[i]);
        /* optional bool no_box = 7; */
        if (message.noBox !== undefined)
            writer.tag(7, WireType.Varint).bool(message.noBox);
        /* repeated string unknown_fields_annotations = 8; */
        for (let i = 0; i < message.unknownFieldsAnnotations.length; i++)
            writer.tag(8, WireType.LengthDelimited).string(message.unknownFieldsAnnotations[i]);
        /* optional bool no_default_values_in_constructor = 9; */
        if (message.noDefaultValuesInConstructor !== undefined)
            writer.tag(9, WireType.Varint).bool(message.noDefaultValuesInConstructor);
        /* repeated string sealed_oneof_companion_extends = 10; */
        for (let i = 0; i < message.sealedOneofCompanionExtends.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.sealedOneofCompanionExtends[i]);
        /* repeated string derives = 11; */
        for (let i = 0; i < message.derives.length; i++)
            writer.tag(11, WireType.LengthDelimited).string(message.derives[i]);
        /* repeated string sealed_oneof_derives = 12; */
        for (let i = 0; i < message.sealedOneofDerives.length; i++)
            writer.tag(12, WireType.LengthDelimited).string(message.sealedOneofDerives[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message scalapb.MessageOptions
 */
export const MessageOptions = new MessageOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Collection$Type extends MessageType<Collection> {
    constructor() {
        super("scalapb.Collection", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "non_empty", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "adapter", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Collection>): Collection {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Collection>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Collection): Collection {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string type */ 1:
                    message.type = reader.string();
                    break;
                case /* optional bool non_empty */ 2:
                    message.nonEmpty = reader.bool();
                    break;
                case /* optional string adapter */ 3:
                    message.adapter = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Collection, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* optional bool non_empty = 2; */
        if (message.nonEmpty !== undefined)
            writer.tag(2, WireType.Varint).bool(message.nonEmpty);
        /* optional string adapter = 3; */
        if (message.adapter !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.adapter);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message scalapb.Collection
 */
export const Collection = new Collection$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FieldOptions$Type extends MessageType<FieldOptions> {
    constructor() {
        super("scalapb.FieldOptions", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "scala_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "collection_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "collection", kind: "message", T: () => Collection },
            { no: 4, name: "key_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "value_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "annotations", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "map_type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "no_default_value_in_constructor", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 30, name: "no_box", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 31, name: "required", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FieldOptions>): FieldOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.annotations = [];
        if (value !== undefined)
            reflectionMergePartial<FieldOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FieldOptions): FieldOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string type */ 1:
                    message.type = reader.string();
                    break;
                case /* optional string scala_name */ 2:
                    message.scalaName = reader.string();
                    break;
                case /* optional string collection_type */ 3:
                    message.collectionType = reader.string();
                    break;
                case /* optional scalapb.Collection collection */ 8:
                    message.collection = Collection.internalBinaryRead(reader, reader.uint32(), options, message.collection);
                    break;
                case /* optional string key_type */ 4:
                    message.keyType = reader.string();
                    break;
                case /* optional string value_type */ 5:
                    message.valueType = reader.string();
                    break;
                case /* repeated string annotations */ 6:
                    message.annotations.push(reader.string());
                    break;
                case /* optional string map_type */ 7:
                    message.mapType = reader.string();
                    break;
                case /* optional bool no_default_value_in_constructor */ 9:
                    message.noDefaultValueInConstructor = reader.bool();
                    break;
                case /* optional bool no_box */ 30:
                    message.noBox = reader.bool();
                    break;
                case /* optional bool required */ 31:
                    message.required = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FieldOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.type);
        /* optional string scala_name = 2; */
        if (message.scalaName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.scalaName);
        /* optional string collection_type = 3; */
        if (message.collectionType !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.collectionType);
        /* optional string key_type = 4; */
        if (message.keyType !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.keyType);
        /* optional string value_type = 5; */
        if (message.valueType !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.valueType);
        /* repeated string annotations = 6; */
        for (let i = 0; i < message.annotations.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.annotations[i]);
        /* optional string map_type = 7; */
        if (message.mapType !== undefined)
            writer.tag(7, WireType.LengthDelimited).string(message.mapType);
        /* optional scalapb.Collection collection = 8; */
        if (message.collection)
            Collection.internalBinaryWrite(message.collection, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional bool no_default_value_in_constructor = 9; */
        if (message.noDefaultValueInConstructor !== undefined)
            writer.tag(9, WireType.Varint).bool(message.noDefaultValueInConstructor);
        /* optional bool no_box = 30; */
        if (message.noBox !== undefined)
            writer.tag(30, WireType.Varint).bool(message.noBox);
        /* optional bool required = 31; */
        if (message.required !== undefined)
            writer.tag(31, WireType.Varint).bool(message.required);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message scalapb.FieldOptions
 */
export const FieldOptions = new FieldOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnumOptions$Type extends MessageType<EnumOptions> {
    constructor() {
        super("scalapb.EnumOptions", [
            { no: 1, name: "extends", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "companion_extends", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "type", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "base_annotations", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "recognized_annotations", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "unrecognized_annotations", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EnumOptions>): EnumOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.extends = [];
        message.companionExtends = [];
        message.baseAnnotations = [];
        message.recognizedAnnotations = [];
        message.unrecognizedAnnotations = [];
        if (value !== undefined)
            reflectionMergePartial<EnumOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnumOptions): EnumOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string extends */ 1:
                    message.extends.push(reader.string());
                    break;
                case /* repeated string companion_extends */ 2:
                    message.companionExtends.push(reader.string());
                    break;
                case /* optional string type */ 3:
                    message.type = reader.string();
                    break;
                case /* repeated string base_annotations */ 4:
                    message.baseAnnotations.push(reader.string());
                    break;
                case /* repeated string recognized_annotations */ 5:
                    message.recognizedAnnotations.push(reader.string());
                    break;
                case /* repeated string unrecognized_annotations */ 6:
                    message.unrecognizedAnnotations.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnumOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string extends = 1; */
        for (let i = 0; i < message.extends.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.extends[i]);
        /* repeated string companion_extends = 2; */
        for (let i = 0; i < message.companionExtends.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.companionExtends[i]);
        /* optional string type = 3; */
        if (message.type !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        /* repeated string base_annotations = 4; */
        for (let i = 0; i < message.baseAnnotations.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.baseAnnotations[i]);
        /* repeated string recognized_annotations = 5; */
        for (let i = 0; i < message.recognizedAnnotations.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.recognizedAnnotations[i]);
        /* repeated string unrecognized_annotations = 6; */
        for (let i = 0; i < message.unrecognizedAnnotations.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.unrecognizedAnnotations[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message scalapb.EnumOptions
 */
export const EnumOptions = new EnumOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnumValueOptions$Type extends MessageType<EnumValueOptions> {
    constructor() {
        super("scalapb.EnumValueOptions", [
            { no: 1, name: "extends", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "scala_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "annotations", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EnumValueOptions>): EnumValueOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.extends = [];
        message.annotations = [];
        if (value !== undefined)
            reflectionMergePartial<EnumValueOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnumValueOptions): EnumValueOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string extends */ 1:
                    message.extends.push(reader.string());
                    break;
                case /* optional string scala_name */ 2:
                    message.scalaName = reader.string();
                    break;
                case /* repeated string annotations */ 3:
                    message.annotations.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnumValueOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string extends = 1; */
        for (let i = 0; i < message.extends.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.extends[i]);
        /* optional string scala_name = 2; */
        if (message.scalaName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.scalaName);
        /* repeated string annotations = 3; */
        for (let i = 0; i < message.annotations.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.annotations[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message scalapb.EnumValueOptions
 */
export const EnumValueOptions = new EnumValueOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OneofOptions$Type extends MessageType<OneofOptions> {
    constructor() {
        super("scalapb.OneofOptions", [
            { no: 1, name: "extends", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "scala_name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OneofOptions>): OneofOptions {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.extends = [];
        if (value !== undefined)
            reflectionMergePartial<OneofOptions>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OneofOptions): OneofOptions {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string extends */ 1:
                    message.extends.push(reader.string());
                    break;
                case /* optional string scala_name */ 2:
                    message.scalaName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OneofOptions, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string extends = 1; */
        for (let i = 0; i < message.extends.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.extends[i]);
        /* optional string scala_name = 2; */
        if (message.scalaName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.scalaName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message scalapb.OneofOptions
 */
export const OneofOptions = new OneofOptions$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FieldTransformation$Type extends MessageType<FieldTransformation> {
    constructor() {
        super("scalapb.FieldTransformation", [
            { no: 1, name: "when", kind: "message", T: () => FieldDescriptorProto },
            { no: 2, name: "match_type", kind: "enum", opt: true, T: () => ["scalapb.MatchType", MatchType] },
            { no: 3, name: "set", kind: "message", T: () => FieldOptions$ }
        ]);
    }
    create(value?: PartialMessage<FieldTransformation>): FieldTransformation {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<FieldTransformation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FieldTransformation): FieldTransformation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional google.protobuf.FieldDescriptorProto when */ 1:
                    message.when = FieldDescriptorProto.internalBinaryRead(reader, reader.uint32(), options, message.when);
                    break;
                case /* optional scalapb.MatchType match_type = 2 [default = CONTAINS] */ 2:
                    message.matchType = reader.int32();
                    break;
                case /* optional google.protobuf.FieldOptions set */ 3:
                    message.set = FieldOptions$.internalBinaryRead(reader, reader.uint32(), options, message.set);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FieldTransformation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional google.protobuf.FieldDescriptorProto when = 1; */
        if (message.when)
            FieldDescriptorProto.internalBinaryWrite(message.when, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional scalapb.MatchType match_type = 2 [default = CONTAINS]; */
        if (message.matchType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.matchType);
        /* optional google.protobuf.FieldOptions set = 3; */
        if (message.set)
            FieldOptions$.internalBinaryWrite(message.set, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message scalapb.FieldTransformation
 */
export const FieldTransformation = new FieldTransformation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PreprocessorOutput$Type extends MessageType<PreprocessorOutput> {
    constructor() {
        super("scalapb.PreprocessorOutput", [
            { no: 1, name: "options_by_file", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => ScalaPbOptions } }
        ]);
    }
    create(value?: PartialMessage<PreprocessorOutput>): PreprocessorOutput {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.optionsByFile = {};
        if (value !== undefined)
            reflectionMergePartial<PreprocessorOutput>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PreprocessorOutput): PreprocessorOutput {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, scalapb.ScalaPbOptions> options_by_file */ 1:
                    this.binaryReadMap1(message.optionsByFile, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: PreprocessorOutput["optionsByFile"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof PreprocessorOutput["optionsByFile"] | undefined, val: PreprocessorOutput["optionsByFile"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = ScalaPbOptions.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for scalapb.PreprocessorOutput.options_by_file");
            }
        }
        map[key ?? ""] = val ?? ScalaPbOptions.create();
    }
    internalBinaryWrite(message: PreprocessorOutput, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, scalapb.ScalaPbOptions> options_by_file = 1; */
        for (let k of globalThis.Object.keys(message.optionsByFile)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            ScalaPbOptions.internalBinaryWrite(message.optionsByFile[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message scalapb.PreprocessorOutput
 */
export const PreprocessorOutput = new PreprocessorOutput$Type();
