// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/event_query_service.proto" (package "com.daml.ledger.api.v2", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ArchivedEvent } from "./event";
import { CreatedEvent } from "./event";
import { EventFormat } from "./transaction_filter";
/**
 * @generated from protobuf message com.daml.ledger.api.v2.GetEventsByContractIdRequest
 */
export interface GetEventsByContractIdRequest {
    /**
     * The contract id being queried.
     * Required
     *
     * @generated from protobuf field: string contract_id = 1
     */
    contractId: string;
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * The parties whose events the client expects to see.
     * The events associated with the contract id will only be returned if the requesting parties includes
     * at least one party that is a stakeholder of the event. For a definition of stakeholders see
     * https://docs.daml.com/concepts/ledger-model/ledger-privacy.html#contract-observers-and-stakeholders
     * Optional, if some parties specified, event_format needs to be unset.
     *
     * @generated from protobuf field: repeated string requesting_parties = 2
     */
    requestingParties: string[];
    /**
     * Format of the events in the result, the presentation will be of TRANSACTION_SHAPE_ACS_DELTA.
     * Optional for backwards compatibility, defaults to an EventFormat where:
     *
     * - filters_by_party is a template-wildcard filter for all requesting_parties
     * - filters_for_any_party is unset
     * - verbose is set
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.EventFormat event_format = 3
     */
    eventFormat?: EventFormat;
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.GetEventsByContractIdResponse
 */
export interface GetEventsByContractIdResponse {
    /**
     * The create event for the contract with the ``contract_id`` given in the request
     * provided it exists and has not yet been pruned.
     * Optional
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Created created = 1
     */
    created?: Created;
    /**
     * The archive event for the contract with the ``contract_id`` given in the request
     * provided such an archive event exists and it has not yet been pruned.
     * Optional
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Archived archived = 2
     */
    archived?: Archived;
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.Created
 */
export interface Created {
    /**
     * Required
     * The event as it appeared in the context of its original update (i.e. daml transaction or
     * reassignment) on this participant node. You can use its offset and node_id to find the
     * corresponding update and the node within it.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.CreatedEvent created_event = 1
     */
    createdEvent?: CreatedEvent;
    /**
     * The synchronizer which sequenced the creation of the contract
     * Required
     *
     * @generated from protobuf field: string synchronizer_id = 2
     */
    synchronizerId: string;
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.Archived
 */
export interface Archived {
    /**
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.ArchivedEvent archived_event = 1
     */
    archivedEvent?: ArchivedEvent;
    /**
     * Required
     * The synchronizer which sequenced the archival of the contract
     *
     * @generated from protobuf field: string synchronizer_id = 2
     */
    synchronizerId: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetEventsByContractIdRequest$Type extends MessageType<GetEventsByContractIdRequest> {
    constructor() {
        super("com.daml.ledger.api.v2.GetEventsByContractIdRequest", [
            { no: 1, name: "contract_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "requesting_parties", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "event_format", kind: "message", T: () => EventFormat }
        ]);
    }
    create(value?: PartialMessage<GetEventsByContractIdRequest>): GetEventsByContractIdRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contractId = "";
        message.requestingParties = [];
        if (value !== undefined)
            reflectionMergePartial<GetEventsByContractIdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEventsByContractIdRequest): GetEventsByContractIdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string contract_id */ 1:
                    message.contractId = reader.string();
                    break;
                case /* repeated string requesting_parties */ 2:
                    message.requestingParties.push(reader.string());
                    break;
                case /* com.daml.ledger.api.v2.EventFormat event_format */ 3:
                    message.eventFormat = EventFormat.internalBinaryRead(reader, reader.uint32(), options, message.eventFormat);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEventsByContractIdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string contract_id = 1; */
        if (message.contractId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.contractId);
        /* repeated string requesting_parties = 2; */
        for (let i = 0; i < message.requestingParties.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.requestingParties[i]);
        /* com.daml.ledger.api.v2.EventFormat event_format = 3; */
        if (message.eventFormat)
            EventFormat.internalBinaryWrite(message.eventFormat, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetEventsByContractIdRequest
 */
export const GetEventsByContractIdRequest = new GetEventsByContractIdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEventsByContractIdResponse$Type extends MessageType<GetEventsByContractIdResponse> {
    constructor() {
        super("com.daml.ledger.api.v2.GetEventsByContractIdResponse", [
            { no: 1, name: "created", kind: "message", T: () => Created },
            { no: 2, name: "archived", kind: "message", T: () => Archived }
        ]);
    }
    create(value?: PartialMessage<GetEventsByContractIdResponse>): GetEventsByContractIdResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetEventsByContractIdResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEventsByContractIdResponse): GetEventsByContractIdResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Created created */ 1:
                    message.created = Created.internalBinaryRead(reader, reader.uint32(), options, message.created);
                    break;
                case /* com.daml.ledger.api.v2.Archived archived */ 2:
                    message.archived = Archived.internalBinaryRead(reader, reader.uint32(), options, message.archived);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEventsByContractIdResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.Created created = 1; */
        if (message.created)
            Created.internalBinaryWrite(message.created, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.Archived archived = 2; */
        if (message.archived)
            Archived.internalBinaryWrite(message.archived, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetEventsByContractIdResponse
 */
export const GetEventsByContractIdResponse = new GetEventsByContractIdResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Created$Type extends MessageType<Created> {
    constructor() {
        super("com.daml.ledger.api.v2.Created", [
            { no: 1, name: "created_event", kind: "message", T: () => CreatedEvent },
            { no: 2, name: "synchronizer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Created>): Created {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.synchronizerId = "";
        if (value !== undefined)
            reflectionMergePartial<Created>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Created): Created {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.CreatedEvent created_event */ 1:
                    message.createdEvent = CreatedEvent.internalBinaryRead(reader, reader.uint32(), options, message.createdEvent);
                    break;
                case /* string synchronizer_id */ 2:
                    message.synchronizerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Created, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.CreatedEvent created_event = 1; */
        if (message.createdEvent)
            CreatedEvent.internalBinaryWrite(message.createdEvent, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string synchronizer_id = 2; */
        if (message.synchronizerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.synchronizerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.Created
 */
export const Created = new Created$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Archived$Type extends MessageType<Archived> {
    constructor() {
        super("com.daml.ledger.api.v2.Archived", [
            { no: 1, name: "archived_event", kind: "message", T: () => ArchivedEvent },
            { no: 2, name: "synchronizer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Archived>): Archived {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.synchronizerId = "";
        if (value !== undefined)
            reflectionMergePartial<Archived>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Archived): Archived {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.ArchivedEvent archived_event */ 1:
                    message.archivedEvent = ArchivedEvent.internalBinaryRead(reader, reader.uint32(), options, message.archivedEvent);
                    break;
                case /* string synchronizer_id */ 2:
                    message.synchronizerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Archived, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.ArchivedEvent archived_event = 1; */
        if (message.archivedEvent)
            ArchivedEvent.internalBinaryWrite(message.archivedEvent, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string synchronizer_id = 2; */
        if (message.synchronizerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.synchronizerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.Archived
 */
export const Archived = new Archived$Type();
/**
 * @generated ServiceType for protobuf service com.daml.ledger.api.v2.EventQueryService
 */
export const EventQueryService = new ServiceType("com.daml.ledger.api.v2.EventQueryService", [
    { name: "GetEventsByContractId", options: {}, I: GetEventsByContractIdRequest, O: GetEventsByContractIdResponse }
]);
