// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/admin/party_management_service.proto" (package "com.daml.ledger.api.v2.admin", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { PartyManagementService } from "./party_management_service";
import type { UpdatePartyIdentityProviderIdResponse } from "./party_management_service";
import type { UpdatePartyIdentityProviderIdRequest } from "./party_management_service";
import type { UpdatePartyDetailsResponse } from "./party_management_service";
import type { UpdatePartyDetailsRequest } from "./party_management_service";
import type { AllocatePartyResponse } from "./party_management_service";
import type { AllocatePartyRequest } from "./party_management_service";
import type { ListKnownPartiesResponse } from "./party_management_service";
import type { ListKnownPartiesRequest } from "./party_management_service";
import type { GetPartiesResponse } from "./party_management_service";
import type { GetPartiesRequest } from "./party_management_service";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { GetParticipantIdResponse } from "./party_management_service";
import type { GetParticipantIdRequest } from "./party_management_service";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * This service allows inspecting the party management state of the ledger known to the participant
 * and managing the participant-local party metadata.
 *
 * The authorization rules for its RPCs are specified on the ``<RpcName>Request``
 * messages as boolean expressions over these facts:
 *
 * 1. ``HasRight(r)`` denoting whether the authenticated user has right ``r`` and
 * 2. ``IsAuthenticatedIdentityProviderAdmin(idp)`` denoting whether ``idp`` is equal to the ``identity_provider_id``
 *    of the authenticated user and the user has an IdentityProviderAdmin right.
 *
 * If `identity_provider_id` is set to an empty string, then it's effectively set to the value of access token's 'iss' field if that is provided.
 * If `identity_provider_id` remains an empty string, the default identity provider will be assumed.
 *
 * The fields of request messages (and sub-messages) are marked either as ``Optional`` or ``Required``:
 *
 * 1. ``Optional`` denoting the client may leave the field unset when sending a request.
 * 2. ``Required`` denoting the client must set the field to a non-default value when sending a request.
 *
 * A party details resource is described by the ``PartyDetails`` message,
 * A party details resource, once it has been created, can be modified using the ``UpdatePartyDetails`` RPC.
 * The only fields that can be modified are those marked as ``Modifiable``.
 *
 * @generated from protobuf service com.daml.ledger.api.v2.admin.PartyManagementService
 */
export interface IPartyManagementServiceClient {
    /**
     * Return the identifier of the participant.
     * All horizontally scaled replicas should return the same id.
     * daml-on-kv-ledger: returns an identifier supplied on command line at launch time
     * canton: returns globally unique identifier of the participant
     *
     * @generated from protobuf rpc: GetParticipantId
     */
    getParticipantId(input: GetParticipantIdRequest, options?: RpcOptions): UnaryCall<GetParticipantIdRequest, GetParticipantIdResponse>;
    /**
     * Get the party details of the given parties. Only known parties will be
     * returned in the list.
     *
     * @generated from protobuf rpc: GetParties
     */
    getParties(input: GetPartiesRequest, options?: RpcOptions): UnaryCall<GetPartiesRequest, GetPartiesResponse>;
    /**
     * List the parties known by the participant.
     * The list returned contains parties whose ledger access is facilitated by
     * the participant and the ones maintained elsewhere.
     *
     * @generated from protobuf rpc: ListKnownParties
     */
    listKnownParties(input: ListKnownPartiesRequest, options?: RpcOptions): UnaryCall<ListKnownPartiesRequest, ListKnownPartiesResponse>;
    /**
     * Allocates a new party on a ledger and adds it to the set managed by the participant.
     * Caller specifies a party identifier suggestion, the actual identifier
     * allocated might be different and is implementation specific.
     * Caller can specify party metadata that is stored locally on the participant.
     * This call may:
     *
     * - Succeed, in which case the actual allocated identifier is visible in
     *   the response.
     * - Respond with a gRPC error
     *
     * daml-on-kv-ledger: suggestion's uniqueness is checked by the validators in
     * the consensus layer and call rejected if the identifier is already present.
     * canton: completely different globally unique identifier is allocated.
     * Behind the scenes calls to an internal protocol are made. As that protocol
     * is richer than the surface protocol, the arguments take implicit values
     * The party identifier suggestion must be a valid party name. Party names are required to be non-empty US-ASCII strings built from letters, digits, space,
     * colon, minus and underscore limited to 255 chars
     *
     * @generated from protobuf rpc: AllocateParty
     */
    allocateParty(input: AllocatePartyRequest, options?: RpcOptions): UnaryCall<AllocatePartyRequest, AllocatePartyResponse>;
    /**
     * Update selected modifiable participant-local attributes of a party details resource.
     * Can update the participant's local information for local parties.
     *
     * @generated from protobuf rpc: UpdatePartyDetails
     */
    updatePartyDetails(input: UpdatePartyDetailsRequest, options?: RpcOptions): UnaryCall<UpdatePartyDetailsRequest, UpdatePartyDetailsResponse>;
    /**
     * Update the assignment of a party from one IDP to another.
     *
     * @generated from protobuf rpc: UpdatePartyIdentityProviderId
     */
    updatePartyIdentityProviderId(input: UpdatePartyIdentityProviderIdRequest, options?: RpcOptions): UnaryCall<UpdatePartyIdentityProviderIdRequest, UpdatePartyIdentityProviderIdResponse>;
}
/**
 * This service allows inspecting the party management state of the ledger known to the participant
 * and managing the participant-local party metadata.
 *
 * The authorization rules for its RPCs are specified on the ``<RpcName>Request``
 * messages as boolean expressions over these facts:
 *
 * 1. ``HasRight(r)`` denoting whether the authenticated user has right ``r`` and
 * 2. ``IsAuthenticatedIdentityProviderAdmin(idp)`` denoting whether ``idp`` is equal to the ``identity_provider_id``
 *    of the authenticated user and the user has an IdentityProviderAdmin right.
 *
 * If `identity_provider_id` is set to an empty string, then it's effectively set to the value of access token's 'iss' field if that is provided.
 * If `identity_provider_id` remains an empty string, the default identity provider will be assumed.
 *
 * The fields of request messages (and sub-messages) are marked either as ``Optional`` or ``Required``:
 *
 * 1. ``Optional`` denoting the client may leave the field unset when sending a request.
 * 2. ``Required`` denoting the client must set the field to a non-default value when sending a request.
 *
 * A party details resource is described by the ``PartyDetails`` message,
 * A party details resource, once it has been created, can be modified using the ``UpdatePartyDetails`` RPC.
 * The only fields that can be modified are those marked as ``Modifiable``.
 *
 * @generated from protobuf service com.daml.ledger.api.v2.admin.PartyManagementService
 */
export class PartyManagementServiceClient implements IPartyManagementServiceClient, ServiceInfo {
    typeName = PartyManagementService.typeName;
    methods = PartyManagementService.methods;
    options = PartyManagementService.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * Return the identifier of the participant.
     * All horizontally scaled replicas should return the same id.
     * daml-on-kv-ledger: returns an identifier supplied on command line at launch time
     * canton: returns globally unique identifier of the participant
     *
     * @generated from protobuf rpc: GetParticipantId
     */
    getParticipantId(input: GetParticipantIdRequest, options?: RpcOptions): UnaryCall<GetParticipantIdRequest, GetParticipantIdResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetParticipantIdRequest, GetParticipantIdResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Get the party details of the given parties. Only known parties will be
     * returned in the list.
     *
     * @generated from protobuf rpc: GetParties
     */
    getParties(input: GetPartiesRequest, options?: RpcOptions): UnaryCall<GetPartiesRequest, GetPartiesResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<GetPartiesRequest, GetPartiesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * List the parties known by the participant.
     * The list returned contains parties whose ledger access is facilitated by
     * the participant and the ones maintained elsewhere.
     *
     * @generated from protobuf rpc: ListKnownParties
     */
    listKnownParties(input: ListKnownPartiesRequest, options?: RpcOptions): UnaryCall<ListKnownPartiesRequest, ListKnownPartiesResponse> {
        const method = this.methods[2], opt = this._transport.mergeOptions(options);
        return stackIntercept<ListKnownPartiesRequest, ListKnownPartiesResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Allocates a new party on a ledger and adds it to the set managed by the participant.
     * Caller specifies a party identifier suggestion, the actual identifier
     * allocated might be different and is implementation specific.
     * Caller can specify party metadata that is stored locally on the participant.
     * This call may:
     *
     * - Succeed, in which case the actual allocated identifier is visible in
     *   the response.
     * - Respond with a gRPC error
     *
     * daml-on-kv-ledger: suggestion's uniqueness is checked by the validators in
     * the consensus layer and call rejected if the identifier is already present.
     * canton: completely different globally unique identifier is allocated.
     * Behind the scenes calls to an internal protocol are made. As that protocol
     * is richer than the surface protocol, the arguments take implicit values
     * The party identifier suggestion must be a valid party name. Party names are required to be non-empty US-ASCII strings built from letters, digits, space,
     * colon, minus and underscore limited to 255 chars
     *
     * @generated from protobuf rpc: AllocateParty
     */
    allocateParty(input: AllocatePartyRequest, options?: RpcOptions): UnaryCall<AllocatePartyRequest, AllocatePartyResponse> {
        const method = this.methods[3], opt = this._transport.mergeOptions(options);
        return stackIntercept<AllocatePartyRequest, AllocatePartyResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Update selected modifiable participant-local attributes of a party details resource.
     * Can update the participant's local information for local parties.
     *
     * @generated from protobuf rpc: UpdatePartyDetails
     */
    updatePartyDetails(input: UpdatePartyDetailsRequest, options?: RpcOptions): UnaryCall<UpdatePartyDetailsRequest, UpdatePartyDetailsResponse> {
        const method = this.methods[4], opt = this._transport.mergeOptions(options);
        return stackIntercept<UpdatePartyDetailsRequest, UpdatePartyDetailsResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * Update the assignment of a party from one IDP to another.
     *
     * @generated from protobuf rpc: UpdatePartyIdentityProviderId
     */
    updatePartyIdentityProviderId(input: UpdatePartyIdentityProviderIdRequest, options?: RpcOptions): UnaryCall<UpdatePartyIdentityProviderIdRequest, UpdatePartyIdentityProviderIdResponse> {
        const method = this.methods[5], opt = this._transport.mergeOptions(options);
        return stackIntercept<UpdatePartyIdentityProviderIdRequest, UpdatePartyIdentityProviderIdResponse>("unary", this._transport, method, opt, input);
    }
}
