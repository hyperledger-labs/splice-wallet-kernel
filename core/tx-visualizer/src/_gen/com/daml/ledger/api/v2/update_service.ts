// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/update_service.proto" (package "com.daml.ledger.api.v2", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { TransactionFormat } from "./transaction_filter";
import { TransactionTree } from "./transaction";
import { TopologyTransaction } from "./topology_transaction";
import { OffsetCheckpoint } from "./offset_checkpoint";
import { Reassignment } from "./reassignment";
import { Transaction } from "./transaction";
import { UpdateFormat } from "./transaction_filter";
import { TransactionFilter } from "./transaction_filter";
/**
 * @generated from protobuf message com.daml.ledger.api.v2.GetUpdatesRequest
 */
export interface GetUpdatesRequest {
    /**
     * Beginning of the requested ledger section (non-negative integer).
     * The response will only contain transactions whose offset is strictly greater than this.
     * If zero, the stream will start from the beginning of the ledger.
     * If positive, the streaming will start after this absolute offset.
     * If the ledger has been pruned, this parameter must be specified and be greater than the pruning offset.
     *
     * @generated from protobuf field: int64 begin_exclusive = 1
     */
    beginExclusive: bigint;
    /**
     * End of the requested ledger section.
     * The response will only contain transactions whose offset is less than or equal to this.
     * Optional, if empty, the stream will not terminate.
     * If specified, the stream will terminate after this absolute offset (positive integer) is reached.
     *
     * @generated from protobuf field: optional int64 end_inclusive = 2
     */
    endInclusive?: bigint;
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * Requesting parties with template filters.
     * Template filters must be empty for GetUpdateTrees requests.
     * Optional for backwards compatibility, if defined update_format must be unset
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.TransactionFilter filter = 3
     */
    filter?: TransactionFilter;
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
     * In particular, setting the verbose flag to true triggers the ledger to include labels, record and variant type ids
     * for record fields.
     * Optional for backwards compatibility, if defined update_format must be unset
     *
     * @generated from protobuf field: bool verbose = 4
     */
    verbose: boolean;
    /**
     * Must be unset for GetUpdateTrees request.
     * Optional for backwards compatibility for GetUpdates request: defaults to an UpdateFormat where:
     *
     * - include_transactions.event_format.filters_by_party = the filter.filters_by_party on this request
     * - include_transactions.event_format.filters_for_any_party = the filter.filters_for_any_party on this request
     * - include_transactions.event_format.verbose = the same flag specified on this request
     * - include_transactions.transaction_shape = TRANSACTION_SHAPE_ACS_DELTA
     * - include_reassignments.filter = the same filter specified on this request
     * - include_reassignments.verbose = the same flag specified on this request
     * - include_topology_events.include_participant_authorization_events.parties = all the parties specified in filter
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.UpdateFormat update_format = 5
     */
    updateFormat?: UpdateFormat;
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.GetUpdatesResponse
 */
export interface GetUpdatesResponse {
    /**
     * The update that matches the filter in the request.
     *
     * @generated from protobuf oneof: update
     */
    update: {
        oneofKind: "transaction";
        /**
         * @generated from protobuf field: com.daml.ledger.api.v2.Transaction transaction = 1
         */
        transaction: Transaction;
    } | {
        oneofKind: "reassignment";
        /**
         * @generated from protobuf field: com.daml.ledger.api.v2.Reassignment reassignment = 2
         */
        reassignment: Reassignment;
    } | {
        oneofKind: "offsetCheckpoint";
        /**
         * @generated from protobuf field: com.daml.ledger.api.v2.OffsetCheckpoint offset_checkpoint = 3
         */
        offsetCheckpoint: OffsetCheckpoint;
    } | {
        oneofKind: "topologyTransaction";
        /**
         * @generated from protobuf field: com.daml.ledger.api.v2.TopologyTransaction topology_transaction = 4
         */
        topologyTransaction: TopologyTransaction;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.GetUpdateTreesResponse
 */
export interface GetUpdateTreesResponse {
    /**
     * The update that matches the filter in the request.
     *
     * @generated from protobuf oneof: update
     */
    update: {
        oneofKind: "transactionTree";
        /**
         * @generated from protobuf field: com.daml.ledger.api.v2.TransactionTree transaction_tree = 1
         */
        transactionTree: TransactionTree;
    } | {
        oneofKind: "reassignment";
        /**
         * @generated from protobuf field: com.daml.ledger.api.v2.Reassignment reassignment = 2
         */
        reassignment: Reassignment;
    } | {
        oneofKind: "offsetCheckpoint";
        /**
         * @generated from protobuf field: com.daml.ledger.api.v2.OffsetCheckpoint offset_checkpoint = 3
         */
        offsetCheckpoint: OffsetCheckpoint;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.GetTransactionByOffsetRequest
 */
export interface GetTransactionByOffsetRequest {
    /**
     * The offset of the transaction being looked up.
     * Must be a valid absolute offset (positive integer).
     * Required
     *
     * @generated from protobuf field: int64 offset = 1
     */
    offset: bigint;
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * The parties whose events the client expects to see.
     * Events that are not visible for the parties in this collection will not be present in the response.
     * Each element must be a valid PartyIdString (as described in ``value.proto``).
     * Must be set for GetTransactionTreeByOffset request.
     * Optional for backwards compatibility for GetTransactionByOffset request: if defined transaction_format must be
     * unset (falling back to defaults).
     *
     * @generated from protobuf field: repeated string requesting_parties = 2
     */
    requestingParties: string[];
    /**
     * Must be unset for GetTransactionTreeByOffset request.
     * Optional for GetTransactionByOffset request for backwards compatibility: defaults to a TransactionFormat, where:
     *
     * - event_format.filters_by_party will have template-wildcard filters for all the requesting_parties
     * - event_format.filters_for_any_party is unset
     * - event_format.verbose = true
     * - transaction_shape = TRANSACTION_SHAPE_ACS_DELTA
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.TransactionFormat transaction_format = 3
     */
    transactionFormat?: TransactionFormat;
}
/**
 * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.GetTransactionByIdRequest
 */
export interface GetTransactionByIdRequest {
    /**
     * The ID of a particular transaction.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string update_id = 1
     */
    updateId: string;
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * The parties whose events the client expects to see.
     * Events that are not visible for the parties in this collection will not be present in the response.
     * Each element must be a valid PartyIdString (as described in ``value.proto``).
     * Must be set for GetTransactionTreeById request.
     * Optional for backwards compatibility for GetTransactionById request: if defined transaction_format must be
     * unset (falling back to defaults).
     *
     * @generated from protobuf field: repeated string requesting_parties = 2
     */
    requestingParties: string[];
    /**
     * Must be unset for GetTransactionTreeById request.
     * Optional for GetTransactionById request for backwards compatibility: defaults to a transaction_format, where:
     *
     * - event_format.filters_by_party will have template-wildcard filters for all the requesting_parties
     * - event_format.filters_for_any_party is unset
     * - event_format.verbose = true
     * - transaction_shape = TRANSACTION_SHAPE_ACS_DELTA
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.TransactionFormat transaction_format = 3
     */
    transactionFormat?: TransactionFormat;
}
/**
 * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.GetTransactionTreeResponse
 */
export interface GetTransactionTreeResponse {
    /**
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.TransactionTree transaction = 1
     */
    transaction?: TransactionTree;
}
/**
 * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.GetTransactionResponse
 */
export interface GetTransactionResponse {
    /**
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Transaction transaction = 1
     */
    transaction?: Transaction;
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.GetUpdateByOffsetRequest
 */
export interface GetUpdateByOffsetRequest {
    /**
     * The offset of the update being looked up.
     * Must be a valid absolute offset (positive integer).
     * Required
     *
     * @generated from protobuf field: int64 offset = 1
     */
    offset: bigint;
    /**
     * The format for the update.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.UpdateFormat update_format = 2
     */
    updateFormat?: UpdateFormat;
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.GetUpdateByIdRequest
 */
export interface GetUpdateByIdRequest {
    /**
     * The ID of a particular update.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string update_id = 1
     */
    updateId: string;
    /**
     * The format for the update.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.UpdateFormat update_format = 2
     */
    updateFormat?: UpdateFormat;
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.GetUpdateResponse
 */
export interface GetUpdateResponse {
    /**
     * The update that matches the filter in the request.
     *
     * @generated from protobuf oneof: update
     */
    update: {
        oneofKind: "transaction";
        /**
         * @generated from protobuf field: com.daml.ledger.api.v2.Transaction transaction = 1
         */
        transaction: Transaction;
    } | {
        oneofKind: "reassignment";
        /**
         * @generated from protobuf field: com.daml.ledger.api.v2.Reassignment reassignment = 2
         */
        reassignment: Reassignment;
    } | {
        oneofKind: "topologyTransaction";
        /**
         * @generated from protobuf field: com.daml.ledger.api.v2.TopologyTransaction topology_transaction = 3
         */
        topologyTransaction: TopologyTransaction;
    } | {
        oneofKind: undefined;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class GetUpdatesRequest$Type extends MessageType<GetUpdatesRequest> {
    constructor() {
        super("com.daml.ledger.api.v2.GetUpdatesRequest", [
            { no: 1, name: "begin_exclusive", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "end_inclusive", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "filter", kind: "message", T: () => TransactionFilter },
            { no: 4, name: "verbose", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "update_format", kind: "message", T: () => UpdateFormat }
        ]);
    }
    create(value?: PartialMessage<GetUpdatesRequest>): GetUpdatesRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.beginExclusive = 0n;
        message.verbose = false;
        if (value !== undefined)
            reflectionMergePartial<GetUpdatesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUpdatesRequest): GetUpdatesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 begin_exclusive */ 1:
                    message.beginExclusive = reader.int64().toBigInt();
                    break;
                case /* optional int64 end_inclusive */ 2:
                    message.endInclusive = reader.int64().toBigInt();
                    break;
                case /* com.daml.ledger.api.v2.TransactionFilter filter */ 3:
                    message.filter = TransactionFilter.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* bool verbose */ 4:
                    message.verbose = reader.bool();
                    break;
                case /* com.daml.ledger.api.v2.UpdateFormat update_format */ 5:
                    message.updateFormat = UpdateFormat.internalBinaryRead(reader, reader.uint32(), options, message.updateFormat);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUpdatesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 begin_exclusive = 1; */
        if (message.beginExclusive !== 0n)
            writer.tag(1, WireType.Varint).int64(message.beginExclusive);
        /* optional int64 end_inclusive = 2; */
        if (message.endInclusive !== undefined)
            writer.tag(2, WireType.Varint).int64(message.endInclusive);
        /* com.daml.ledger.api.v2.TransactionFilter filter = 3; */
        if (message.filter)
            TransactionFilter.internalBinaryWrite(message.filter, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool verbose = 4; */
        if (message.verbose !== false)
            writer.tag(4, WireType.Varint).bool(message.verbose);
        /* com.daml.ledger.api.v2.UpdateFormat update_format = 5; */
        if (message.updateFormat)
            UpdateFormat.internalBinaryWrite(message.updateFormat, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetUpdatesRequest
 */
export const GetUpdatesRequest = new GetUpdatesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUpdatesResponse$Type extends MessageType<GetUpdatesResponse> {
    constructor() {
        super("com.daml.ledger.api.v2.GetUpdatesResponse", [
            { no: 1, name: "transaction", kind: "message", oneof: "update", T: () => Transaction },
            { no: 2, name: "reassignment", kind: "message", oneof: "update", T: () => Reassignment },
            { no: 3, name: "offset_checkpoint", kind: "message", oneof: "update", T: () => OffsetCheckpoint },
            { no: 4, name: "topology_transaction", kind: "message", oneof: "update", T: () => TopologyTransaction }
        ]);
    }
    create(value?: PartialMessage<GetUpdatesResponse>): GetUpdatesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.update = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<GetUpdatesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUpdatesResponse): GetUpdatesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Transaction transaction */ 1:
                    message.update = {
                        oneofKind: "transaction",
                        transaction: Transaction.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).transaction)
                    };
                    break;
                case /* com.daml.ledger.api.v2.Reassignment reassignment */ 2:
                    message.update = {
                        oneofKind: "reassignment",
                        reassignment: Reassignment.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).reassignment)
                    };
                    break;
                case /* com.daml.ledger.api.v2.OffsetCheckpoint offset_checkpoint */ 3:
                    message.update = {
                        oneofKind: "offsetCheckpoint",
                        offsetCheckpoint: OffsetCheckpoint.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).offsetCheckpoint)
                    };
                    break;
                case /* com.daml.ledger.api.v2.TopologyTransaction topology_transaction */ 4:
                    message.update = {
                        oneofKind: "topologyTransaction",
                        topologyTransaction: TopologyTransaction.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).topologyTransaction)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUpdatesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.Transaction transaction = 1; */
        if (message.update.oneofKind === "transaction")
            Transaction.internalBinaryWrite(message.update.transaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.Reassignment reassignment = 2; */
        if (message.update.oneofKind === "reassignment")
            Reassignment.internalBinaryWrite(message.update.reassignment, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.OffsetCheckpoint offset_checkpoint = 3; */
        if (message.update.oneofKind === "offsetCheckpoint")
            OffsetCheckpoint.internalBinaryWrite(message.update.offsetCheckpoint, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.TopologyTransaction topology_transaction = 4; */
        if (message.update.oneofKind === "topologyTransaction")
            TopologyTransaction.internalBinaryWrite(message.update.topologyTransaction, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetUpdatesResponse
 */
export const GetUpdatesResponse = new GetUpdatesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUpdateTreesResponse$Type extends MessageType<GetUpdateTreesResponse> {
    constructor() {
        super("com.daml.ledger.api.v2.GetUpdateTreesResponse", [
            { no: 1, name: "transaction_tree", kind: "message", oneof: "update", T: () => TransactionTree },
            { no: 2, name: "reassignment", kind: "message", oneof: "update", T: () => Reassignment },
            { no: 3, name: "offset_checkpoint", kind: "message", oneof: "update", T: () => OffsetCheckpoint }
        ]);
    }
    create(value?: PartialMessage<GetUpdateTreesResponse>): GetUpdateTreesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.update = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<GetUpdateTreesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUpdateTreesResponse): GetUpdateTreesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.TransactionTree transaction_tree */ 1:
                    message.update = {
                        oneofKind: "transactionTree",
                        transactionTree: TransactionTree.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).transactionTree)
                    };
                    break;
                case /* com.daml.ledger.api.v2.Reassignment reassignment */ 2:
                    message.update = {
                        oneofKind: "reassignment",
                        reassignment: Reassignment.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).reassignment)
                    };
                    break;
                case /* com.daml.ledger.api.v2.OffsetCheckpoint offset_checkpoint */ 3:
                    message.update = {
                        oneofKind: "offsetCheckpoint",
                        offsetCheckpoint: OffsetCheckpoint.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).offsetCheckpoint)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUpdateTreesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.TransactionTree transaction_tree = 1; */
        if (message.update.oneofKind === "transactionTree")
            TransactionTree.internalBinaryWrite(message.update.transactionTree, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.Reassignment reassignment = 2; */
        if (message.update.oneofKind === "reassignment")
            Reassignment.internalBinaryWrite(message.update.reassignment, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.OffsetCheckpoint offset_checkpoint = 3; */
        if (message.update.oneofKind === "offsetCheckpoint")
            OffsetCheckpoint.internalBinaryWrite(message.update.offsetCheckpoint, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetUpdateTreesResponse
 */
export const GetUpdateTreesResponse = new GetUpdateTreesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTransactionByOffsetRequest$Type extends MessageType<GetTransactionByOffsetRequest> {
    constructor() {
        super("com.daml.ledger.api.v2.GetTransactionByOffsetRequest", [
            { no: 1, name: "offset", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "requesting_parties", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "transaction_format", kind: "message", T: () => TransactionFormat }
        ]);
    }
    create(value?: PartialMessage<GetTransactionByOffsetRequest>): GetTransactionByOffsetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.offset = 0n;
        message.requestingParties = [];
        if (value !== undefined)
            reflectionMergePartial<GetTransactionByOffsetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTransactionByOffsetRequest): GetTransactionByOffsetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 offset */ 1:
                    message.offset = reader.int64().toBigInt();
                    break;
                case /* repeated string requesting_parties */ 2:
                    message.requestingParties.push(reader.string());
                    break;
                case /* com.daml.ledger.api.v2.TransactionFormat transaction_format */ 3:
                    message.transactionFormat = TransactionFormat.internalBinaryRead(reader, reader.uint32(), options, message.transactionFormat);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTransactionByOffsetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 offset = 1; */
        if (message.offset !== 0n)
            writer.tag(1, WireType.Varint).int64(message.offset);
        /* repeated string requesting_parties = 2; */
        for (let i = 0; i < message.requestingParties.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.requestingParties[i]);
        /* com.daml.ledger.api.v2.TransactionFormat transaction_format = 3; */
        if (message.transactionFormat)
            TransactionFormat.internalBinaryWrite(message.transactionFormat, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetTransactionByOffsetRequest
 */
export const GetTransactionByOffsetRequest = new GetTransactionByOffsetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTransactionByIdRequest$Type extends MessageType<GetTransactionByIdRequest> {
    constructor() {
        super("com.daml.ledger.api.v2.GetTransactionByIdRequest", [
            { no: 1, name: "update_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "requesting_parties", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "transaction_format", kind: "message", T: () => TransactionFormat }
        ]);
    }
    create(value?: PartialMessage<GetTransactionByIdRequest>): GetTransactionByIdRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updateId = "";
        message.requestingParties = [];
        if (value !== undefined)
            reflectionMergePartial<GetTransactionByIdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTransactionByIdRequest): GetTransactionByIdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string update_id */ 1:
                    message.updateId = reader.string();
                    break;
                case /* repeated string requesting_parties */ 2:
                    message.requestingParties.push(reader.string());
                    break;
                case /* com.daml.ledger.api.v2.TransactionFormat transaction_format */ 3:
                    message.transactionFormat = TransactionFormat.internalBinaryRead(reader, reader.uint32(), options, message.transactionFormat);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTransactionByIdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string update_id = 1; */
        if (message.updateId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.updateId);
        /* repeated string requesting_parties = 2; */
        for (let i = 0; i < message.requestingParties.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.requestingParties[i]);
        /* com.daml.ledger.api.v2.TransactionFormat transaction_format = 3; */
        if (message.transactionFormat)
            TransactionFormat.internalBinaryWrite(message.transactionFormat, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetTransactionByIdRequest
 */
export const GetTransactionByIdRequest = new GetTransactionByIdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTransactionTreeResponse$Type extends MessageType<GetTransactionTreeResponse> {
    constructor() {
        super("com.daml.ledger.api.v2.GetTransactionTreeResponse", [
            { no: 1, name: "transaction", kind: "message", T: () => TransactionTree }
        ]);
    }
    create(value?: PartialMessage<GetTransactionTreeResponse>): GetTransactionTreeResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTransactionTreeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTransactionTreeResponse): GetTransactionTreeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.TransactionTree transaction */ 1:
                    message.transaction = TransactionTree.internalBinaryRead(reader, reader.uint32(), options, message.transaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTransactionTreeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.TransactionTree transaction = 1; */
        if (message.transaction)
            TransactionTree.internalBinaryWrite(message.transaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetTransactionTreeResponse
 */
export const GetTransactionTreeResponse = new GetTransactionTreeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTransactionResponse$Type extends MessageType<GetTransactionResponse> {
    constructor() {
        super("com.daml.ledger.api.v2.GetTransactionResponse", [
            { no: 1, name: "transaction", kind: "message", T: () => Transaction }
        ]);
    }
    create(value?: PartialMessage<GetTransactionResponse>): GetTransactionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTransactionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTransactionResponse): GetTransactionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Transaction transaction */ 1:
                    message.transaction = Transaction.internalBinaryRead(reader, reader.uint32(), options, message.transaction);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTransactionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.Transaction transaction = 1; */
        if (message.transaction)
            Transaction.internalBinaryWrite(message.transaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetTransactionResponse
 */
export const GetTransactionResponse = new GetTransactionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUpdateByOffsetRequest$Type extends MessageType<GetUpdateByOffsetRequest> {
    constructor() {
        super("com.daml.ledger.api.v2.GetUpdateByOffsetRequest", [
            { no: 1, name: "offset", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "update_format", kind: "message", T: () => UpdateFormat }
        ]);
    }
    create(value?: PartialMessage<GetUpdateByOffsetRequest>): GetUpdateByOffsetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.offset = 0n;
        if (value !== undefined)
            reflectionMergePartial<GetUpdateByOffsetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUpdateByOffsetRequest): GetUpdateByOffsetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 offset */ 1:
                    message.offset = reader.int64().toBigInt();
                    break;
                case /* com.daml.ledger.api.v2.UpdateFormat update_format */ 2:
                    message.updateFormat = UpdateFormat.internalBinaryRead(reader, reader.uint32(), options, message.updateFormat);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUpdateByOffsetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 offset = 1; */
        if (message.offset !== 0n)
            writer.tag(1, WireType.Varint).int64(message.offset);
        /* com.daml.ledger.api.v2.UpdateFormat update_format = 2; */
        if (message.updateFormat)
            UpdateFormat.internalBinaryWrite(message.updateFormat, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetUpdateByOffsetRequest
 */
export const GetUpdateByOffsetRequest = new GetUpdateByOffsetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUpdateByIdRequest$Type extends MessageType<GetUpdateByIdRequest> {
    constructor() {
        super("com.daml.ledger.api.v2.GetUpdateByIdRequest", [
            { no: 1, name: "update_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "update_format", kind: "message", T: () => UpdateFormat }
        ]);
    }
    create(value?: PartialMessage<GetUpdateByIdRequest>): GetUpdateByIdRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updateId = "";
        if (value !== undefined)
            reflectionMergePartial<GetUpdateByIdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUpdateByIdRequest): GetUpdateByIdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string update_id */ 1:
                    message.updateId = reader.string();
                    break;
                case /* com.daml.ledger.api.v2.UpdateFormat update_format */ 2:
                    message.updateFormat = UpdateFormat.internalBinaryRead(reader, reader.uint32(), options, message.updateFormat);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUpdateByIdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string update_id = 1; */
        if (message.updateId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.updateId);
        /* com.daml.ledger.api.v2.UpdateFormat update_format = 2; */
        if (message.updateFormat)
            UpdateFormat.internalBinaryWrite(message.updateFormat, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetUpdateByIdRequest
 */
export const GetUpdateByIdRequest = new GetUpdateByIdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetUpdateResponse$Type extends MessageType<GetUpdateResponse> {
    constructor() {
        super("com.daml.ledger.api.v2.GetUpdateResponse", [
            { no: 1, name: "transaction", kind: "message", oneof: "update", T: () => Transaction },
            { no: 2, name: "reassignment", kind: "message", oneof: "update", T: () => Reassignment },
            { no: 3, name: "topology_transaction", kind: "message", oneof: "update", T: () => TopologyTransaction }
        ]);
    }
    create(value?: PartialMessage<GetUpdateResponse>): GetUpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.update = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<GetUpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetUpdateResponse): GetUpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Transaction transaction */ 1:
                    message.update = {
                        oneofKind: "transaction",
                        transaction: Transaction.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).transaction)
                    };
                    break;
                case /* com.daml.ledger.api.v2.Reassignment reassignment */ 2:
                    message.update = {
                        oneofKind: "reassignment",
                        reassignment: Reassignment.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).reassignment)
                    };
                    break;
                case /* com.daml.ledger.api.v2.TopologyTransaction topology_transaction */ 3:
                    message.update = {
                        oneofKind: "topologyTransaction",
                        topologyTransaction: TopologyTransaction.internalBinaryRead(reader, reader.uint32(), options, (message.update as any).topologyTransaction)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetUpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.Transaction transaction = 1; */
        if (message.update.oneofKind === "transaction")
            Transaction.internalBinaryWrite(message.update.transaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.Reassignment reassignment = 2; */
        if (message.update.oneofKind === "reassignment")
            Reassignment.internalBinaryWrite(message.update.reassignment, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.TopologyTransaction topology_transaction = 3; */
        if (message.update.oneofKind === "topologyTransaction")
            TopologyTransaction.internalBinaryWrite(message.update.topologyTransaction, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetUpdateResponse
 */
export const GetUpdateResponse = new GetUpdateResponse$Type();
/**
 * @generated ServiceType for protobuf service com.daml.ledger.api.v2.UpdateService
 */
export const UpdateService = new ServiceType("com.daml.ledger.api.v2.UpdateService", [
    { name: "GetUpdates", serverStreaming: true, options: {}, I: GetUpdatesRequest, O: GetUpdatesResponse },
    { name: "GetUpdateTrees", serverStreaming: true, options: {}, I: GetUpdatesRequest, O: GetUpdateTreesResponse },
    { name: "GetTransactionTreeByOffset", options: {}, I: GetTransactionByOffsetRequest, O: GetTransactionTreeResponse },
    { name: "GetTransactionTreeById", options: {}, I: GetTransactionByIdRequest, O: GetTransactionTreeResponse },
    { name: "GetTransactionByOffset", options: {}, I: GetTransactionByOffsetRequest, O: GetTransactionResponse },
    { name: "GetTransactionById", options: {}, I: GetTransactionByIdRequest, O: GetTransactionResponse },
    { name: "GetUpdateByOffset", options: {}, I: GetUpdateByOffsetRequest, O: GetUpdateResponse },
    { name: "GetUpdateById", options: {}, I: GetUpdateByIdRequest, O: GetUpdateResponse }
]);
