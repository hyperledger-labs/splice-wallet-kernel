// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/value.proto" (package "com.daml.ledger.api.v2", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
//
// IMPORTANT: The comments for the messages and fields are used to produce Sphinx documentation in Canton.
//            Make sure to check if they're valid and the output is as expected.
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Empty } from "../../../../../google/protobuf/empty";
/**
 * Encodes values that the ledger accepts as command arguments and emits as contract arguments.
 *
 * The values encoding use different classes of non-empty strings as identifiers. Those classes are
 * defined as follows:
 *
 * - NameStrings are strings with length <= 1000 that match the regexp ``[A-Za-z\$_][A-Za-z0-9\$_]*``.
 * - PackageIdStrings are strings with length <= 64 that match the regexp ``[A-Za-z0-9\-_ ]+``.
 * - PartyIdStrings are strings with length <= 255 that match the regexp ``[A-Za-z0-9:\-_ ]+``.
 * - LedgerStrings are strings with length <= 255 that match the regexp ``[A-Za-z0-9#:\-_/ ]+``.
 * - UserIdStrings are strings with length <= 128 that match the regexp ``[a-zA-Z0-9@^$.!`\-#+'~_|:]+``.
 *
 *
 * @generated from protobuf message com.daml.ledger.api.v2.Value
 */
export interface Value {
    /**
     * @generated from protobuf oneof: sum
     */
    sum: {
        oneofKind: "unit";
        /**
         * This value is used for example for choices that don't take any arguments.
         *
         * @generated from protobuf field: google.protobuf.Empty unit = 1
         */
        unit: Empty;
    } | {
        oneofKind: "bool";
        /**
         * True or false.
         *
         * @generated from protobuf field: bool bool = 2
         */
        bool: boolean;
    } | {
        oneofKind: "int64";
        /**
         * @generated from protobuf field: sint64 int64 = 3 [jstype = JS_STRING]
         */
        int64: string;
    } | {
        oneofKind: "date";
        /**
         * Days since the unix epoch. Can go backwards. Limited from
         * 0001-01-01 to 9999-12-31, also to be compatible with
         * https://www.ietf.org/rfc/rfc3339.txt
         *
         * @generated from protobuf field: int32 date = 4
         */
        date: number;
    } | {
        oneofKind: "timestamp";
        /**
         * Microseconds since the UNIX epoch. Can go backwards. Fixed
         * since the vast majority of values will be greater than
         * 2^28, since currently the number of microseconds since the
         * epoch is greater than that. Range: 0001-01-01T00:00:00Z to
         * 9999-12-31T23:59:59.999999Z, so that we can convert to/from
         * https://www.ietf.org/rfc/rfc3339.txt
         *
         * @generated from protobuf field: sfixed64 timestamp = 5 [jstype = JS_STRING]
         */
        timestamp: string;
    } | {
        oneofKind: "numeric";
        /**
         * A Numeric, that is a decimal value with precision 38 (at most 38 significant digits) and a
         * scale between 0 and 37 (significant digits on the right of the decimal point).
         * The field has to match the regex
         *
         * .. code-block:: none
         *
         *   [+-]?\d{1,38}(.\d{0,37})?
         *
         * and should be representable by a Numeric without loss of precision.
         *
         * @generated from protobuf field: string numeric = 6
         */
        numeric: string;
    } | {
        oneofKind: "party";
        /**
         * An agent operating on the ledger.
         * Must be a valid PartyIdString.
         *
         * @generated from protobuf field: string party = 7
         */
        party: string;
    } | {
        oneofKind: "text";
        /**
         * A string.
         *
         * @generated from protobuf field: string text = 8
         */
        text: string;
    } | {
        oneofKind: "contractId";
        /**
         * Identifier of an on-ledger contract. Commands which reference an unknown or already archived contract ID will fail.
         * Must be a valid LedgerString.
         *
         * @generated from protobuf field: string contract_id = 9
         */
        contractId: string;
    } | {
        oneofKind: "optional";
        /**
         * The Optional type, None or Some
         *
         * @generated from protobuf field: com.daml.ledger.api.v2.Optional optional = 10
         */
        optional: Optional;
    } | {
        oneofKind: "list";
        /**
         * Represents a homogeneous list of values.
         *
         * @generated from protobuf field: com.daml.ledger.api.v2.List list = 11
         */
        list: List;
    } | {
        oneofKind: "textMap";
        /**
         * The TextMap type
         *
         * @generated from protobuf field: com.daml.ledger.api.v2.TextMap text_map = 12
         */
        textMap: TextMap;
    } | {
        oneofKind: "genMap";
        /**
         * The GenMap type
         *
         * @generated from protobuf field: com.daml.ledger.api.v2.GenMap gen_map = 13
         */
        genMap: GenMap;
    } | {
        oneofKind: "record";
        /**
         * @generated from protobuf field: com.daml.ledger.api.v2.Record record = 14
         */
        record: Record;
    } | {
        oneofKind: "variant";
        /**
         * @generated from protobuf field: com.daml.ledger.api.v2.Variant variant = 15
         */
        variant: Variant;
    } | {
        oneofKind: "enum";
        /**
         * The Enum type
         *
         * @generated from protobuf field: com.daml.ledger.api.v2.Enum enum = 16
         */
        enum: Enum;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Contains nested values.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.Record
 */
export interface Record {
    /**
     * Omitted from the transaction stream when verbose streaming is not enabled.
     * Optional when submitting commands.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier record_id = 1
     */
    recordId?: Identifier;
    /**
     * The nested values of the record.
     * Required
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.RecordField fields = 2
     */
    fields: RecordField[];
}
/**
 * A named nested value within a record.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.RecordField
 */
export interface RecordField {
    /**
     * When reading a transaction stream, it's omitted if verbose streaming is not enabled.
     * When submitting a command, it's optional:
     *
     * - if all keys within a single record are present, the order in which fields appear does not matter. however, each key must appear exactly once.
     * - if any of the keys within a single record are omitted, the order of fields MUST match the order of declaration in the Daml template.
     *
     * Must be a valid NameString
     *
     * @generated from protobuf field: string label = 1
     */
    label: string;
    /**
     * A nested value of a record.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Value value = 2
     */
    value?: Value;
}
/**
 * Unique identifier of an entity.
 * Throughout this API, the following terminology is being used:
 *
 *   - if a Daml package-id is encoded in the package_id field, it is referred to as using a "package-id reference format"
 *   - if a Daml package-name is encoded in the package_id field, it is referred to as using a "package-name reference format"
 *
 * @generated from protobuf message com.daml.ledger.api.v2.Identifier
 */
export interface Identifier {
    /**
     * Generally, the identifier of the Daml package that contains the entity.
     * When encoding a package-id, it must be a valid PackageIdString.
     *
     * The field is overloaded to also be able to contain the package-name of the Daml package.
     * This is supported if the entity referenced is either an interface or template.
     * When representing the Daml package-name, the encoding is of form `#<package-name>`
     * where `#` (not a valid package-id character)
     * is used as a discriminator for signalling a package-name encoding.
     *
     * Required
     *
     * @generated from protobuf field: string package_id = 1
     */
    packageId: string;
    /**
     * The dot-separated module name of the identifier.
     * Required
     *
     * @generated from protobuf field: string module_name = 2
     */
    moduleName: string;
    /**
     * The dot-separated name of the entity (e.g. record, template, ...) within the module.
     * Required
     *
     * @generated from protobuf field: string entity_name = 3
     */
    entityName: string;
}
/**
 * A value with alternative representations.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.Variant
 */
export interface Variant {
    /**
     * Omitted from the transaction stream when verbose streaming is not enabled.
     * Optional when submitting commands.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier variant_id = 1
     */
    variantId?: Identifier;
    /**
     * Determines which of the Variant's alternatives is encoded in this message.
     * Must be a valid NameString.
     * Required
     *
     * @generated from protobuf field: string constructor = 2
     */
    constructor: string;
    /**
     * The value encoded within the Variant.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Value value = 3
     */
    value?: Value;
}
/**
 * A value with finite set of alternative representations.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.Enum
 */
export interface Enum {
    /**
     * Omitted from the transaction stream when verbose streaming is not enabled.
     * Optional when submitting commands.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier enum_id = 1
     */
    enumId?: Identifier;
    /**
     * Determines which of the Variant's alternatives is encoded in this message.
     * Must be a valid NameString.
     * Required
     *
     * @generated from protobuf field: string constructor = 2
     */
    constructor: string;
}
/**
 * A homogenous collection of values.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.List
 */
export interface List {
    /**
     * The elements must all be of the same concrete value type.
     * Optional
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.Value elements = 1
     */
    elements: Value[];
}
/**
 * Corresponds to Java's Optional type, Scala's Option, and Haskell's Maybe.
 * The reason why we need to wrap this in an additional ``message`` is that we
 * need to be able to encode the ``None`` case in the ``Value`` oneof.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.Optional
 */
export interface Optional {
    /**
     * @generated from protobuf field: com.daml.ledger.api.v2.Value value = 1
     */
    value?: Value; // optional
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.TextMap
 */
export interface TextMap {
    /**
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.TextMap.Entry entries = 1
     */
    entries: TextMap_Entry[];
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.TextMap.Entry
 */
export interface TextMap_Entry {
    /**
     * @generated from protobuf field: string key = 1
     */
    key: string;
    /**
     * @generated from protobuf field: com.daml.ledger.api.v2.Value value = 2
     */
    value?: Value;
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.GenMap
 */
export interface GenMap {
    /**
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.GenMap.Entry entries = 1
     */
    entries: GenMap_Entry[];
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.GenMap.Entry
 */
export interface GenMap_Entry {
    /**
     * @generated from protobuf field: com.daml.ledger.api.v2.Value key = 1
     */
    key?: Value;
    /**
     * @generated from protobuf field: com.daml.ledger.api.v2.Value value = 2
     */
    value?: Value;
}
// @generated message type with reflection information, may provide speed optimized methods
class Value$Type extends MessageType<Value> {
    constructor() {
        super("com.daml.ledger.api.v2.Value", [
            { no: 1, name: "unit", kind: "message", oneof: "sum", T: () => Empty },
            { no: 2, name: "bool", kind: "scalar", oneof: "sum", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "int64", kind: "scalar", oneof: "sum", T: 18 /*ScalarType.SINT64*/ },
            { no: 4, name: "date", kind: "scalar", oneof: "sum", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "timestamp", kind: "scalar", oneof: "sum", T: 16 /*ScalarType.SFIXED64*/ },
            { no: 6, name: "numeric", kind: "scalar", oneof: "sum", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "party", kind: "scalar", oneof: "sum", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "text", kind: "scalar", oneof: "sum", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "contract_id", kind: "scalar", oneof: "sum", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "optional", kind: "message", oneof: "sum", T: () => Optional },
            { no: 11, name: "list", kind: "message", oneof: "sum", T: () => List },
            { no: 12, name: "text_map", kind: "message", oneof: "sum", T: () => TextMap },
            { no: 13, name: "gen_map", kind: "message", oneof: "sum", T: () => GenMap },
            { no: 14, name: "record", kind: "message", oneof: "sum", T: () => Record },
            { no: 15, name: "variant", kind: "message", oneof: "sum", T: () => Variant },
            { no: 16, name: "enum", kind: "message", oneof: "sum", T: () => Enum }
        ]);
    }
    create(value?: PartialMessage<Value>): Value {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sum = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Value>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Value): Value {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Empty unit */ 1:
                    message.sum = {
                        oneofKind: "unit",
                        unit: Empty.internalBinaryRead(reader, reader.uint32(), options, (message.sum as any).unit)
                    };
                    break;
                case /* bool bool */ 2:
                    message.sum = {
                        oneofKind: "bool",
                        bool: reader.bool()
                    };
                    break;
                case /* sint64 int64 = 3 [jstype = JS_STRING] */ 3:
                    message.sum = {
                        oneofKind: "int64",
                        int64: reader.sint64().toString()
                    };
                    break;
                case /* int32 date */ 4:
                    message.sum = {
                        oneofKind: "date",
                        date: reader.int32()
                    };
                    break;
                case /* sfixed64 timestamp = 5 [jstype = JS_STRING] */ 5:
                    message.sum = {
                        oneofKind: "timestamp",
                        timestamp: reader.sfixed64().toString()
                    };
                    break;
                case /* string numeric */ 6:
                    message.sum = {
                        oneofKind: "numeric",
                        numeric: reader.string()
                    };
                    break;
                case /* string party */ 7:
                    message.sum = {
                        oneofKind: "party",
                        party: reader.string()
                    };
                    break;
                case /* string text */ 8:
                    message.sum = {
                        oneofKind: "text",
                        text: reader.string()
                    };
                    break;
                case /* string contract_id */ 9:
                    message.sum = {
                        oneofKind: "contractId",
                        contractId: reader.string()
                    };
                    break;
                case /* com.daml.ledger.api.v2.Optional optional */ 10:
                    message.sum = {
                        oneofKind: "optional",
                        optional: Optional.internalBinaryRead(reader, reader.uint32(), options, (message.sum as any).optional)
                    };
                    break;
                case /* com.daml.ledger.api.v2.List list */ 11:
                    message.sum = {
                        oneofKind: "list",
                        list: List.internalBinaryRead(reader, reader.uint32(), options, (message.sum as any).list)
                    };
                    break;
                case /* com.daml.ledger.api.v2.TextMap text_map */ 12:
                    message.sum = {
                        oneofKind: "textMap",
                        textMap: TextMap.internalBinaryRead(reader, reader.uint32(), options, (message.sum as any).textMap)
                    };
                    break;
                case /* com.daml.ledger.api.v2.GenMap gen_map */ 13:
                    message.sum = {
                        oneofKind: "genMap",
                        genMap: GenMap.internalBinaryRead(reader, reader.uint32(), options, (message.sum as any).genMap)
                    };
                    break;
                case /* com.daml.ledger.api.v2.Record record */ 14:
                    message.sum = {
                        oneofKind: "record",
                        record: Record.internalBinaryRead(reader, reader.uint32(), options, (message.sum as any).record)
                    };
                    break;
                case /* com.daml.ledger.api.v2.Variant variant */ 15:
                    message.sum = {
                        oneofKind: "variant",
                        variant: Variant.internalBinaryRead(reader, reader.uint32(), options, (message.sum as any).variant)
                    };
                    break;
                case /* com.daml.ledger.api.v2.Enum enum */ 16:
                    message.sum = {
                        oneofKind: "enum",
                        enum: Enum.internalBinaryRead(reader, reader.uint32(), options, (message.sum as any).enum)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Value, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Empty unit = 1; */
        if (message.sum.oneofKind === "unit")
            Empty.internalBinaryWrite(message.sum.unit, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool bool = 2; */
        if (message.sum.oneofKind === "bool")
            writer.tag(2, WireType.Varint).bool(message.sum.bool);
        /* sint64 int64 = 3 [jstype = JS_STRING]; */
        if (message.sum.oneofKind === "int64")
            writer.tag(3, WireType.Varint).sint64(message.sum.int64);
        /* int32 date = 4; */
        if (message.sum.oneofKind === "date")
            writer.tag(4, WireType.Varint).int32(message.sum.date);
        /* sfixed64 timestamp = 5 [jstype = JS_STRING]; */
        if (message.sum.oneofKind === "timestamp")
            writer.tag(5, WireType.Bit64).sfixed64(message.sum.timestamp);
        /* string numeric = 6; */
        if (message.sum.oneofKind === "numeric")
            writer.tag(6, WireType.LengthDelimited).string(message.sum.numeric);
        /* string party = 7; */
        if (message.sum.oneofKind === "party")
            writer.tag(7, WireType.LengthDelimited).string(message.sum.party);
        /* string text = 8; */
        if (message.sum.oneofKind === "text")
            writer.tag(8, WireType.LengthDelimited).string(message.sum.text);
        /* string contract_id = 9; */
        if (message.sum.oneofKind === "contractId")
            writer.tag(9, WireType.LengthDelimited).string(message.sum.contractId);
        /* com.daml.ledger.api.v2.Optional optional = 10; */
        if (message.sum.oneofKind === "optional")
            Optional.internalBinaryWrite(message.sum.optional, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.List list = 11; */
        if (message.sum.oneofKind === "list")
            List.internalBinaryWrite(message.sum.list, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.TextMap text_map = 12; */
        if (message.sum.oneofKind === "textMap")
            TextMap.internalBinaryWrite(message.sum.textMap, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.GenMap gen_map = 13; */
        if (message.sum.oneofKind === "genMap")
            GenMap.internalBinaryWrite(message.sum.genMap, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.Record record = 14; */
        if (message.sum.oneofKind === "record")
            Record.internalBinaryWrite(message.sum.record, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.Variant variant = 15; */
        if (message.sum.oneofKind === "variant")
            Variant.internalBinaryWrite(message.sum.variant, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.Enum enum = 16; */
        if (message.sum.oneofKind === "enum")
            Enum.internalBinaryWrite(message.sum.enum, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.Value
 */
export const Value = new Value$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Record$Type extends MessageType<Record> {
    constructor() {
        super("com.daml.ledger.api.v2.Record", [
            { no: 1, name: "record_id", kind: "message", T: () => Identifier },
            { no: 2, name: "fields", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RecordField }
        ]);
    }
    create(value?: PartialMessage<Record>): Record {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.fields = [];
        if (value !== undefined)
            reflectionMergePartial<Record>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Record): Record {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Identifier record_id */ 1:
                    message.recordId = Identifier.internalBinaryRead(reader, reader.uint32(), options, message.recordId);
                    break;
                case /* repeated com.daml.ledger.api.v2.RecordField fields */ 2:
                    message.fields.push(RecordField.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Record, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.Identifier record_id = 1; */
        if (message.recordId)
            Identifier.internalBinaryWrite(message.recordId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated com.daml.ledger.api.v2.RecordField fields = 2; */
        for (let i = 0; i < message.fields.length; i++)
            RecordField.internalBinaryWrite(message.fields[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.Record
 */
export const Record = new Record$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RecordField$Type extends MessageType<RecordField> {
    constructor() {
        super("com.daml.ledger.api.v2.RecordField", [
            { no: 1, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => Value }
        ]);
    }
    create(value?: PartialMessage<RecordField>): RecordField {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.label = "";
        if (value !== undefined)
            reflectionMergePartial<RecordField>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RecordField): RecordField {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string label */ 1:
                    message.label = reader.string();
                    break;
                case /* com.daml.ledger.api.v2.Value value */ 2:
                    message.value = Value.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RecordField, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string label = 1; */
        if (message.label !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.label);
        /* com.daml.ledger.api.v2.Value value = 2; */
        if (message.value)
            Value.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.RecordField
 */
export const RecordField = new RecordField$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Identifier$Type extends MessageType<Identifier> {
    constructor() {
        super("com.daml.ledger.api.v2.Identifier", [
            { no: 1, name: "package_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "module_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "entity_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Identifier>): Identifier {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.packageId = "";
        message.moduleName = "";
        message.entityName = "";
        if (value !== undefined)
            reflectionMergePartial<Identifier>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Identifier): Identifier {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string package_id */ 1:
                    message.packageId = reader.string();
                    break;
                case /* string module_name */ 2:
                    message.moduleName = reader.string();
                    break;
                case /* string entity_name */ 3:
                    message.entityName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Identifier, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string package_id = 1; */
        if (message.packageId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.packageId);
        /* string module_name = 2; */
        if (message.moduleName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.moduleName);
        /* string entity_name = 3; */
        if (message.entityName !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.entityName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.Identifier
 */
export const Identifier = new Identifier$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Variant$Type extends MessageType<Variant> {
    constructor() {
        super("com.daml.ledger.api.v2.Variant", [
            { no: 1, name: "variant_id", kind: "message", T: () => Identifier },
            { no: 2, name: "constructor", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "message", T: () => Value }
        ]);
    }
    create(value?: PartialMessage<Variant>): Variant {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.constructor = "";
        if (value !== undefined)
            reflectionMergePartial<Variant>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Variant): Variant {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Identifier variant_id */ 1:
                    message.variantId = Identifier.internalBinaryRead(reader, reader.uint32(), options, message.variantId);
                    break;
                case /* string constructor */ 2:
                    message.constructor = reader.string();
                    break;
                case /* com.daml.ledger.api.v2.Value value */ 3:
                    message.value = Value.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Variant, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.Identifier variant_id = 1; */
        if (message.variantId)
            Identifier.internalBinaryWrite(message.variantId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string constructor = 2; */
        if (message.constructor !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.constructor);
        /* com.daml.ledger.api.v2.Value value = 3; */
        if (message.value)
            Value.internalBinaryWrite(message.value, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.Variant
 */
export const Variant = new Variant$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Enum$Type extends MessageType<Enum> {
    constructor() {
        super("com.daml.ledger.api.v2.Enum", [
            { no: 1, name: "enum_id", kind: "message", T: () => Identifier },
            { no: 2, name: "constructor", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Enum>): Enum {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.constructor = "";
        if (value !== undefined)
            reflectionMergePartial<Enum>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Enum): Enum {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Identifier enum_id */ 1:
                    message.enumId = Identifier.internalBinaryRead(reader, reader.uint32(), options, message.enumId);
                    break;
                case /* string constructor */ 2:
                    message.constructor = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Enum, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.Identifier enum_id = 1; */
        if (message.enumId)
            Identifier.internalBinaryWrite(message.enumId, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string constructor = 2; */
        if (message.constructor !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.constructor);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.Enum
 */
export const Enum = new Enum$Type();
// @generated message type with reflection information, may provide speed optimized methods
class List$Type extends MessageType<List> {
    constructor() {
        super("com.daml.ledger.api.v2.List", [
            { no: 1, name: "elements", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Value }
        ]);
    }
    create(value?: PartialMessage<List>): List {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.elements = [];
        if (value !== undefined)
            reflectionMergePartial<List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: List): List {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.daml.ledger.api.v2.Value elements */ 1:
                    message.elements.push(Value.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.daml.ledger.api.v2.Value elements = 1; */
        for (let i = 0; i < message.elements.length; i++)
            Value.internalBinaryWrite(message.elements[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.List
 */
export const List = new List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Optional$Type extends MessageType<Optional> {
    constructor() {
        super("com.daml.ledger.api.v2.Optional", [
            { no: 1, name: "value", kind: "message", T: () => Value }
        ]);
    }
    create(value?: PartialMessage<Optional>): Optional {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Optional>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Optional): Optional {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Value value */ 1:
                    message.value = Value.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Optional, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.Value value = 1; */
        if (message.value)
            Value.internalBinaryWrite(message.value, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.Optional
 */
export const Optional = new Optional$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TextMap$Type extends MessageType<TextMap> {
    constructor() {
        super("com.daml.ledger.api.v2.TextMap", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TextMap_Entry }
        ]);
    }
    create(value?: PartialMessage<TextMap>): TextMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<TextMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TextMap): TextMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.daml.ledger.api.v2.TextMap.Entry entries */ 1:
                    message.entries.push(TextMap_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TextMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.daml.ledger.api.v2.TextMap.Entry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            TextMap_Entry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.TextMap
 */
export const TextMap = new TextMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TextMap_Entry$Type extends MessageType<TextMap_Entry> {
    constructor() {
        super("com.daml.ledger.api.v2.TextMap.Entry", [
            { no: 1, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", T: () => Value }
        ]);
    }
    create(value?: PartialMessage<TextMap_Entry>): TextMap_Entry {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.key = "";
        if (value !== undefined)
            reflectionMergePartial<TextMap_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TextMap_Entry): TextMap_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string key */ 1:
                    message.key = reader.string();
                    break;
                case /* com.daml.ledger.api.v2.Value value */ 2:
                    message.value = Value.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TextMap_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string key = 1; */
        if (message.key !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.key);
        /* com.daml.ledger.api.v2.Value value = 2; */
        if (message.value)
            Value.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.TextMap.Entry
 */
export const TextMap_Entry = new TextMap_Entry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenMap$Type extends MessageType<GenMap> {
    constructor() {
        super("com.daml.ledger.api.v2.GenMap", [
            { no: 1, name: "entries", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => GenMap_Entry }
        ]);
    }
    create(value?: PartialMessage<GenMap>): GenMap {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.entries = [];
        if (value !== undefined)
            reflectionMergePartial<GenMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenMap): GenMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.daml.ledger.api.v2.GenMap.Entry entries */ 1:
                    message.entries.push(GenMap_Entry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.daml.ledger.api.v2.GenMap.Entry entries = 1; */
        for (let i = 0; i < message.entries.length; i++)
            GenMap_Entry.internalBinaryWrite(message.entries[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GenMap
 */
export const GenMap = new GenMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GenMap_Entry$Type extends MessageType<GenMap_Entry> {
    constructor() {
        super("com.daml.ledger.api.v2.GenMap.Entry", [
            { no: 1, name: "key", kind: "message", T: () => Value },
            { no: 2, name: "value", kind: "message", T: () => Value }
        ]);
    }
    create(value?: PartialMessage<GenMap_Entry>): GenMap_Entry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GenMap_Entry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GenMap_Entry): GenMap_Entry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Value key */ 1:
                    message.key = Value.internalBinaryRead(reader, reader.uint32(), options, message.key);
                    break;
                case /* com.daml.ledger.api.v2.Value value */ 2:
                    message.value = Value.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GenMap_Entry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.Value key = 1; */
        if (message.key)
            Value.internalBinaryWrite(message.key, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.Value value = 2; */
        if (message.value)
            Value.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GenMap.Entry
 */
export const GenMap_Entry = new GenMap_Entry$Type();
