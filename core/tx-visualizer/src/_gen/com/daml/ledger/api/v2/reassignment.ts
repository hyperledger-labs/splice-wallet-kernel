// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/reassignment.proto" (package "com.daml.ledger.api.v2", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { CreatedEvent } from "./event";
import { Identifier } from "./value";
import { Timestamp } from "../../../../../google/protobuf/timestamp";
import { TraceContext } from "./trace_context";
/**
 * Complete view of an on-ledger reassignment.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.Reassignment
 */
export interface Reassignment {
    /**
     * Assigned by the server. Useful for correlating logs.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string update_id = 1
     */
    updateId: string;
    /**
     * The ID of the command which resulted in this reassignment. Missing for everyone except the submitting party on the submitting participant.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Optional
     *
     * @generated from protobuf field: string command_id = 2
     */
    commandId: string;
    /**
     * The workflow ID used in reassignment command submission. Only set if the ``workflow_id`` for the command was set.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Optional
     *
     * @generated from protobuf field: string workflow_id = 3
     */
    workflowId: string;
    /**
     * The participant's offset. The details of this field are described in ``community/ledger-api/README.md``.
     * Required, must be a valid absolute offset (positive integer).
     *
     * @generated from protobuf field: int64 offset = 4
     */
    offset: bigint;
    /**
     * The collection of reassignment events. Required.
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.ReassignmentEvent events = 5
     */
    events: ReassignmentEvent[];
    /**
     * Optional; ledger API trace context
     *
     * The trace context transported in this message corresponds to the trace context supplied
     * by the client application in a HTTP2 header of the original command submission.
     * We typically use a header to transfer this type of information. Here we use message
     * body, because it is used in gRPC streams which do not support per message headers.
     * This field will be populated with the trace context contained in the original submission.
     * If that was not provided, a unique ledger-api-server generated trace context will be used
     * instead.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.TraceContext trace_context = 6
     */
    traceContext?: TraceContext;
    /**
     * The time at which the reassignment was recorded. The record time refers to the source/target
     * synchronizer for an unassign/assign event respectively.
     * Required
     *
     * @generated from protobuf field: google.protobuf.Timestamp record_time = 7
     */
    recordTime?: Timestamp;
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.ReassignmentEvent
 */
export interface ReassignmentEvent {
    /**
     * @generated from protobuf oneof: event
     */
    event: {
        oneofKind: "unassigned";
        /**
         * @generated from protobuf field: com.daml.ledger.api.v2.UnassignedEvent unassigned = 1
         */
        unassigned: UnassignedEvent;
    } | {
        oneofKind: "assigned";
        /**
         * @generated from protobuf field: com.daml.ledger.api.v2.AssignedEvent assigned = 2
         */
        assigned: AssignedEvent;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Records that a contract has been unassigned, and it becomes unusable on the source synchronizer
 *
 * @generated from protobuf message com.daml.ledger.api.v2.UnassignedEvent
 */
export interface UnassignedEvent {
    /**
     * The ID of the unassignment. This needs to be used as an input for a assign ReassignmentCommand.
     * For one contract the (unassign_id, source synchronizer) pair is unique.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string unassign_id = 1
     */
    unassignId: string;
    /**
     * The ID of the reassigned contract.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string contract_id = 2
     */
    contractId: string;
    /**
     * The template of the reassigned contract.
     * The identifier uses the package-id reference format.
     *
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier template_id = 3
     */
    templateId?: Identifier;
    /**
     * The ID of the source synchronizer
     * Must be a valid synchronizer id
     * Required
     *
     * @generated from protobuf field: string source = 4
     */
    source: string;
    /**
     * The ID of the target synchronizer
     * Must be a valid synchronizer id
     * Required
     *
     * @generated from protobuf field: string target = 5
     */
    target: string;
    /**
     * Party on whose behalf the unassign command was executed.
     * Empty if the unassignment happened offline via the repair service.
     * Must be a valid PartyIdString (as described in ``value.proto``).
     * Optional
     *
     * @generated from protobuf field: string submitter = 6
     */
    submitter: string;
    /**
     * Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
     * with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
     * equals zero.
     * Required
     *
     * @generated from protobuf field: uint64 reassignment_counter = 7
     */
    reassignmentCounter: bigint;
    /**
     * Assignment exclusivity
     * Before this time (measured on the target synchronizer), only the submitter of the unassignment can initiate the assignment
     * Defined for reassigning participants.
     * Optional
     *
     * @generated from protobuf field: google.protobuf.Timestamp assignment_exclusivity = 8
     */
    assignmentExclusivity?: Timestamp;
    /**
     * The parties that are notified of this event.
     * Required
     *
     * @generated from protobuf field: repeated string witness_parties = 9
     */
    witnessParties: string[];
    /**
     * The package name of the contract.
     * Required
     *
     * @generated from protobuf field: string package_name = 10
     */
    packageName: string;
    /**
     * The offset of origin.
     * Offsets are managed by the participant nodes.
     * Reassignments can thus NOT be assumed to have the same offsets on different participant nodes.
     * Required, it is a valid absolute offset (positive integer)
     *
     * @generated from protobuf field: int64 offset = 11
     */
    offset: bigint;
    /**
     * The position of this event in the originating reassignment.
     * Node IDs are not necessarily equal across participants,
     * as these may see different projections/parts of reassignments.
     * Required, must be valid node ID (non-negative integer)
     *
     * @generated from protobuf field: int32 node_id = 12
     */
    nodeId: number;
}
/**
 * Records that a contract has been assigned, and it can be used on the target synchronizer.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.AssignedEvent
 */
export interface AssignedEvent {
    /**
     * The ID of the source synchronizer.
     * Must be a valid synchronizer id.
     * Required
     *
     * @generated from protobuf field: string source = 1
     */
    source: string;
    /**
     * The ID of the target synchronizer.
     * Must be a valid synchronizer id.
     * Required
     *
     * @generated from protobuf field: string target = 2
     */
    target: string;
    /**
     * The ID from the unassigned event.
     * For correlation capabilities.
     * For one contract the (unassign_id, source synchronizer) pair is unique.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string unassign_id = 3
     */
    unassignId: string;
    /**
     * Party on whose behalf the assign command was executed.
     * Empty if the assignment happened offline via the repair service.
     * Must be a valid PartyIdString (as described in ``value.proto``).
     * Optional
     *
     * @generated from protobuf field: string submitter = 4
     */
    submitter: string;
    /**
     * Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
     * with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
     * equals zero.
     * Required
     *
     * @generated from protobuf field: uint64 reassignment_counter = 5
     */
    reassignmentCounter: bigint;
    /**
     * Required
     * The offset of this event refers to the offset of the assignment,
     * while the node_id is the index of within the batch.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.CreatedEvent created_event = 6
     */
    createdEvent?: CreatedEvent;
}
// @generated message type with reflection information, may provide speed optimized methods
class Reassignment$Type extends MessageType<Reassignment> {
    constructor() {
        super("com.daml.ledger.api.v2.Reassignment", [
            { no: 1, name: "update_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "command_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "workflow_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "offset", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ReassignmentEvent },
            { no: 6, name: "trace_context", kind: "message", T: () => TraceContext },
            { no: 7, name: "record_time", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Reassignment>): Reassignment {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updateId = "";
        message.commandId = "";
        message.workflowId = "";
        message.offset = 0n;
        message.events = [];
        if (value !== undefined)
            reflectionMergePartial<Reassignment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Reassignment): Reassignment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string update_id */ 1:
                    message.updateId = reader.string();
                    break;
                case /* string command_id */ 2:
                    message.commandId = reader.string();
                    break;
                case /* string workflow_id */ 3:
                    message.workflowId = reader.string();
                    break;
                case /* int64 offset */ 4:
                    message.offset = reader.int64().toBigInt();
                    break;
                case /* repeated com.daml.ledger.api.v2.ReassignmentEvent events */ 5:
                    message.events.push(ReassignmentEvent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* com.daml.ledger.api.v2.TraceContext trace_context */ 6:
                    message.traceContext = TraceContext.internalBinaryRead(reader, reader.uint32(), options, message.traceContext);
                    break;
                case /* google.protobuf.Timestamp record_time */ 7:
                    message.recordTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.recordTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Reassignment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string update_id = 1; */
        if (message.updateId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.updateId);
        /* string command_id = 2; */
        if (message.commandId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.commandId);
        /* string workflow_id = 3; */
        if (message.workflowId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.workflowId);
        /* int64 offset = 4; */
        if (message.offset !== 0n)
            writer.tag(4, WireType.Varint).int64(message.offset);
        /* repeated com.daml.ledger.api.v2.ReassignmentEvent events = 5; */
        for (let i = 0; i < message.events.length; i++)
            ReassignmentEvent.internalBinaryWrite(message.events[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.TraceContext trace_context = 6; */
        if (message.traceContext)
            TraceContext.internalBinaryWrite(message.traceContext, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp record_time = 7; */
        if (message.recordTime)
            Timestamp.internalBinaryWrite(message.recordTime, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.Reassignment
 */
export const Reassignment = new Reassignment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReassignmentEvent$Type extends MessageType<ReassignmentEvent> {
    constructor() {
        super("com.daml.ledger.api.v2.ReassignmentEvent", [
            { no: 1, name: "unassigned", kind: "message", oneof: "event", T: () => UnassignedEvent },
            { no: 2, name: "assigned", kind: "message", oneof: "event", T: () => AssignedEvent }
        ]);
    }
    create(value?: PartialMessage<ReassignmentEvent>): ReassignmentEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.event = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ReassignmentEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReassignmentEvent): ReassignmentEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.UnassignedEvent unassigned */ 1:
                    message.event = {
                        oneofKind: "unassigned",
                        unassigned: UnassignedEvent.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).unassigned)
                    };
                    break;
                case /* com.daml.ledger.api.v2.AssignedEvent assigned */ 2:
                    message.event = {
                        oneofKind: "assigned",
                        assigned: AssignedEvent.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).assigned)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReassignmentEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.UnassignedEvent unassigned = 1; */
        if (message.event.oneofKind === "unassigned")
            UnassignedEvent.internalBinaryWrite(message.event.unassigned, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.AssignedEvent assigned = 2; */
        if (message.event.oneofKind === "assigned")
            AssignedEvent.internalBinaryWrite(message.event.assigned, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.ReassignmentEvent
 */
export const ReassignmentEvent = new ReassignmentEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnassignedEvent$Type extends MessageType<UnassignedEvent> {
    constructor() {
        super("com.daml.ledger.api.v2.UnassignedEvent", [
            { no: 1, name: "unassign_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "template_id", kind: "message", T: () => Identifier },
            { no: 4, name: "source", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "target", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "submitter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "reassignment_counter", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "assignment_exclusivity", kind: "message", T: () => Timestamp },
            { no: 9, name: "witness_parties", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "package_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "offset", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 12, name: "node_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UnassignedEvent>): UnassignedEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.unassignId = "";
        message.contractId = "";
        message.source = "";
        message.target = "";
        message.submitter = "";
        message.reassignmentCounter = 0n;
        message.witnessParties = [];
        message.packageName = "";
        message.offset = 0n;
        message.nodeId = 0;
        if (value !== undefined)
            reflectionMergePartial<UnassignedEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnassignedEvent): UnassignedEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string unassign_id */ 1:
                    message.unassignId = reader.string();
                    break;
                case /* string contract_id */ 2:
                    message.contractId = reader.string();
                    break;
                case /* com.daml.ledger.api.v2.Identifier template_id */ 3:
                    message.templateId = Identifier.internalBinaryRead(reader, reader.uint32(), options, message.templateId);
                    break;
                case /* string source */ 4:
                    message.source = reader.string();
                    break;
                case /* string target */ 5:
                    message.target = reader.string();
                    break;
                case /* string submitter */ 6:
                    message.submitter = reader.string();
                    break;
                case /* uint64 reassignment_counter */ 7:
                    message.reassignmentCounter = reader.uint64().toBigInt();
                    break;
                case /* google.protobuf.Timestamp assignment_exclusivity */ 8:
                    message.assignmentExclusivity = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.assignmentExclusivity);
                    break;
                case /* repeated string witness_parties */ 9:
                    message.witnessParties.push(reader.string());
                    break;
                case /* string package_name */ 10:
                    message.packageName = reader.string();
                    break;
                case /* int64 offset */ 11:
                    message.offset = reader.int64().toBigInt();
                    break;
                case /* int32 node_id */ 12:
                    message.nodeId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnassignedEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string unassign_id = 1; */
        if (message.unassignId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.unassignId);
        /* string contract_id = 2; */
        if (message.contractId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contractId);
        /* com.daml.ledger.api.v2.Identifier template_id = 3; */
        if (message.templateId)
            Identifier.internalBinaryWrite(message.templateId, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string source = 4; */
        if (message.source !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.source);
        /* string target = 5; */
        if (message.target !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.target);
        /* string submitter = 6; */
        if (message.submitter !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.submitter);
        /* uint64 reassignment_counter = 7; */
        if (message.reassignmentCounter !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.reassignmentCounter);
        /* google.protobuf.Timestamp assignment_exclusivity = 8; */
        if (message.assignmentExclusivity)
            Timestamp.internalBinaryWrite(message.assignmentExclusivity, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated string witness_parties = 9; */
        for (let i = 0; i < message.witnessParties.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.witnessParties[i]);
        /* string package_name = 10; */
        if (message.packageName !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.packageName);
        /* int64 offset = 11; */
        if (message.offset !== 0n)
            writer.tag(11, WireType.Varint).int64(message.offset);
        /* int32 node_id = 12; */
        if (message.nodeId !== 0)
            writer.tag(12, WireType.Varint).int32(message.nodeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.UnassignedEvent
 */
export const UnassignedEvent = new UnassignedEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AssignedEvent$Type extends MessageType<AssignedEvent> {
    constructor() {
        super("com.daml.ledger.api.v2.AssignedEvent", [
            { no: 1, name: "source", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "target", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "unassign_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "submitter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "reassignment_counter", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "created_event", kind: "message", T: () => CreatedEvent }
        ]);
    }
    create(value?: PartialMessage<AssignedEvent>): AssignedEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.source = "";
        message.target = "";
        message.unassignId = "";
        message.submitter = "";
        message.reassignmentCounter = 0n;
        if (value !== undefined)
            reflectionMergePartial<AssignedEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AssignedEvent): AssignedEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string source */ 1:
                    message.source = reader.string();
                    break;
                case /* string target */ 2:
                    message.target = reader.string();
                    break;
                case /* string unassign_id */ 3:
                    message.unassignId = reader.string();
                    break;
                case /* string submitter */ 4:
                    message.submitter = reader.string();
                    break;
                case /* uint64 reassignment_counter */ 5:
                    message.reassignmentCounter = reader.uint64().toBigInt();
                    break;
                case /* com.daml.ledger.api.v2.CreatedEvent created_event */ 6:
                    message.createdEvent = CreatedEvent.internalBinaryRead(reader, reader.uint32(), options, message.createdEvent);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AssignedEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string source = 1; */
        if (message.source !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.source);
        /* string target = 2; */
        if (message.target !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.target);
        /* string unassign_id = 3; */
        if (message.unassignId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.unassignId);
        /* string submitter = 4; */
        if (message.submitter !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.submitter);
        /* uint64 reassignment_counter = 5; */
        if (message.reassignmentCounter !== 0n)
            writer.tag(5, WireType.Varint).uint64(message.reassignmentCounter);
        /* com.daml.ledger.api.v2.CreatedEvent created_event = 6; */
        if (message.createdEvent)
            CreatedEvent.internalBinaryWrite(message.createdEvent, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.AssignedEvent
 */
export const AssignedEvent = new AssignedEvent$Type();
