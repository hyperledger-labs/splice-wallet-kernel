// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/interactive/interactive_submission_service.proto" (package "com.daml.ledger.api.v2.interactive", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PackageReference } from "../package_reference";
import { Node } from "./transaction/v1/interactive_submission_data";
import { Create } from "./transaction/v1/interactive_submission_data";
import { Value } from "../value";
import { GlobalKey } from "./interactive_submission_common_data";
import { Timestamp } from "../../../../../../google/protobuf/timestamp";
import { Duration } from "../../../../../../google/protobuf/duration";
import { PrefetchContractKey } from "../commands";
import { DisclosedContract } from "../commands";
import { Command } from "../commands";
/**
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.PrepareSubmissionRequest
 */
export interface PrepareSubmissionRequest {
    /**
     * Uniquely identifies the participant user that prepares the transaction.
     * Must be a valid UserIdString (as described in ``value.proto``).
     * Required unless authentication is used with a user token.
     * In that case, the token's user-id will be used for the request's user_id.
     *
     * @generated from protobuf field: string user_id = 1
     */
    userId: string;
    /**
     * Uniquely identifies the command.
     * The triple (user_id, act_as, command_id) constitutes the change ID for the intended ledger change,
     * where act_as is interpreted as a set of party names.
     * The change ID can be used for matching the intended ledger changes with all their completions.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string command_id = 2
     */
    commandId: string;
    /**
     * Individual elements of this atomic command. Must be non-empty.
     * Required
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.Command commands = 3
     */
    commands: Command[];
    /**
     * Optional
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.interactive.MinLedgerTime min_ledger_time = 4
     */
    minLedgerTime?: MinLedgerTime;
    /**
     * Set of parties on whose behalf the command should be executed, if submitted.
     * If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
     * to **read** (not act) on behalf of each of the given parties. This is because this RPC merely prepares a transaction
     * and does not execute it. Therefore read authorization is sufficient even for actAs parties.
     * Note: This may change, and more specific authorization scope may be introduced in the future.
     * Each element must be a valid PartyIdString (as described in ``value.proto``).
     * Required, must be non-empty.
     *
     * @generated from protobuf field: repeated string act_as = 5
     */
    actAs: string[];
    /**
     * Set of parties on whose behalf (in addition to all parties listed in ``act_as``) contracts can be retrieved.
     * This affects Daml operations such as ``fetch``, ``fetchByKey``, ``lookupByKey``, ``exercise``, and ``exerciseByKey``.
     * Note: A command can only use contracts that are visible to at least
     * one of the parties in ``act_as`` or ``read_as``. This visibility check is independent from the Daml authorization
     * rules for fetch operations.
     * If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
     * to read contract data on behalf of each of the given parties.
     * Optional
     *
     * @generated from protobuf field: repeated string read_as = 6
     */
    readAs: string[];
    /**
     * Additional contracts used to resolve contract & contract key lookups.
     * Optional
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.DisclosedContract disclosed_contracts = 7
     */
    disclosedContracts: DisclosedContract[];
    /**
     * Must be a valid synchronizer id
     * Required
     *
     * @generated from protobuf field: string synchronizer_id = 8
     */
    synchronizerId: string;
    /**
     * The package-id selection preference of the client for resolving
     * package names and interface instances in command submission and interpretation
     *
     * @generated from protobuf field: repeated string package_id_selection_preference = 9
     */
    packageIdSelectionPreference: string[];
    /**
     * When true, the response will contain additional details on how the transaction was encoded and hashed
     * This can be useful for troubleshooting of hash mismatches. Should only be used for debugging.
     *
     * @generated from protobuf field: bool verbose_hashing = 10
     */
    verboseHashing: boolean;
    /**
     * Fetches the contract keys into the caches to speed up the command processing.
     * Should only contain contract keys that are expected to be resolved during interpretation of the commands.
     * Keys of disclosed contracts do not need prefetching.
     *
     * Optional
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.PrefetchContractKey prefetch_contract_keys = 15
     */
    prefetchContractKeys: PrefetchContractKey[];
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.PrepareSubmissionResponse
 */
export interface PrepareSubmissionResponse {
    /**
     * The interpreted transaction, it represents the ledger changes necessary to execute the commands specified in the request.
     * Clients MUST display the content of the transaction to the user for them to validate before signing the hash if the preparing participant is not trusted.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.interactive.PreparedTransaction prepared_transaction = 1
     */
    preparedTransaction?: PreparedTransaction;
    /**
     * Hash of the transaction, this is what needs to be signed by the party to authorize the transaction.
     * Only provided for convenience, clients MUST recompute the hash from the raw transaction if the preparing participant is not trusted.
     * May be removed in future versions
     *
     * @generated from protobuf field: bytes prepared_transaction_hash = 2
     */
    preparedTransactionHash: Uint8Array;
    /**
     * The hashing scheme version used when building the hash
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.interactive.HashingSchemeVersion hashing_scheme_version = 3
     */
    hashingSchemeVersion: HashingSchemeVersion;
    /**
     * Optional additional details on how the transaction was encoded and hashed. Only set if verbose_hashing = true in the request
     * Note that there are no guarantees on the stability of the format or content of this field.
     * Its content should NOT be parsed and should only be used for troubleshooting purposes.
     *
     * @generated from protobuf field: optional string hashing_details = 4
     */
    hashingDetails?: string;
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.Signature
 */
export interface Signature {
    /**
     * @generated from protobuf field: com.daml.ledger.api.v2.interactive.SignatureFormat format = 1
     */
    format: SignatureFormat;
    /**
     * @generated from protobuf field: bytes signature = 2
     */
    signature: Uint8Array;
    /**
     * The fingerprint/id of the keypair used to create this signature and needed to verify.
     *
     * @generated from protobuf field: string signed_by = 3
     */
    signedBy: string;
    /**
     * The signing algorithm specification used to produce this signature
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.interactive.SigningAlgorithmSpec signing_algorithm_spec = 4
     */
    signingAlgorithmSpec: SigningAlgorithmSpec;
}
/**
 * Signatures provided by a single party
 *
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.SinglePartySignatures
 */
export interface SinglePartySignatures {
    /**
     * @generated from protobuf field: string party = 1
     */
    party: string; // Submitting party
    /**
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.interactive.Signature signatures = 2
     */
    signatures: Signature[]; // Signatures
}
/**
 * Additional signatures provided by the submitting parties
 *
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.PartySignatures
 */
export interface PartySignatures {
    /**
     * Additional signatures provided by all individual parties
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.interactive.SinglePartySignatures signatures = 1
     */
    signatures: SinglePartySignatures[];
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.ExecuteSubmissionRequest
 */
export interface ExecuteSubmissionRequest {
    /**
     * the prepared transaction
     * Typically this is the value of the `prepared_transaction` field in `PrepareSubmissionResponse`
     * obtained from calling `prepareSubmission`.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.interactive.PreparedTransaction prepared_transaction = 1
     */
    preparedTransaction?: PreparedTransaction;
    /**
     * The party(ies) signatures that authorize the prepared submission to be executed by this node.
     * Each party can provide one or more signatures..
     * and one or more parties can sign.
     * Note that currently, only single party submissions are supported.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.interactive.PartySignatures party_signatures = 2
     */
    partySignatures?: PartySignatures;
    /**
     * Specifies the deduplication period for the change ID (See PrepareSubmissionRequest).
     * If omitted, the participant will assume the configured maximum deduplication time.
     *
     * @generated from protobuf oneof: deduplication_period
     */
    deduplicationPeriod: {
        oneofKind: "deduplicationDuration";
        /**
         * Specifies the length of the deduplication period.
         * It is interpreted relative to the local clock at some point during the submission's processing.
         * Must be non-negative. Must not exceed the maximum deduplication time.
         *
         * @generated from protobuf field: google.protobuf.Duration deduplication_duration = 3
         */
        deduplicationDuration: Duration;
    } | {
        oneofKind: "deduplicationOffset";
        /**
         * Specifies the start of the deduplication period by a completion stream offset (exclusive).
         * Must be a valid absolute offset (positive integer).
         *
         * @generated from protobuf field: int64 deduplication_offset = 4
         */
        deduplicationOffset: bigint;
    } | {
        oneofKind: undefined;
    };
    /**
     * A unique identifier to distinguish completions for different submissions with the same change ID.
     * Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
     * with the same change ID.
     * Must be a valid LedgerString (as described in ``value.proto``).
     *
     * Required
     *
     * @generated from protobuf field: string submission_id = 5
     */
    submissionId: string;
    /**
     * See [PrepareSubmissionRequest.user_id]
     *
     * @generated from protobuf field: string user_id = 6
     */
    userId: string;
    /**
     * The hashing scheme version used when building the hash
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.interactive.HashingSchemeVersion hashing_scheme_version = 7
     */
    hashingSchemeVersion: HashingSchemeVersion;
    /**
     * If set will influence the chosen ledger effective time but will not result in a submission delay so any override
     * should be scheduled to executed within the window allowed by synchronizer.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.interactive.MinLedgerTime min_ledger_time = 8
     */
    minLedgerTime?: MinLedgerTime; // Optional
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.ExecuteSubmissionResponse
 */
export interface ExecuteSubmissionResponse {
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.MinLedgerTime
 */
export interface MinLedgerTime {
    /**
     * @generated from protobuf oneof: time
     */
    time: {
        oneofKind: "minLedgerTimeAbs";
        /**
         * Lower bound for the ledger time assigned to the resulting transaction.
         * The ledger time of a transaction is assigned as part of command interpretation.
         * Important note: for interactive submissions, if the transaction depends on time, it **must** be signed
         * and submitted within a time window around the ledger time assigned to the transaction during the prepare method.
         * The time delta around that ledger time is a configuration of the ledger, usually short, around 1 minute.
         * If however the transaction does not depend on time, the available time window to sign and submit the transaction is bound
         * by the preparation time, which is also assigned in the "prepare" step (this request),
         * but can be configured with a much larger skew, allowing for more time to sign the request (in the order of hours).
         * Must not be set at the same time as min_ledger_time_rel.
         * Optional
         *
         * @generated from protobuf field: google.protobuf.Timestamp min_ledger_time_abs = 1
         */
        minLedgerTimeAbs: Timestamp;
    } | {
        oneofKind: "minLedgerTimeRel";
        /**
         * Same as min_ledger_time_abs, but specified as a duration, starting from the time this request is received by the server.
         * Must not be set at the same time as min_ledger_time_abs.
         * Optional
         *
         * @generated from protobuf field: google.protobuf.Duration min_ledger_time_rel = 2
         */
        minLedgerTimeRel: Duration;
    } | {
        oneofKind: undefined;
    };
}
/**
 * *
 * Prepared Transaction Message
 *
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.PreparedTransaction
 */
export interface PreparedTransaction {
    /**
     * Daml Transaction representing the ledger effect if executed. See below
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.interactive.DamlTransaction transaction = 1
     */
    transaction?: DamlTransaction;
    /**
     * Metadata context necessary to execute the transaction
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.interactive.Metadata metadata = 2
     */
    metadata?: Metadata;
}
/**
 * Transaction Metadata
 * Refer to the hashing documentation for information on how it should be hashed.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.Metadata
 */
export interface Metadata {
    /**
     * @generated from protobuf field: com.daml.ledger.api.v2.interactive.Metadata.SubmitterInfo submitter_info = 2
     */
    submitterInfo?: Metadata_SubmitterInfo;
    /**
     * @generated from protobuf field: string synchronizer_id = 3
     */
    synchronizerId: string;
    /**
     * @generated from protobuf field: uint32 mediator_group = 4
     */
    mediatorGroup: number;
    /**
     * @generated from protobuf field: string transaction_uuid = 5
     */
    transactionUuid: string;
    /**
     * @generated from protobuf field: uint64 preparation_time = 6
     */
    preparationTime: bigint;
    /**
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.interactive.Metadata.InputContract input_contracts = 7
     */
    inputContracts: Metadata_InputContract[];
    /**
     *
     * Where ledger time constraints are imposed during the execution of the contract they will be populated
     * in the fields below. These are optional because if the transaction does NOT depend on time, these values
     * do not need to be set.
     * The final ledger effective time used will be chosen when the command is submitted through the [execute] RPC.
     * If the ledger effective time is outside of any populated min/max bounds then a different transaction
     * can result, that will cause a confirmation message rejection.
     *
     * @generated from protobuf field: optional uint64 min_ledger_effective_time = 9
     */
    minLedgerEffectiveTime?: bigint;
    /**
     * @generated from protobuf field: optional uint64 max_ledger_effective_time = 10
     */
    maxLedgerEffectiveTime?: bigint;
    // ********************************************************** 

    // ** Metadata information that does NOT need to be signed ** 

    // ********************************************************** 

    /**
     * Contextual information needed to process the transaction but not signed, either because it's already indirectly
     * signed by signing the transaction, or because it doesn't impact the ledger state
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.interactive.Metadata.GlobalKeyMappingEntry global_key_mapping = 8
     */
    globalKeyMapping: Metadata_GlobalKeyMappingEntry[];
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.Metadata.SubmitterInfo
 */
export interface Metadata_SubmitterInfo {
    /**
     * @generated from protobuf field: repeated string act_as = 1
     */
    actAs: string[];
    /**
     * @generated from protobuf field: string command_id = 2
     */
    commandId: string;
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.Metadata.GlobalKeyMappingEntry
 */
export interface Metadata_GlobalKeyMappingEntry {
    /**
     * @generated from protobuf field: com.daml.ledger.api.v2.interactive.GlobalKey key = 1
     */
    key?: GlobalKey;
    /**
     * @generated from protobuf field: optional com.daml.ledger.api.v2.Value value = 2
     */
    value?: Value;
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.Metadata.InputContract
 */
export interface Metadata_InputContract {
    /**
     * @generated from protobuf oneof: contract
     */
    contract: {
        oneofKind: "v1";
        /**
         * When new versions will be added, they will show here
         *
         * @generated from protobuf field: com.daml.ledger.api.v2.interactive.transaction.v1.Create v1 = 1
         */
        v1: Create;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: uint64 created_at = 1000
     */
    createdAt: bigint;
    /**
     * @generated from protobuf field: bytes event_blob = 1002
     */
    eventBlob: Uint8Array;
}
/**
 *
 * Daml Transaction.
 * This represents the effect on the ledger if this transaction is successfully committed.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.DamlTransaction
 */
export interface DamlTransaction {
    /**
     * Transaction version, will be >= max(nodes version)
     *
     * @generated from protobuf field: string version = 1
     */
    version: string;
    /**
     * Root nodes of the transaction
     *
     * @generated from protobuf field: repeated string roots = 2
     */
    roots: string[];
    /**
     * List of nodes in the transaction
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.interactive.DamlTransaction.Node nodes = 3
     */
    nodes: DamlTransaction_Node[];
    /**
     * Node seeds are values associated with certain nodes used for generating cryptographic salts
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.interactive.DamlTransaction.NodeSeed node_seeds = 4
     */
    nodeSeeds: DamlTransaction_NodeSeed[];
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.DamlTransaction.NodeSeed
 */
export interface DamlTransaction_NodeSeed {
    /**
     * @generated from protobuf field: int32 node_id = 1
     */
    nodeId: number;
    /**
     * @generated from protobuf field: bytes seed = 2
     */
    seed: Uint8Array;
}
/**
 * A transaction may contain nodes with different versions.
 * Each node must be hashed using the hashing algorithm corresponding to its specific version.
 * [docs-entry-start: DamlTransaction.Node]
 *
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.DamlTransaction.Node
 */
export interface DamlTransaction_Node {
    /**
     * @generated from protobuf field: string node_id = 1
     */
    nodeId: string;
    /**
     * Versioned node
     *
     * @generated from protobuf oneof: versioned_node
     */
    versionedNode: {
        oneofKind: "v1";
        /**
         * Start at 1000 so we can add more fields before if necessary
         * When new versions will be added, they will show here
         *
         * @generated from protobuf field: com.daml.ledger.api.v2.interactive.transaction.v1.Node v1 = 1000
         */
        v1: Node;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.GetPreferredPackageVersionRequest
 */
export interface GetPreferredPackageVersionRequest {
    /**
     * The parties whose participants' vetting state should be considered when resolving the preferred package.
     * Required
     *
     * @generated from protobuf field: repeated string parties = 1
     */
    parties: string[];
    /**
     * The package-name for which the preferred package should be resolved.
     * Required
     *
     * @generated from protobuf field: string package_name = 2
     */
    packageName: string;
    /**
     * The synchronizer whose vetting state to use for resolving this query.
     * If not specified, the vetting state of all the synchronizers the participant is connected to will be used.
     * Optional
     *
     * @generated from protobuf field: string synchronizer_id = 3
     */
    synchronizerId: string;
    /**
     * The timestamp at which the package vetting validity should be computed
     * on the latest topology snapshot as seen by the participant.
     * If not provided, the participant's current clock time is used.
     * Optional
     *
     * @generated from protobuf field: google.protobuf.Timestamp vetting_valid_at = 4
     */
    vettingValidAt?: Timestamp;
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.GetPreferredPackageVersionResponse
 */
export interface GetPreferredPackageVersionResponse {
    /**
     * Not populated when no preferred package is found
     * Optional
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.interactive.PackagePreference package_preference = 1
     */
    packagePreference?: PackagePreference;
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.interactive.PackagePreference
 */
export interface PackagePreference {
    /**
     * The package reference of the preferred package.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.PackageReference package_reference = 1
     */
    packageReference?: PackageReference;
    /**
     * The synchronizer for which the preferred package was computed.
     * If the synchronizer_id was specified in the request, then it matches the request synchronizer_id.
     * Required
     *
     * @generated from protobuf field: string synchronizer_id = 2
     */
    synchronizerId: string;
}
/**
 * [docs-entry-start: HashingSchemeVersion]
 * The hashing scheme version used when building the hash of the PreparedTransaction
 *
 * @generated from protobuf enum com.daml.ledger.api.v2.interactive.HashingSchemeVersion
 */
export enum HashingSchemeVersion {
    /**
     * @generated from protobuf enum value: HASHING_SCHEME_VERSION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: HASHING_SCHEME_VERSION_V2 = 2;
     */
    V2 = 2
}
/**
 * @generated from protobuf enum com.daml.ledger.api.v2.interactive.SigningAlgorithmSpec
 */
export enum SigningAlgorithmSpec {
    /**
     * @generated from protobuf enum value: SIGNING_ALGORITHM_SPEC_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * EdDSA Signature based on Curve25519 with SHA-512
     * http://ed25519.cr.yp.to/
     *
     * @generated from protobuf enum value: SIGNING_ALGORITHM_SPEC_ED25519 = 1;
     */
    ED25519 = 1,
    /**
     * Elliptic Curve Digital Signature Algorithm with SHA256
     *
     * @generated from protobuf enum value: SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_256 = 2;
     */
    EC_DSA_SHA_256 = 2,
    /**
     * Elliptic Curve Digital Signature Algorithm with SHA384
     *
     * @generated from protobuf enum value: SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_384 = 3;
     */
    EC_DSA_SHA_384 = 3
}
/**
 * @generated from protobuf enum com.daml.ledger.api.v2.interactive.SignatureFormat
 */
export enum SignatureFormat {
    /**
     * @generated from protobuf enum value: SIGNATURE_FORMAT_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Signature scheme specific signature format
     * Legacy format no longer used, except for migrations
     *
     * @generated from protobuf enum value: SIGNATURE_FORMAT_RAW = 1;
     */
    RAW = 1,
    /**
     * ASN.1 + DER-encoding of the `r` and `s` integers, as defined in https://datatracker.ietf.org/doc/html/rfc3279#section-2.2.3
     * Used for ECDSA signatures
     *
     * @generated from protobuf enum value: SIGNATURE_FORMAT_DER = 2;
     */
    DER = 2,
    /**
     * Concatenation of the integers `r || s` in little-endian form, as defined in https://datatracker.ietf.org/doc/html/rfc8032#section-3.3
     * Note that this is different from the format defined in IEEE P1363, which uses concatenation in big-endian form.
     * Used for EdDSA signatures
     *
     * @generated from protobuf enum value: SIGNATURE_FORMAT_CONCAT = 3;
     */
    CONCAT = 3,
    /**
     * Symbolic crypto, must only be used for testing
     *
     * @generated from protobuf enum value: SIGNATURE_FORMAT_SYMBOLIC = 10000;
     */
    SYMBOLIC = 10000
}
// @generated message type with reflection information, may provide speed optimized methods
class PrepareSubmissionRequest$Type extends MessageType<PrepareSubmissionRequest> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.PrepareSubmissionRequest", [
            { no: 1, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "command_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "commands", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Command },
            { no: 4, name: "min_ledger_time", kind: "message", T: () => MinLedgerTime },
            { no: 5, name: "act_as", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "read_as", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "disclosed_contracts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DisclosedContract },
            { no: 8, name: "synchronizer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "package_id_selection_preference", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "verbose_hashing", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 15, name: "prefetch_contract_keys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PrefetchContractKey }
        ]);
    }
    create(value?: PartialMessage<PrepareSubmissionRequest>): PrepareSubmissionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.userId = "";
        message.commandId = "";
        message.commands = [];
        message.actAs = [];
        message.readAs = [];
        message.disclosedContracts = [];
        message.synchronizerId = "";
        message.packageIdSelectionPreference = [];
        message.verboseHashing = false;
        message.prefetchContractKeys = [];
        if (value !== undefined)
            reflectionMergePartial<PrepareSubmissionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareSubmissionRequest): PrepareSubmissionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string user_id */ 1:
                    message.userId = reader.string();
                    break;
                case /* string command_id */ 2:
                    message.commandId = reader.string();
                    break;
                case /* repeated com.daml.ledger.api.v2.Command commands */ 3:
                    message.commands.push(Command.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* com.daml.ledger.api.v2.interactive.MinLedgerTime min_ledger_time */ 4:
                    message.minLedgerTime = MinLedgerTime.internalBinaryRead(reader, reader.uint32(), options, message.minLedgerTime);
                    break;
                case /* repeated string act_as */ 5:
                    message.actAs.push(reader.string());
                    break;
                case /* repeated string read_as */ 6:
                    message.readAs.push(reader.string());
                    break;
                case /* repeated com.daml.ledger.api.v2.DisclosedContract disclosed_contracts */ 7:
                    message.disclosedContracts.push(DisclosedContract.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string synchronizer_id */ 8:
                    message.synchronizerId = reader.string();
                    break;
                case /* repeated string package_id_selection_preference */ 9:
                    message.packageIdSelectionPreference.push(reader.string());
                    break;
                case /* bool verbose_hashing */ 10:
                    message.verboseHashing = reader.bool();
                    break;
                case /* repeated com.daml.ledger.api.v2.PrefetchContractKey prefetch_contract_keys */ 15:
                    message.prefetchContractKeys.push(PrefetchContractKey.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrepareSubmissionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string user_id = 1; */
        if (message.userId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.userId);
        /* string command_id = 2; */
        if (message.commandId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.commandId);
        /* repeated com.daml.ledger.api.v2.Command commands = 3; */
        for (let i = 0; i < message.commands.length; i++)
            Command.internalBinaryWrite(message.commands[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.interactive.MinLedgerTime min_ledger_time = 4; */
        if (message.minLedgerTime)
            MinLedgerTime.internalBinaryWrite(message.minLedgerTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated string act_as = 5; */
        for (let i = 0; i < message.actAs.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.actAs[i]);
        /* repeated string read_as = 6; */
        for (let i = 0; i < message.readAs.length; i++)
            writer.tag(6, WireType.LengthDelimited).string(message.readAs[i]);
        /* repeated com.daml.ledger.api.v2.DisclosedContract disclosed_contracts = 7; */
        for (let i = 0; i < message.disclosedContracts.length; i++)
            DisclosedContract.internalBinaryWrite(message.disclosedContracts[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* string synchronizer_id = 8; */
        if (message.synchronizerId !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.synchronizerId);
        /* repeated string package_id_selection_preference = 9; */
        for (let i = 0; i < message.packageIdSelectionPreference.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.packageIdSelectionPreference[i]);
        /* bool verbose_hashing = 10; */
        if (message.verboseHashing !== false)
            writer.tag(10, WireType.Varint).bool(message.verboseHashing);
        /* repeated com.daml.ledger.api.v2.PrefetchContractKey prefetch_contract_keys = 15; */
        for (let i = 0; i < message.prefetchContractKeys.length; i++)
            PrefetchContractKey.internalBinaryWrite(message.prefetchContractKeys[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.PrepareSubmissionRequest
 */
export const PrepareSubmissionRequest = new PrepareSubmissionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PrepareSubmissionResponse$Type extends MessageType<PrepareSubmissionResponse> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.PrepareSubmissionResponse", [
            { no: 1, name: "prepared_transaction", kind: "message", T: () => PreparedTransaction },
            { no: 2, name: "prepared_transaction_hash", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "hashing_scheme_version", kind: "enum", T: () => ["com.daml.ledger.api.v2.interactive.HashingSchemeVersion", HashingSchemeVersion, "HASHING_SCHEME_VERSION_"] },
            { no: 4, name: "hashing_details", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PrepareSubmissionResponse>): PrepareSubmissionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.preparedTransactionHash = new Uint8Array(0);
        message.hashingSchemeVersion = 0;
        if (value !== undefined)
            reflectionMergePartial<PrepareSubmissionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PrepareSubmissionResponse): PrepareSubmissionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.interactive.PreparedTransaction prepared_transaction */ 1:
                    message.preparedTransaction = PreparedTransaction.internalBinaryRead(reader, reader.uint32(), options, message.preparedTransaction);
                    break;
                case /* bytes prepared_transaction_hash */ 2:
                    message.preparedTransactionHash = reader.bytes();
                    break;
                case /* com.daml.ledger.api.v2.interactive.HashingSchemeVersion hashing_scheme_version */ 3:
                    message.hashingSchemeVersion = reader.int32();
                    break;
                case /* optional string hashing_details */ 4:
                    message.hashingDetails = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PrepareSubmissionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.interactive.PreparedTransaction prepared_transaction = 1; */
        if (message.preparedTransaction)
            PreparedTransaction.internalBinaryWrite(message.preparedTransaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bytes prepared_transaction_hash = 2; */
        if (message.preparedTransactionHash.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.preparedTransactionHash);
        /* com.daml.ledger.api.v2.interactive.HashingSchemeVersion hashing_scheme_version = 3; */
        if (message.hashingSchemeVersion !== 0)
            writer.tag(3, WireType.Varint).int32(message.hashingSchemeVersion);
        /* optional string hashing_details = 4; */
        if (message.hashingDetails !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.hashingDetails);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.PrepareSubmissionResponse
 */
export const PrepareSubmissionResponse = new PrepareSubmissionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Signature$Type extends MessageType<Signature> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.Signature", [
            { no: 1, name: "format", kind: "enum", T: () => ["com.daml.ledger.api.v2.interactive.SignatureFormat", SignatureFormat, "SIGNATURE_FORMAT_"] },
            { no: 2, name: "signature", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "signed_by", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "signing_algorithm_spec", kind: "enum", T: () => ["com.daml.ledger.api.v2.interactive.SigningAlgorithmSpec", SigningAlgorithmSpec, "SIGNING_ALGORITHM_SPEC_"] }
        ]);
    }
    create(value?: PartialMessage<Signature>): Signature {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.format = 0;
        message.signature = new Uint8Array(0);
        message.signedBy = "";
        message.signingAlgorithmSpec = 0;
        if (value !== undefined)
            reflectionMergePartial<Signature>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Signature): Signature {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.interactive.SignatureFormat format */ 1:
                    message.format = reader.int32();
                    break;
                case /* bytes signature */ 2:
                    message.signature = reader.bytes();
                    break;
                case /* string signed_by */ 3:
                    message.signedBy = reader.string();
                    break;
                case /* com.daml.ledger.api.v2.interactive.SigningAlgorithmSpec signing_algorithm_spec */ 4:
                    message.signingAlgorithmSpec = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Signature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.interactive.SignatureFormat format = 1; */
        if (message.format !== 0)
            writer.tag(1, WireType.Varint).int32(message.format);
        /* bytes signature = 2; */
        if (message.signature.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.signature);
        /* string signed_by = 3; */
        if (message.signedBy !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.signedBy);
        /* com.daml.ledger.api.v2.interactive.SigningAlgorithmSpec signing_algorithm_spec = 4; */
        if (message.signingAlgorithmSpec !== 0)
            writer.tag(4, WireType.Varint).int32(message.signingAlgorithmSpec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.Signature
 */
export const Signature = new Signature$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SinglePartySignatures$Type extends MessageType<SinglePartySignatures> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.SinglePartySignatures", [
            { no: 1, name: "party", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "signatures", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Signature }
        ]);
    }
    create(value?: PartialMessage<SinglePartySignatures>): SinglePartySignatures {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.party = "";
        message.signatures = [];
        if (value !== undefined)
            reflectionMergePartial<SinglePartySignatures>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SinglePartySignatures): SinglePartySignatures {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string party */ 1:
                    message.party = reader.string();
                    break;
                case /* repeated com.daml.ledger.api.v2.interactive.Signature signatures */ 2:
                    message.signatures.push(Signature.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SinglePartySignatures, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string party = 1; */
        if (message.party !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.party);
        /* repeated com.daml.ledger.api.v2.interactive.Signature signatures = 2; */
        for (let i = 0; i < message.signatures.length; i++)
            Signature.internalBinaryWrite(message.signatures[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.SinglePartySignatures
 */
export const SinglePartySignatures = new SinglePartySignatures$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PartySignatures$Type extends MessageType<PartySignatures> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.PartySignatures", [
            { no: 1, name: "signatures", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SinglePartySignatures }
        ]);
    }
    create(value?: PartialMessage<PartySignatures>): PartySignatures {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.signatures = [];
        if (value !== undefined)
            reflectionMergePartial<PartySignatures>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PartySignatures): PartySignatures {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated com.daml.ledger.api.v2.interactive.SinglePartySignatures signatures */ 1:
                    message.signatures.push(SinglePartySignatures.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PartySignatures, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated com.daml.ledger.api.v2.interactive.SinglePartySignatures signatures = 1; */
        for (let i = 0; i < message.signatures.length; i++)
            SinglePartySignatures.internalBinaryWrite(message.signatures[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.PartySignatures
 */
export const PartySignatures = new PartySignatures$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteSubmissionRequest$Type extends MessageType<ExecuteSubmissionRequest> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.ExecuteSubmissionRequest", [
            { no: 1, name: "prepared_transaction", kind: "message", T: () => PreparedTransaction },
            { no: 2, name: "party_signatures", kind: "message", T: () => PartySignatures },
            { no: 3, name: "deduplication_duration", kind: "message", oneof: "deduplicationPeriod", T: () => Duration },
            { no: 4, name: "deduplication_offset", kind: "scalar", oneof: "deduplicationPeriod", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "submission_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "user_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "hashing_scheme_version", kind: "enum", T: () => ["com.daml.ledger.api.v2.interactive.HashingSchemeVersion", HashingSchemeVersion, "HASHING_SCHEME_VERSION_"] },
            { no: 8, name: "min_ledger_time", kind: "message", T: () => MinLedgerTime }
        ]);
    }
    create(value?: PartialMessage<ExecuteSubmissionRequest>): ExecuteSubmissionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.deduplicationPeriod = { oneofKind: undefined };
        message.submissionId = "";
        message.userId = "";
        message.hashingSchemeVersion = 0;
        if (value !== undefined)
            reflectionMergePartial<ExecuteSubmissionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteSubmissionRequest): ExecuteSubmissionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.interactive.PreparedTransaction prepared_transaction */ 1:
                    message.preparedTransaction = PreparedTransaction.internalBinaryRead(reader, reader.uint32(), options, message.preparedTransaction);
                    break;
                case /* com.daml.ledger.api.v2.interactive.PartySignatures party_signatures */ 2:
                    message.partySignatures = PartySignatures.internalBinaryRead(reader, reader.uint32(), options, message.partySignatures);
                    break;
                case /* google.protobuf.Duration deduplication_duration */ 3:
                    message.deduplicationPeriod = {
                        oneofKind: "deduplicationDuration",
                        deduplicationDuration: Duration.internalBinaryRead(reader, reader.uint32(), options, (message.deduplicationPeriod as any).deduplicationDuration)
                    };
                    break;
                case /* int64 deduplication_offset */ 4:
                    message.deduplicationPeriod = {
                        oneofKind: "deduplicationOffset",
                        deduplicationOffset: reader.int64().toBigInt()
                    };
                    break;
                case /* string submission_id */ 5:
                    message.submissionId = reader.string();
                    break;
                case /* string user_id */ 6:
                    message.userId = reader.string();
                    break;
                case /* com.daml.ledger.api.v2.interactive.HashingSchemeVersion hashing_scheme_version */ 7:
                    message.hashingSchemeVersion = reader.int32();
                    break;
                case /* com.daml.ledger.api.v2.interactive.MinLedgerTime min_ledger_time */ 8:
                    message.minLedgerTime = MinLedgerTime.internalBinaryRead(reader, reader.uint32(), options, message.minLedgerTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteSubmissionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.interactive.PreparedTransaction prepared_transaction = 1; */
        if (message.preparedTransaction)
            PreparedTransaction.internalBinaryWrite(message.preparedTransaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.interactive.PartySignatures party_signatures = 2; */
        if (message.partySignatures)
            PartySignatures.internalBinaryWrite(message.partySignatures, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration deduplication_duration = 3; */
        if (message.deduplicationPeriod.oneofKind === "deduplicationDuration")
            Duration.internalBinaryWrite(message.deduplicationPeriod.deduplicationDuration, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* int64 deduplication_offset = 4; */
        if (message.deduplicationPeriod.oneofKind === "deduplicationOffset")
            writer.tag(4, WireType.Varint).int64(message.deduplicationPeriod.deduplicationOffset);
        /* string submission_id = 5; */
        if (message.submissionId !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.submissionId);
        /* string user_id = 6; */
        if (message.userId !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.userId);
        /* com.daml.ledger.api.v2.interactive.HashingSchemeVersion hashing_scheme_version = 7; */
        if (message.hashingSchemeVersion !== 0)
            writer.tag(7, WireType.Varint).int32(message.hashingSchemeVersion);
        /* com.daml.ledger.api.v2.interactive.MinLedgerTime min_ledger_time = 8; */
        if (message.minLedgerTime)
            MinLedgerTime.internalBinaryWrite(message.minLedgerTime, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.ExecuteSubmissionRequest
 */
export const ExecuteSubmissionRequest = new ExecuteSubmissionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExecuteSubmissionResponse$Type extends MessageType<ExecuteSubmissionResponse> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.ExecuteSubmissionResponse", []);
    }
    create(value?: PartialMessage<ExecuteSubmissionResponse>): ExecuteSubmissionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ExecuteSubmissionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExecuteSubmissionResponse): ExecuteSubmissionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExecuteSubmissionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.ExecuteSubmissionResponse
 */
export const ExecuteSubmissionResponse = new ExecuteSubmissionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MinLedgerTime$Type extends MessageType<MinLedgerTime> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.MinLedgerTime", [
            { no: 1, name: "min_ledger_time_abs", kind: "message", oneof: "time", T: () => Timestamp },
            { no: 2, name: "min_ledger_time_rel", kind: "message", oneof: "time", T: () => Duration }
        ]);
    }
    create(value?: PartialMessage<MinLedgerTime>): MinLedgerTime {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.time = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MinLedgerTime>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MinLedgerTime): MinLedgerTime {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp min_ledger_time_abs */ 1:
                    message.time = {
                        oneofKind: "minLedgerTimeAbs",
                        minLedgerTimeAbs: Timestamp.internalBinaryRead(reader, reader.uint32(), options, (message.time as any).minLedgerTimeAbs)
                    };
                    break;
                case /* google.protobuf.Duration min_ledger_time_rel */ 2:
                    message.time = {
                        oneofKind: "minLedgerTimeRel",
                        minLedgerTimeRel: Duration.internalBinaryRead(reader, reader.uint32(), options, (message.time as any).minLedgerTimeRel)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MinLedgerTime, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp min_ledger_time_abs = 1; */
        if (message.time.oneofKind === "minLedgerTimeAbs")
            Timestamp.internalBinaryWrite(message.time.minLedgerTimeAbs, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Duration min_ledger_time_rel = 2; */
        if (message.time.oneofKind === "minLedgerTimeRel")
            Duration.internalBinaryWrite(message.time.minLedgerTimeRel, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.MinLedgerTime
 */
export const MinLedgerTime = new MinLedgerTime$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PreparedTransaction$Type extends MessageType<PreparedTransaction> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.PreparedTransaction", [
            { no: 1, name: "transaction", kind: "message", T: () => DamlTransaction },
            { no: 2, name: "metadata", kind: "message", T: () => Metadata }
        ]);
    }
    create(value?: PartialMessage<PreparedTransaction>): PreparedTransaction {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<PreparedTransaction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PreparedTransaction): PreparedTransaction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.interactive.DamlTransaction transaction */ 1:
                    message.transaction = DamlTransaction.internalBinaryRead(reader, reader.uint32(), options, message.transaction);
                    break;
                case /* com.daml.ledger.api.v2.interactive.Metadata metadata */ 2:
                    message.metadata = Metadata.internalBinaryRead(reader, reader.uint32(), options, message.metadata);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PreparedTransaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.interactive.DamlTransaction transaction = 1; */
        if (message.transaction)
            DamlTransaction.internalBinaryWrite(message.transaction, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* com.daml.ledger.api.v2.interactive.Metadata metadata = 2; */
        if (message.metadata)
            Metadata.internalBinaryWrite(message.metadata, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.PreparedTransaction
 */
export const PreparedTransaction = new PreparedTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Metadata$Type extends MessageType<Metadata> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.Metadata", [
            { no: 2, name: "submitter_info", kind: "message", T: () => Metadata_SubmitterInfo },
            { no: 3, name: "synchronizer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "mediator_group", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "transaction_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "preparation_time", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "input_contracts", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Metadata_InputContract },
            { no: 9, name: "min_ledger_effective_time", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "max_ledger_effective_time", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "global_key_mapping", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Metadata_GlobalKeyMappingEntry }
        ]);
    }
    create(value?: PartialMessage<Metadata>): Metadata {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.synchronizerId = "";
        message.mediatorGroup = 0;
        message.transactionUuid = "";
        message.preparationTime = 0n;
        message.inputContracts = [];
        message.globalKeyMapping = [];
        if (value !== undefined)
            reflectionMergePartial<Metadata>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Metadata): Metadata {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.interactive.Metadata.SubmitterInfo submitter_info */ 2:
                    message.submitterInfo = Metadata_SubmitterInfo.internalBinaryRead(reader, reader.uint32(), options, message.submitterInfo);
                    break;
                case /* string synchronizer_id */ 3:
                    message.synchronizerId = reader.string();
                    break;
                case /* uint32 mediator_group */ 4:
                    message.mediatorGroup = reader.uint32();
                    break;
                case /* string transaction_uuid */ 5:
                    message.transactionUuid = reader.string();
                    break;
                case /* uint64 preparation_time */ 6:
                    message.preparationTime = reader.uint64().toBigInt();
                    break;
                case /* repeated com.daml.ledger.api.v2.interactive.Metadata.InputContract input_contracts */ 7:
                    message.inputContracts.push(Metadata_InputContract.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional uint64 min_ledger_effective_time */ 9:
                    message.minLedgerEffectiveTime = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 max_ledger_effective_time */ 10:
                    message.maxLedgerEffectiveTime = reader.uint64().toBigInt();
                    break;
                case /* repeated com.daml.ledger.api.v2.interactive.Metadata.GlobalKeyMappingEntry global_key_mapping */ 8:
                    message.globalKeyMapping.push(Metadata_GlobalKeyMappingEntry.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Metadata, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.interactive.Metadata.SubmitterInfo submitter_info = 2; */
        if (message.submitterInfo)
            Metadata_SubmitterInfo.internalBinaryWrite(message.submitterInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string synchronizer_id = 3; */
        if (message.synchronizerId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.synchronizerId);
        /* uint32 mediator_group = 4; */
        if (message.mediatorGroup !== 0)
            writer.tag(4, WireType.Varint).uint32(message.mediatorGroup);
        /* string transaction_uuid = 5; */
        if (message.transactionUuid !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.transactionUuid);
        /* uint64 preparation_time = 6; */
        if (message.preparationTime !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.preparationTime);
        /* repeated com.daml.ledger.api.v2.interactive.Metadata.InputContract input_contracts = 7; */
        for (let i = 0; i < message.inputContracts.length; i++)
            Metadata_InputContract.internalBinaryWrite(message.inputContracts[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated com.daml.ledger.api.v2.interactive.Metadata.GlobalKeyMappingEntry global_key_mapping = 8; */
        for (let i = 0; i < message.globalKeyMapping.length; i++)
            Metadata_GlobalKeyMappingEntry.internalBinaryWrite(message.globalKeyMapping[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 min_ledger_effective_time = 9; */
        if (message.minLedgerEffectiveTime !== undefined)
            writer.tag(9, WireType.Varint).uint64(message.minLedgerEffectiveTime);
        /* optional uint64 max_ledger_effective_time = 10; */
        if (message.maxLedgerEffectiveTime !== undefined)
            writer.tag(10, WireType.Varint).uint64(message.maxLedgerEffectiveTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.Metadata
 */
export const Metadata = new Metadata$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Metadata_SubmitterInfo$Type extends MessageType<Metadata_SubmitterInfo> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.Metadata.SubmitterInfo", [
            { no: 1, name: "act_as", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "command_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Metadata_SubmitterInfo>): Metadata_SubmitterInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.actAs = [];
        message.commandId = "";
        if (value !== undefined)
            reflectionMergePartial<Metadata_SubmitterInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Metadata_SubmitterInfo): Metadata_SubmitterInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string act_as */ 1:
                    message.actAs.push(reader.string());
                    break;
                case /* string command_id */ 2:
                    message.commandId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Metadata_SubmitterInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string act_as = 1; */
        for (let i = 0; i < message.actAs.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.actAs[i]);
        /* string command_id = 2; */
        if (message.commandId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.commandId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.Metadata.SubmitterInfo
 */
export const Metadata_SubmitterInfo = new Metadata_SubmitterInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Metadata_GlobalKeyMappingEntry$Type extends MessageType<Metadata_GlobalKeyMappingEntry> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.Metadata.GlobalKeyMappingEntry", [
            { no: 1, name: "key", kind: "message", T: () => GlobalKey },
            { no: 2, name: "value", kind: "message", T: () => Value }
        ]);
    }
    create(value?: PartialMessage<Metadata_GlobalKeyMappingEntry>): Metadata_GlobalKeyMappingEntry {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Metadata_GlobalKeyMappingEntry>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Metadata_GlobalKeyMappingEntry): Metadata_GlobalKeyMappingEntry {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.interactive.GlobalKey key */ 1:
                    message.key = GlobalKey.internalBinaryRead(reader, reader.uint32(), options, message.key);
                    break;
                case /* optional com.daml.ledger.api.v2.Value value */ 2:
                    message.value = Value.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Metadata_GlobalKeyMappingEntry, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.interactive.GlobalKey key = 1; */
        if (message.key)
            GlobalKey.internalBinaryWrite(message.key, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional com.daml.ledger.api.v2.Value value = 2; */
        if (message.value)
            Value.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.Metadata.GlobalKeyMappingEntry
 */
export const Metadata_GlobalKeyMappingEntry = new Metadata_GlobalKeyMappingEntry$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Metadata_InputContract$Type extends MessageType<Metadata_InputContract> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.Metadata.InputContract", [
            { no: 1, name: "v1", kind: "message", oneof: "contract", T: () => Create },
            { no: 1000, name: "created_at", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 1002, name: "event_blob", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<Metadata_InputContract>): Metadata_InputContract {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.contract = { oneofKind: undefined };
        message.createdAt = 0n;
        message.eventBlob = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<Metadata_InputContract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Metadata_InputContract): Metadata_InputContract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.interactive.transaction.v1.Create v1 */ 1:
                    message.contract = {
                        oneofKind: "v1",
                        v1: Create.internalBinaryRead(reader, reader.uint32(), options, (message.contract as any).v1)
                    };
                    break;
                case /* uint64 created_at */ 1000:
                    message.createdAt = reader.uint64().toBigInt();
                    break;
                case /* bytes event_blob */ 1002:
                    message.eventBlob = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Metadata_InputContract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.interactive.transaction.v1.Create v1 = 1; */
        if (message.contract.oneofKind === "v1")
            Create.internalBinaryWrite(message.contract.v1, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint64 created_at = 1000; */
        if (message.createdAt !== 0n)
            writer.tag(1000, WireType.Varint).uint64(message.createdAt);
        /* bytes event_blob = 1002; */
        if (message.eventBlob.length)
            writer.tag(1002, WireType.LengthDelimited).bytes(message.eventBlob);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.Metadata.InputContract
 */
export const Metadata_InputContract = new Metadata_InputContract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DamlTransaction$Type extends MessageType<DamlTransaction> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.DamlTransaction", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "roots", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "nodes", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DamlTransaction_Node },
            { no: 4, name: "node_seeds", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DamlTransaction_NodeSeed }
        ]);
    }
    create(value?: PartialMessage<DamlTransaction>): DamlTransaction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.roots = [];
        message.nodes = [];
        message.nodeSeeds = [];
        if (value !== undefined)
            reflectionMergePartial<DamlTransaction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DamlTransaction): DamlTransaction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* repeated string roots */ 2:
                    message.roots.push(reader.string());
                    break;
                case /* repeated com.daml.ledger.api.v2.interactive.DamlTransaction.Node nodes */ 3:
                    message.nodes.push(DamlTransaction_Node.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated com.daml.ledger.api.v2.interactive.DamlTransaction.NodeSeed node_seeds */ 4:
                    message.nodeSeeds.push(DamlTransaction_NodeSeed.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DamlTransaction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* repeated string roots = 2; */
        for (let i = 0; i < message.roots.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.roots[i]);
        /* repeated com.daml.ledger.api.v2.interactive.DamlTransaction.Node nodes = 3; */
        for (let i = 0; i < message.nodes.length; i++)
            DamlTransaction_Node.internalBinaryWrite(message.nodes[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated com.daml.ledger.api.v2.interactive.DamlTransaction.NodeSeed node_seeds = 4; */
        for (let i = 0; i < message.nodeSeeds.length; i++)
            DamlTransaction_NodeSeed.internalBinaryWrite(message.nodeSeeds[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.DamlTransaction
 */
export const DamlTransaction = new DamlTransaction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DamlTransaction_NodeSeed$Type extends MessageType<DamlTransaction_NodeSeed> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.DamlTransaction.NodeSeed", [
            { no: 1, name: "node_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "seed", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<DamlTransaction_NodeSeed>): DamlTransaction_NodeSeed {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nodeId = 0;
        message.seed = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<DamlTransaction_NodeSeed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DamlTransaction_NodeSeed): DamlTransaction_NodeSeed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 node_id */ 1:
                    message.nodeId = reader.int32();
                    break;
                case /* bytes seed */ 2:
                    message.seed = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DamlTransaction_NodeSeed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 node_id = 1; */
        if (message.nodeId !== 0)
            writer.tag(1, WireType.Varint).int32(message.nodeId);
        /* bytes seed = 2; */
        if (message.seed.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.seed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.DamlTransaction.NodeSeed
 */
export const DamlTransaction_NodeSeed = new DamlTransaction_NodeSeed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DamlTransaction_Node$Type extends MessageType<DamlTransaction_Node> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.DamlTransaction.Node", [
            { no: 1, name: "node_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 1000, name: "v1", kind: "message", oneof: "versionedNode", T: () => Node }
        ]);
    }
    create(value?: PartialMessage<DamlTransaction_Node>): DamlTransaction_Node {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.nodeId = "";
        message.versionedNode = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<DamlTransaction_Node>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DamlTransaction_Node): DamlTransaction_Node {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string node_id */ 1:
                    message.nodeId = reader.string();
                    break;
                case /* com.daml.ledger.api.v2.interactive.transaction.v1.Node v1 */ 1000:
                    message.versionedNode = {
                        oneofKind: "v1",
                        v1: Node.internalBinaryRead(reader, reader.uint32(), options, (message.versionedNode as any).v1)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DamlTransaction_Node, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string node_id = 1; */
        if (message.nodeId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.nodeId);
        /* com.daml.ledger.api.v2.interactive.transaction.v1.Node v1 = 1000; */
        if (message.versionedNode.oneofKind === "v1")
            Node.internalBinaryWrite(message.versionedNode.v1, writer.tag(1000, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.DamlTransaction.Node
 */
export const DamlTransaction_Node = new DamlTransaction_Node$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPreferredPackageVersionRequest$Type extends MessageType<GetPreferredPackageVersionRequest> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.GetPreferredPackageVersionRequest", [
            { no: 1, name: "parties", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "package_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "synchronizer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "vetting_valid_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<GetPreferredPackageVersionRequest>): GetPreferredPackageVersionRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.parties = [];
        message.packageName = "";
        message.synchronizerId = "";
        if (value !== undefined)
            reflectionMergePartial<GetPreferredPackageVersionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPreferredPackageVersionRequest): GetPreferredPackageVersionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string parties */ 1:
                    message.parties.push(reader.string());
                    break;
                case /* string package_name */ 2:
                    message.packageName = reader.string();
                    break;
                case /* string synchronizer_id */ 3:
                    message.synchronizerId = reader.string();
                    break;
                case /* google.protobuf.Timestamp vetting_valid_at */ 4:
                    message.vettingValidAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.vettingValidAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPreferredPackageVersionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string parties = 1; */
        for (let i = 0; i < message.parties.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.parties[i]);
        /* string package_name = 2; */
        if (message.packageName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.packageName);
        /* string synchronizer_id = 3; */
        if (message.synchronizerId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.synchronizerId);
        /* google.protobuf.Timestamp vetting_valid_at = 4; */
        if (message.vettingValidAt)
            Timestamp.internalBinaryWrite(message.vettingValidAt, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.GetPreferredPackageVersionRequest
 */
export const GetPreferredPackageVersionRequest = new GetPreferredPackageVersionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPreferredPackageVersionResponse$Type extends MessageType<GetPreferredPackageVersionResponse> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.GetPreferredPackageVersionResponse", [
            { no: 1, name: "package_preference", kind: "message", T: () => PackagePreference }
        ]);
    }
    create(value?: PartialMessage<GetPreferredPackageVersionResponse>): GetPreferredPackageVersionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetPreferredPackageVersionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPreferredPackageVersionResponse): GetPreferredPackageVersionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.interactive.PackagePreference package_preference */ 1:
                    message.packagePreference = PackagePreference.internalBinaryRead(reader, reader.uint32(), options, message.packagePreference);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPreferredPackageVersionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.interactive.PackagePreference package_preference = 1; */
        if (message.packagePreference)
            PackagePreference.internalBinaryWrite(message.packagePreference, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.GetPreferredPackageVersionResponse
 */
export const GetPreferredPackageVersionResponse = new GetPreferredPackageVersionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PackagePreference$Type extends MessageType<PackagePreference> {
    constructor() {
        super("com.daml.ledger.api.v2.interactive.PackagePreference", [
            { no: 1, name: "package_reference", kind: "message", T: () => PackageReference },
            { no: 2, name: "synchronizer_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PackagePreference>): PackagePreference {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.synchronizerId = "";
        if (value !== undefined)
            reflectionMergePartial<PackagePreference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PackagePreference): PackagePreference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.PackageReference package_reference */ 1:
                    message.packageReference = PackageReference.internalBinaryRead(reader, reader.uint32(), options, message.packageReference);
                    break;
                case /* string synchronizer_id */ 2:
                    message.synchronizerId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PackagePreference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* com.daml.ledger.api.v2.PackageReference package_reference = 1; */
        if (message.packageReference)
            PackageReference.internalBinaryWrite(message.packageReference, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string synchronizer_id = 2; */
        if (message.synchronizerId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.synchronizerId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.interactive.PackagePreference
 */
export const PackagePreference = new PackagePreference$Type();
/**
 * @generated ServiceType for protobuf service com.daml.ledger.api.v2.interactive.InteractiveSubmissionService
 */
export const InteractiveSubmissionService = new ServiceType("com.daml.ledger.api.v2.interactive.InteractiveSubmissionService", [
    { name: "PrepareSubmission", options: {}, I: PrepareSubmissionRequest, O: PrepareSubmissionResponse },
    { name: "ExecuteSubmission", options: {}, I: ExecuteSubmissionRequest, O: ExecuteSubmissionResponse },
    { name: "GetPreferredPackageVersion", options: {}, I: GetPreferredPackageVersionRequest, O: GetPreferredPackageVersionResponse }
]);
