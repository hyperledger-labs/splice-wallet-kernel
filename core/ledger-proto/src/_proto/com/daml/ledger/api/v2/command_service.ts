// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/command_service.proto" (package "com.daml.ledger.api.v2", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import { ServiceType } from '@protobuf-ts/runtime-rpc'
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { Reassignment } from './reassignment.js'
import { EventFormat } from './transaction_filter.js'
import { ReassignmentCommands } from './reassignment_commands.js'
import { TransactionTree } from './transaction.js'
import { Transaction } from './transaction.js'
import { TransactionFormat } from './transaction_filter.js'
import { Commands } from './commands.js'
/**
 * These commands are executed as a single atomic transaction.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.SubmitAndWaitRequest
 */
export interface SubmitAndWaitRequest {
    /**
     * The commands to be submitted.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Commands commands = 1
     */
    commands?: Commands
}
/**
 * These commands are executed as a single atomic transaction.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.SubmitAndWaitForTransactionRequest
 */
export interface SubmitAndWaitForTransactionRequest {
    /**
     * The commands to be submitted.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Commands commands = 1
     */
    commands?: Commands
    /**
     * If no ``transaction_format`` is provided, a default will be used where ``transaction_shape`` is set to
     * TRANSACTION_SHAPE_ACS_DELTA, ``event_format`` is defined with ``filters_by_party`` containing wildcard-template
     * filter for all original ``act_as`` and ``read_as`` parties and the ``verbose`` flag is set.
     * Optional
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.TransactionFormat transaction_format = 2
     */
    transactionFormat?: TransactionFormat
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.SubmitAndWaitResponse
 */
export interface SubmitAndWaitResponse {
    /**
     * The id of the transaction that resulted from the submitted command.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string update_id = 1
     */
    updateId: string
    /**
     * The details of the offset field are described in ``community/ledger-api/README.md``.
     * Required
     *
     * @generated from protobuf field: int64 completion_offset = 2
     */
    completionOffset: bigint
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.SubmitAndWaitForTransactionResponse
 */
export interface SubmitAndWaitForTransactionResponse {
    /**
     * The transaction that resulted from the submitted command.
     * The transaction might contain no events (request conditions result in filtering out all of them).
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Transaction transaction = 1
     */
    transaction?: Transaction
}
/**
 * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
 *
 * @deprecated
 * @generated from protobuf message com.daml.ledger.api.v2.SubmitAndWaitForTransactionTreeResponse
 */
export interface SubmitAndWaitForTransactionTreeResponse {
    /**
     * The transaction tree that resulted from the submitted command.
     * The transaction might contain no events (request conditions result in filtering out all of them).
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.TransactionTree transaction = 1
     */
    transaction?: TransactionTree
}
/**
 * This reassignment is executed as a single atomic update.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.SubmitAndWaitForReassignmentRequest
 */
export interface SubmitAndWaitForReassignmentRequest {
    /**
     * The reassignment commands to be submitted.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.ReassignmentCommands reassignment_commands = 1
     */
    reassignmentCommands?: ReassignmentCommands
    /**
     * Optional
     * If no event_format provided, the result will contain no events.
     * The events in the result, will take shape TRANSACTION_SHAPE_ACS_DELTA.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.EventFormat event_format = 2
     */
    eventFormat?: EventFormat
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.SubmitAndWaitForReassignmentResponse
 */
export interface SubmitAndWaitForReassignmentResponse {
    /**
     * The reassignment that resulted from the submitted reassignment command.
     * The reassignment might contain no events (request conditions result in filtering out all of them).
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Reassignment reassignment = 1
     */
    reassignment?: Reassignment
}
// @generated message type with reflection information, may provide speed optimized methods
class SubmitAndWaitRequest$Type extends MessageType<SubmitAndWaitRequest> {
    constructor() {
        super('com.daml.ledger.api.v2.SubmitAndWaitRequest', [
            { no: 1, name: 'commands', kind: 'message', T: () => Commands },
        ])
    }
    create(value?: PartialMessage<SubmitAndWaitRequest>): SubmitAndWaitRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<SubmitAndWaitRequest>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubmitAndWaitRequest
    ): SubmitAndWaitRequest {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Commands commands */ 1:
                    message.commands = Commands.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.commands
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: SubmitAndWaitRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.Commands commands = 1; */
        if (message.commands)
            Commands.internalBinaryWrite(
                message.commands,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.SubmitAndWaitRequest
 */
export const SubmitAndWaitRequest = new SubmitAndWaitRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SubmitAndWaitForTransactionRequest$Type extends MessageType<SubmitAndWaitForTransactionRequest> {
    constructor() {
        super('com.daml.ledger.api.v2.SubmitAndWaitForTransactionRequest', [
            { no: 1, name: 'commands', kind: 'message', T: () => Commands },
            {
                no: 2,
                name: 'transaction_format',
                kind: 'message',
                T: () => TransactionFormat,
            },
        ])
    }
    create(
        value?: PartialMessage<SubmitAndWaitForTransactionRequest>
    ): SubmitAndWaitForTransactionRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<SubmitAndWaitForTransactionRequest>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubmitAndWaitForTransactionRequest
    ): SubmitAndWaitForTransactionRequest {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Commands commands */ 1:
                    message.commands = Commands.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.commands
                    )
                    break
                case /* com.daml.ledger.api.v2.TransactionFormat transaction_format */ 2:
                    message.transactionFormat =
                        TransactionFormat.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.transactionFormat
                        )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: SubmitAndWaitForTransactionRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.Commands commands = 1; */
        if (message.commands)
            Commands.internalBinaryWrite(
                message.commands,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.TransactionFormat transaction_format = 2; */
        if (message.transactionFormat)
            TransactionFormat.internalBinaryWrite(
                message.transactionFormat,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.SubmitAndWaitForTransactionRequest
 */
export const SubmitAndWaitForTransactionRequest =
    new SubmitAndWaitForTransactionRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SubmitAndWaitResponse$Type extends MessageType<SubmitAndWaitResponse> {
    constructor() {
        super('com.daml.ledger.api.v2.SubmitAndWaitResponse', [
            {
                no: 1,
                name: 'update_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'completion_offset',
                kind: 'scalar',
                T: 3 /*ScalarType.INT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
        ])
    }
    create(
        value?: PartialMessage<SubmitAndWaitResponse>
    ): SubmitAndWaitResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.updateId = ''
        message.completionOffset = 0n
        if (value !== undefined)
            reflectionMergePartial<SubmitAndWaitResponse>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubmitAndWaitResponse
    ): SubmitAndWaitResponse {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string update_id */ 1:
                    message.updateId = reader.string()
                    break
                case /* int64 completion_offset */ 2:
                    message.completionOffset = reader.int64().toBigInt()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: SubmitAndWaitResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string update_id = 1; */
        if (message.updateId !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.updateId)
        /* int64 completion_offset = 2; */
        if (message.completionOffset !== 0n)
            writer.tag(2, WireType.Varint).int64(message.completionOffset)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.SubmitAndWaitResponse
 */
export const SubmitAndWaitResponse = new SubmitAndWaitResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SubmitAndWaitForTransactionResponse$Type extends MessageType<SubmitAndWaitForTransactionResponse> {
    constructor() {
        super('com.daml.ledger.api.v2.SubmitAndWaitForTransactionResponse', [
            {
                no: 1,
                name: 'transaction',
                kind: 'message',
                T: () => Transaction,
            },
        ])
    }
    create(
        value?: PartialMessage<SubmitAndWaitForTransactionResponse>
    ): SubmitAndWaitForTransactionResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<SubmitAndWaitForTransactionResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubmitAndWaitForTransactionResponse
    ): SubmitAndWaitForTransactionResponse {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Transaction transaction */ 1:
                    message.transaction = Transaction.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.transaction
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: SubmitAndWaitForTransactionResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.Transaction transaction = 1; */
        if (message.transaction)
            Transaction.internalBinaryWrite(
                message.transaction,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.SubmitAndWaitForTransactionResponse
 */
export const SubmitAndWaitForTransactionResponse =
    new SubmitAndWaitForTransactionResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SubmitAndWaitForTransactionTreeResponse$Type extends MessageType<SubmitAndWaitForTransactionTreeResponse> {
    constructor() {
        super(
            'com.daml.ledger.api.v2.SubmitAndWaitForTransactionTreeResponse',
            [
                {
                    no: 1,
                    name: 'transaction',
                    kind: 'message',
                    T: () => TransactionTree,
                },
            ]
        )
    }
    create(
        value?: PartialMessage<SubmitAndWaitForTransactionTreeResponse>
    ): SubmitAndWaitForTransactionTreeResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<SubmitAndWaitForTransactionTreeResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubmitAndWaitForTransactionTreeResponse
    ): SubmitAndWaitForTransactionTreeResponse {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.TransactionTree transaction */ 1:
                    message.transaction = TransactionTree.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.transaction
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: SubmitAndWaitForTransactionTreeResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.TransactionTree transaction = 1; */
        if (message.transaction)
            TransactionTree.internalBinaryWrite(
                message.transaction,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @deprecated
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.SubmitAndWaitForTransactionTreeResponse
 */
export const SubmitAndWaitForTransactionTreeResponse =
    new SubmitAndWaitForTransactionTreeResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SubmitAndWaitForReassignmentRequest$Type extends MessageType<SubmitAndWaitForReassignmentRequest> {
    constructor() {
        super('com.daml.ledger.api.v2.SubmitAndWaitForReassignmentRequest', [
            {
                no: 1,
                name: 'reassignment_commands',
                kind: 'message',
                T: () => ReassignmentCommands,
            },
            {
                no: 2,
                name: 'event_format',
                kind: 'message',
                T: () => EventFormat,
            },
        ])
    }
    create(
        value?: PartialMessage<SubmitAndWaitForReassignmentRequest>
    ): SubmitAndWaitForReassignmentRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<SubmitAndWaitForReassignmentRequest>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubmitAndWaitForReassignmentRequest
    ): SubmitAndWaitForReassignmentRequest {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.ReassignmentCommands reassignment_commands */ 1:
                    message.reassignmentCommands =
                        ReassignmentCommands.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.reassignmentCommands
                        )
                    break
                case /* com.daml.ledger.api.v2.EventFormat event_format */ 2:
                    message.eventFormat = EventFormat.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.eventFormat
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: SubmitAndWaitForReassignmentRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.ReassignmentCommands reassignment_commands = 1; */
        if (message.reassignmentCommands)
            ReassignmentCommands.internalBinaryWrite(
                message.reassignmentCommands,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.EventFormat event_format = 2; */
        if (message.eventFormat)
            EventFormat.internalBinaryWrite(
                message.eventFormat,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.SubmitAndWaitForReassignmentRequest
 */
export const SubmitAndWaitForReassignmentRequest =
    new SubmitAndWaitForReassignmentRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SubmitAndWaitForReassignmentResponse$Type extends MessageType<SubmitAndWaitForReassignmentResponse> {
    constructor() {
        super('com.daml.ledger.api.v2.SubmitAndWaitForReassignmentResponse', [
            {
                no: 1,
                name: 'reassignment',
                kind: 'message',
                T: () => Reassignment,
            },
        ])
    }
    create(
        value?: PartialMessage<SubmitAndWaitForReassignmentResponse>
    ): SubmitAndWaitForReassignmentResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<SubmitAndWaitForReassignmentResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SubmitAndWaitForReassignmentResponse
    ): SubmitAndWaitForReassignmentResponse {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Reassignment reassignment */ 1:
                    message.reassignment = Reassignment.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.reassignment
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: SubmitAndWaitForReassignmentResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.Reassignment reassignment = 1; */
        if (message.reassignment)
            Reassignment.internalBinaryWrite(
                message.reassignment,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.SubmitAndWaitForReassignmentResponse
 */
export const SubmitAndWaitForReassignmentResponse =
    new SubmitAndWaitForReassignmentResponse$Type()
/**
 * @generated ServiceType for protobuf service com.daml.ledger.api.v2.CommandService
 */
export const CommandService = new ServiceType(
    'com.daml.ledger.api.v2.CommandService',
    [
        {
            name: 'SubmitAndWait',
            options: {},
            I: SubmitAndWaitRequest,
            O: SubmitAndWaitResponse,
        },
        {
            name: 'SubmitAndWaitForTransaction',
            options: {},
            I: SubmitAndWaitForTransactionRequest,
            O: SubmitAndWaitForTransactionResponse,
        },
        {
            name: 'SubmitAndWaitForTransactionTree',
            options: {},
            I: SubmitAndWaitRequest,
            O: SubmitAndWaitForTransactionTreeResponse,
        },
        {
            name: 'SubmitAndWaitForReassignment',
            options: {},
            I: SubmitAndWaitForReassignmentRequest,
            O: SubmitAndWaitForReassignmentResponse,
        },
    ]
)
