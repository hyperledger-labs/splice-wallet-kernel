// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/update_service.proto" (package "com.daml.ledger.api.v2", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import type { RpcTransport } from '@protobuf-ts/runtime-rpc'
import type { ServiceInfo } from '@protobuf-ts/runtime-rpc'
import { UpdateService } from './update_service.js'
import type { GetUpdateByIdRequest } from './update_service.js'
import type { GetUpdateResponse } from './update_service.js'
import type { GetUpdateByOffsetRequest } from './update_service.js'
import type { GetTransactionResponse } from './update_service.js'
import type { GetTransactionByIdRequest } from './update_service.js'
import type { GetTransactionTreeResponse } from './update_service.js'
import type { GetTransactionByOffsetRequest } from './update_service.js'
import type { UnaryCall } from '@protobuf-ts/runtime-rpc'
import type { GetUpdateTreesResponse } from './update_service.js'
import { stackIntercept } from '@protobuf-ts/runtime-rpc'
import type { GetUpdatesResponse } from './update_service.js'
import type { GetUpdatesRequest } from './update_service.js'
import type { ServerStreamingCall } from '@protobuf-ts/runtime-rpc'
import type { RpcOptions } from '@protobuf-ts/runtime-rpc'
/**
 * Allows clients to read updates (transactions, (un)assignments, topology events) from the ledger.
 *
 * ``GetUpdates`` and ``GetUpdateTrees`` provide a comprehensive stream of updates/changes
 * which happened on the virtual shared ledger. These streams are indexed with ledger
 * offsets, which are strictly increasing.
 * The virtual shared ledger consist of changes happening on multiple synchronizers which are
 * connected to the serving participant. Each update belongs to one synchronizer, this is
 * provided in the result (the ``synchronizer_id`` field in ``Transaction`` and ``TransactionTree``
 * for transactions, the ``source`` field in ``UnassignedEvent`` and the ``target`` field in ``AssignedEvent``).
 * Consumers can rely on strong causal guarantees on the virtual shared ledger for a single
 * synchronizer: updates which have greater offsets are happened after than updates with smaller
 * offsets for the same synchronizer. Across different synchronizers this is not guaranteed.
 *
 * @generated from protobuf service com.daml.ledger.api.v2.UpdateService
 */
export interface IUpdateServiceClient {
    /**
     * Read the ledger's filtered update stream for the specified contents and filters.
     * It returns the event types in accordance with the stream contents selected. Also the selection criteria
     * for individual events depends on the transaction shape chosen.
     *
     * - ACS delta: a requesting party must be a stakeholder of an event for it to be included.
     * - ledger effects: a requesting party must be a witness of an en event for it to be included.
     *
     * @generated from protobuf rpc: GetUpdates
     */
    getUpdates(
        input: GetUpdatesRequest,
        options?: RpcOptions
    ): ServerStreamingCall<GetUpdatesRequest, GetUpdatesResponse>
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * Read the ledger's complete transaction tree stream and related (un)assignments for a set of parties.
     * The stream will be filtered only by the parties as wildcard parties.
     * The template/interface filters describe the respective fields in the ``CreatedEvent`` results.
     *
     * @deprecated
     * @generated from protobuf rpc: GetUpdateTrees
     */
    getUpdateTrees(
        input: GetUpdatesRequest,
        options?: RpcOptions
    ): ServerStreamingCall<GetUpdatesRequest, GetUpdateTreesResponse>
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * Lookup a transaction tree by its offset.
     * For looking up a transaction instead of a transaction tree, please see GetTransactionByEventId
     * If the transaction cannot be found for the request, or all the events are filtered, a TRANSACTION_NOT_FOUND error will be raised.
     *
     * @deprecated
     * @generated from protobuf rpc: GetTransactionTreeByOffset
     */
    getTransactionTreeByOffset(
        input: GetTransactionByOffsetRequest,
        options?: RpcOptions
    ): UnaryCall<GetTransactionByOffsetRequest, GetTransactionTreeResponse>
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * Lookup a transaction tree by its ID.
     * For looking up a transaction instead of a transaction tree, please see GetTransactionById
     * If the transaction cannot be found for the request, or all the events are filtered, a TRANSACTION_NOT_FOUND error will be raised.
     *
     * @deprecated
     * @generated from protobuf rpc: GetTransactionTreeById
     */
    getTransactionTreeById(
        input: GetTransactionByIdRequest,
        options?: RpcOptions
    ): UnaryCall<GetTransactionByIdRequest, GetTransactionTreeResponse>
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * Lookup a transaction by its offset.
     * If there is no transaction with this offset, or all the events are filtered, a TRANSACTION_NOT_FOUND error will be raised.
     * Use a wildcard template filter if you want to retrieve any transaction visible to the parties you can read as.
     *
     * @deprecated
     * @generated from protobuf rpc: GetTransactionByOffset
     */
    getTransactionByOffset(
        input: GetTransactionByOffsetRequest,
        options?: RpcOptions
    ): UnaryCall<GetTransactionByOffsetRequest, GetTransactionResponse>
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * Lookup a transaction by its ID.
     * If there is no transaction with this id, or all the events are filtered, a TRANSACTION_NOT_FOUND error will be raised.
     * Use a wildcard template filter if you want to retrieve any transaction visible to the parties you can read as.
     *
     * @deprecated
     * @generated from protobuf rpc: GetTransactionById
     */
    getTransactionById(
        input: GetTransactionByIdRequest,
        options?: RpcOptions
    ): UnaryCall<GetTransactionByIdRequest, GetTransactionResponse>
    /**
     * Lookup an update by its offset.
     * If there is no update with this offset, or all the events are filtered, an UPDATE_NOT_FOUND error will be raised.
     *
     * @generated from protobuf rpc: GetUpdateByOffset
     */
    getUpdateByOffset(
        input: GetUpdateByOffsetRequest,
        options?: RpcOptions
    ): UnaryCall<GetUpdateByOffsetRequest, GetUpdateResponse>
    /**
     * Lookup an update by its ID.
     * If there is no update with this ID, or all the events are filtered, an UPDATE_NOT_FOUND error will be raised.
     *
     * @generated from protobuf rpc: GetUpdateById
     */
    getUpdateById(
        input: GetUpdateByIdRequest,
        options?: RpcOptions
    ): UnaryCall<GetUpdateByIdRequest, GetUpdateResponse>
}
/**
 * Allows clients to read updates (transactions, (un)assignments, topology events) from the ledger.
 *
 * ``GetUpdates`` and ``GetUpdateTrees`` provide a comprehensive stream of updates/changes
 * which happened on the virtual shared ledger. These streams are indexed with ledger
 * offsets, which are strictly increasing.
 * The virtual shared ledger consist of changes happening on multiple synchronizers which are
 * connected to the serving participant. Each update belongs to one synchronizer, this is
 * provided in the result (the ``synchronizer_id`` field in ``Transaction`` and ``TransactionTree``
 * for transactions, the ``source`` field in ``UnassignedEvent`` and the ``target`` field in ``AssignedEvent``).
 * Consumers can rely on strong causal guarantees on the virtual shared ledger for a single
 * synchronizer: updates which have greater offsets are happened after than updates with smaller
 * offsets for the same synchronizer. Across different synchronizers this is not guaranteed.
 *
 * @generated from protobuf service com.daml.ledger.api.v2.UpdateService
 */
export class UpdateServiceClient implements IUpdateServiceClient, ServiceInfo {
    typeName = UpdateService.typeName
    methods = UpdateService.methods
    options = UpdateService.options
    constructor(private readonly _transport: RpcTransport) {}
    /**
     * Read the ledger's filtered update stream for the specified contents and filters.
     * It returns the event types in accordance with the stream contents selected. Also the selection criteria
     * for individual events depends on the transaction shape chosen.
     *
     * - ACS delta: a requesting party must be a stakeholder of an event for it to be included.
     * - ledger effects: a requesting party must be a witness of an en event for it to be included.
     *
     * @generated from protobuf rpc: GetUpdates
     */
    getUpdates(
        input: GetUpdatesRequest,
        options?: RpcOptions
    ): ServerStreamingCall<GetUpdatesRequest, GetUpdatesResponse> {
        const method = this.methods[0],
            opt = this._transport.mergeOptions(options)
        return stackIntercept<GetUpdatesRequest, GetUpdatesResponse>(
            'serverStreaming',
            this._transport,
            method,
            opt,
            input
        )
    }
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * Read the ledger's complete transaction tree stream and related (un)assignments for a set of parties.
     * The stream will be filtered only by the parties as wildcard parties.
     * The template/interface filters describe the respective fields in the ``CreatedEvent`` results.
     *
     * @deprecated
     * @generated from protobuf rpc: GetUpdateTrees
     */
    getUpdateTrees(
        input: GetUpdatesRequest,
        options?: RpcOptions
    ): ServerStreamingCall<GetUpdatesRequest, GetUpdateTreesResponse> {
        const method = this.methods[1],
            opt = this._transport.mergeOptions(options)
        return stackIntercept<GetUpdatesRequest, GetUpdateTreesResponse>(
            'serverStreaming',
            this._transport,
            method,
            opt,
            input
        )
    }
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * Lookup a transaction tree by its offset.
     * For looking up a transaction instead of a transaction tree, please see GetTransactionByEventId
     * If the transaction cannot be found for the request, or all the events are filtered, a TRANSACTION_NOT_FOUND error will be raised.
     *
     * @deprecated
     * @generated from protobuf rpc: GetTransactionTreeByOffset
     */
    getTransactionTreeByOffset(
        input: GetTransactionByOffsetRequest,
        options?: RpcOptions
    ): UnaryCall<GetTransactionByOffsetRequest, GetTransactionTreeResponse> {
        const method = this.methods[2],
            opt = this._transport.mergeOptions(options)
        return stackIntercept<
            GetTransactionByOffsetRequest,
            GetTransactionTreeResponse
        >('unary', this._transport, method, opt, input)
    }
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * Lookup a transaction tree by its ID.
     * For looking up a transaction instead of a transaction tree, please see GetTransactionById
     * If the transaction cannot be found for the request, or all the events are filtered, a TRANSACTION_NOT_FOUND error will be raised.
     *
     * @deprecated
     * @generated from protobuf rpc: GetTransactionTreeById
     */
    getTransactionTreeById(
        input: GetTransactionByIdRequest,
        options?: RpcOptions
    ): UnaryCall<GetTransactionByIdRequest, GetTransactionTreeResponse> {
        const method = this.methods[3],
            opt = this._transport.mergeOptions(options)
        return stackIntercept<
            GetTransactionByIdRequest,
            GetTransactionTreeResponse
        >('unary', this._transport, method, opt, input)
    }
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * Lookup a transaction by its offset.
     * If there is no transaction with this offset, or all the events are filtered, a TRANSACTION_NOT_FOUND error will be raised.
     * Use a wildcard template filter if you want to retrieve any transaction visible to the parties you can read as.
     *
     * @deprecated
     * @generated from protobuf rpc: GetTransactionByOffset
     */
    getTransactionByOffset(
        input: GetTransactionByOffsetRequest,
        options?: RpcOptions
    ): UnaryCall<GetTransactionByOffsetRequest, GetTransactionResponse> {
        const method = this.methods[4],
            opt = this._transport.mergeOptions(options)
        return stackIntercept<
            GetTransactionByOffsetRequest,
            GetTransactionResponse
        >('unary', this._transport, method, opt, input)
    }
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * Lookup a transaction by its ID.
     * If there is no transaction with this id, or all the events are filtered, a TRANSACTION_NOT_FOUND error will be raised.
     * Use a wildcard template filter if you want to retrieve any transaction visible to the parties you can read as.
     *
     * @deprecated
     * @generated from protobuf rpc: GetTransactionById
     */
    getTransactionById(
        input: GetTransactionByIdRequest,
        options?: RpcOptions
    ): UnaryCall<GetTransactionByIdRequest, GetTransactionResponse> {
        const method = this.methods[5],
            opt = this._transport.mergeOptions(options)
        return stackIntercept<
            GetTransactionByIdRequest,
            GetTransactionResponse
        >('unary', this._transport, method, opt, input)
    }
    /**
     * Lookup an update by its offset.
     * If there is no update with this offset, or all the events are filtered, an UPDATE_NOT_FOUND error will be raised.
     *
     * @generated from protobuf rpc: GetUpdateByOffset
     */
    getUpdateByOffset(
        input: GetUpdateByOffsetRequest,
        options?: RpcOptions
    ): UnaryCall<GetUpdateByOffsetRequest, GetUpdateResponse> {
        const method = this.methods[6],
            opt = this._transport.mergeOptions(options)
        return stackIntercept<GetUpdateByOffsetRequest, GetUpdateResponse>(
            'unary',
            this._transport,
            method,
            opt,
            input
        )
    }
    /**
     * Lookup an update by its ID.
     * If there is no update with this ID, or all the events are filtered, an UPDATE_NOT_FOUND error will be raised.
     *
     * @generated from protobuf rpc: GetUpdateById
     */
    getUpdateById(
        input: GetUpdateByIdRequest,
        options?: RpcOptions
    ): UnaryCall<GetUpdateByIdRequest, GetUpdateResponse> {
        const method = this.methods[7],
            opt = this._transport.mergeOptions(options)
        return stackIntercept<GetUpdateByIdRequest, GetUpdateResponse>(
            'unary',
            this._transport,
            method,
            opt,
            input
        )
    }
}
