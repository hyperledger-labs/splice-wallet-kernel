// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/admin/object_meta.proto" (package "com.daml.ledger.api.v2.admin", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
/**
 * Represents metadata corresponding to a participant resource (e.g. a participant user or participant local information about a party).
 *
 * Based on ``ObjectMeta`` meta used in Kubernetes API.
 * See https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/generated.proto#L640
 *
 * @generated from protobuf message com.daml.ledger.api.v2.admin.ObjectMeta
 */
export interface ObjectMeta {
    /**
     * An opaque, non-empty value, populated by a participant server which represents the internal version of the resource
     * this ``ObjectMeta`` message is attached to. The participant server will change it to a unique value each time the corresponding resource is updated.
     * You must not rely on the format of resource version. The participant server might change it without notice.
     * You can obtain the newest resource version value by issuing a read request.
     * You may use it for concurrent change detection by passing it back unmodified in an update request.
     * The participant server will then compare the passed value with the value maintained by the system to determine
     * if any other updates took place since you had read the resource version.
     * Upon a successful update you are guaranteed that no other update took place during your read-modify-write sequence.
     * However, if another update took place during your read-modify-write sequence then your update will fail with an appropriate error.
     * Concurrent change control is optional. It will be applied only if you include a resource version in an update request.
     * When creating a new instance of a resource you must leave the resource version empty.
     * Its value will be populated by the participant server upon successful resource creation.
     * Optional
     *
     * @generated from protobuf field: string resource_version = 6
     */
    resourceVersion: string
    /**
     * A set of modifiable key-value pairs that can be used to represent arbitrary, client-specific metadata.
     * Constraints:
     *
     * 1. The total size over all keys and values cannot exceed 256kb in UTF-8 encoding.
     * 2. Keys are composed of an optional prefix segment and a required name segment such that:
     *
     *    - key prefix, when present, must be a valid DNS subdomain with at most 253 characters, followed by a '/' (forward slash) character,
     *    - name segment must have at most 63 characters that are either alphanumeric ([a-z0-9A-Z]), or a '.' (dot), '-' (dash) or '_' (underscore);
     *      and it must start and end with an alphanumeric character.
     *
     * 3. Values can be any non-empty strings.
     *
     * Keys with empty prefix are reserved for end-users.
     * Properties set by external tools or internally by the participant server must use non-empty key prefixes.
     * Duplicate keys are disallowed by the semantics of the protobuf3 maps.
     * See: https://developers.google.com/protocol-buffers/docs/proto3#maps
     * Annotations may be a part of a modifiable resource.
     * Use the resource's update RPC to update its annotations.
     * In order to add a new annotation or update an existing one using an update RPC, provide the desired annotation in the update request.
     * In order to remove an annotation using an update RPC, provide the target annotation's key but set its value to the empty string in the update request.
     * Optional
     * Modifiable
     *
     * @generated from protobuf field: map<string, string> annotations = 12
     */
    annotations: {
        [key: string]: string
    }
}
// @generated message type with reflection information, may provide speed optimized methods
class ObjectMeta$Type extends MessageType<ObjectMeta> {
    constructor() {
        super('com.daml.ledger.api.v2.admin.ObjectMeta', [
            {
                no: 6,
                name: 'resource_version',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 12,
                name: 'annotations',
                kind: 'map',
                K: 9 /*ScalarType.STRING*/,
                V: { kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            },
        ])
    }
    create(value?: PartialMessage<ObjectMeta>): ObjectMeta {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.resourceVersion = ''
        message.annotations = {}
        if (value !== undefined)
            reflectionMergePartial<ObjectMeta>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ObjectMeta
    ): ObjectMeta {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string resource_version */ 6:
                    message.resourceVersion = reader.string()
                    break
                case /* map<string, string> annotations */ 12:
                    this.binaryReadMap12(message.annotations, reader, options)
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    private binaryReadMap12(
        map: ObjectMeta['annotations'],
        reader: IBinaryReader,
        options: BinaryReadOptions
    ): void {
        let len = reader.uint32(),
            end = reader.pos + len,
            key: keyof ObjectMeta['annotations'] | undefined,
            val: ObjectMeta['annotations'][any] | undefined
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case 1:
                    key = reader.string()
                    break
                case 2:
                    val = reader.string()
                    break
                default:
                    throw new globalThis.Error(
                        'unknown map entry field for com.daml.ledger.api.v2.admin.ObjectMeta.annotations'
                    )
            }
        }
        map[key ?? ''] = val ?? ''
    }
    internalBinaryWrite(
        message: ObjectMeta,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string resource_version = 6; */
        if (message.resourceVersion !== '')
            writer
                .tag(6, WireType.LengthDelimited)
                .string(message.resourceVersion)
        /* map<string, string> annotations = 12; */
        for (let k of globalThis.Object.keys(message.annotations))
            writer
                .tag(12, WireType.LengthDelimited)
                .fork()
                .tag(1, WireType.LengthDelimited)
                .string(k)
                .tag(2, WireType.LengthDelimited)
                .string(message.annotations[k])
                .join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.ObjectMeta
 */
export const ObjectMeta = new ObjectMeta$Type()
