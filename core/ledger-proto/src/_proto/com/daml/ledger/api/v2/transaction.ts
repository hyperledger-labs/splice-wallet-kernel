// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/transaction.proto" (package "com.daml.ledger.api.v2", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { Event } from './event.js'
import { TraceContext } from './trace_context.js'
import { Timestamp } from '../../../../../google/protobuf/timestamp.js'
import { ExercisedEvent } from './event.js'
import { CreatedEvent } from './event.js'
/**
 * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
 * Each tree event message type below contains a ``witness_parties`` field which
 * indicates the subset of the requested parties that can see the event
 * in question.
 *
 * Note that transaction trees might contain events with
 * _no_ witness parties, which were included simply because they were
 * children of events which have witnesses.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.TreeEvent
 */
export interface TreeEvent {
    /**
     * @generated from protobuf oneof: kind
     */
    kind:
        | {
              oneofKind: 'created'
              /**
               * The event as it appeared in the context of its original daml transaction on this participant node.
               * In particular, the offset, node_id pair of the daml transaction are preserved.
               *
               * @generated from protobuf field: com.daml.ledger.api.v2.CreatedEvent created = 1
               */
              created: CreatedEvent
          }
        | {
              oneofKind: 'exercised'
              /**
               * @generated from protobuf field: com.daml.ledger.api.v2.ExercisedEvent exercised = 2
               */
              exercised: ExercisedEvent
          }
        | {
              oneofKind: undefined
          }
}
/**
 * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
 * Complete view of an on-ledger transaction.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.TransactionTree
 */
export interface TransactionTree {
    /**
     * Assigned by the server. Useful for correlating logs.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string update_id = 1
     */
    updateId: string
    /**
     * The ID of the command which resulted in this transaction. Missing for everyone except the submitting party.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Optional
     *
     * @generated from protobuf field: string command_id = 2
     */
    commandId: string
    /**
     * The workflow ID used in command submission. Only set if the ``workflow_id`` for the command was set.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Optional
     *
     * @generated from protobuf field: string workflow_id = 3
     */
    workflowId: string
    /**
     * Ledger effective time.
     * Required
     *
     * @generated from protobuf field: google.protobuf.Timestamp effective_at = 4
     */
    effectiveAt?: Timestamp
    /**
     * The absolute offset. The details of this field are described in ``community/ledger-api/README.md``.
     * Required, it is a valid absolute offset (positive integer).
     *
     * @generated from protobuf field: int64 offset = 5
     */
    offset: bigint
    /**
     * Changes to the ledger that were caused by this transaction. Nodes of the transaction tree.
     * Each key must be a valid node ID (non-negative integer).
     * Required
     *
     * @generated from protobuf field: map<int32, com.daml.ledger.api.v2.TreeEvent> events_by_id = 6
     */
    eventsById: {
        [key: number]: TreeEvent
    }
    /**
     * A valid synchronizer id.
     * Identifies the synchronizer that synchronized the transaction.
     * Required
     *
     * @generated from protobuf field: string synchronizer_id = 7
     */
    synchronizerId: string
    /**
     * Optional; ledger API trace context
     *
     * The trace context transported in this message corresponds to the trace context supplied
     * by the client application in a HTTP2 header of the original command submission.
     * We typically use a header to transfer this type of information. Here we use message
     * body, because it is used in gRPC streams which do not support per message headers.
     * This field will be populated with the trace context contained in the original submission.
     * If that was not provided, a unique ledger-api-server generated trace context will be used
     * instead.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.TraceContext trace_context = 8
     */
    traceContext?: TraceContext
    /**
     * The time at which the transaction was recorded. The record time refers to the synchronizer
     * which synchronized the transaction.
     * Required
     *
     * @generated from protobuf field: google.protobuf.Timestamp record_time = 9
     */
    recordTime?: Timestamp
}
/**
 * Filtered view of an on-ledger transaction's create and archive events.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.Transaction
 */
export interface Transaction {
    /**
     * Assigned by the server. Useful for correlating logs.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string update_id = 1
     */
    updateId: string
    /**
     * The ID of the command which resulted in this transaction. Missing for everyone except the submitting party.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Optional
     *
     * @generated from protobuf field: string command_id = 2
     */
    commandId: string
    /**
     * The workflow ID used in command submission.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Optional
     *
     * @generated from protobuf field: string workflow_id = 3
     */
    workflowId: string
    /**
     * Ledger effective time.
     * Required
     *
     * @generated from protobuf field: google.protobuf.Timestamp effective_at = 4
     */
    effectiveAt?: Timestamp
    /**
     * The collection of events.
     * Contains:
     *
     * - ``CreatedEvent`` or ``ArchivedEvent`` in case of ACS_DELTA transaction shape
     * - ``CreatedEvent`` or ``ExercisedEvent`` in case of LEDGER_EFFECTS transaction shape
     *
     * Required
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.Event events = 5
     */
    events: Event[]
    /**
     * The absolute offset. The details of this field are described in ``community/ledger-api/README.md``.
     * Required, it is a valid absolute offset (positive integer).
     *
     * @generated from protobuf field: int64 offset = 6
     */
    offset: bigint
    /**
     * A valid synchronizer id.
     * Identifies the synchronizer that synchronized the transaction.
     * Required
     *
     * @generated from protobuf field: string synchronizer_id = 7
     */
    synchronizerId: string
    /**
     * Optional; ledger API trace context
     *
     * The trace context transported in this message corresponds to the trace context supplied
     * by the client application in a HTTP2 header of the original command submission.
     * We typically use a header to transfer this type of information. Here we use message
     * body, because it is used in gRPC streams which do not support per message headers.
     * This field will be populated with the trace context contained in the original submission.
     * If that was not provided, a unique ledger-api-server generated trace context will be used
     * instead.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.TraceContext trace_context = 8
     */
    traceContext?: TraceContext
    /**
     * The time at which the transaction was recorded. The record time refers to the synchronizer
     * which synchronized the transaction.
     * Required
     *
     * @generated from protobuf field: google.protobuf.Timestamp record_time = 9
     */
    recordTime?: Timestamp
}
// @generated message type with reflection information, may provide speed optimized methods
class TreeEvent$Type extends MessageType<TreeEvent> {
    constructor() {
        super('com.daml.ledger.api.v2.TreeEvent', [
            {
                no: 1,
                name: 'created',
                kind: 'message',
                oneof: 'kind',
                T: () => CreatedEvent,
            },
            {
                no: 2,
                name: 'exercised',
                kind: 'message',
                oneof: 'kind',
                T: () => ExercisedEvent,
            },
        ])
    }
    create(value?: PartialMessage<TreeEvent>): TreeEvent {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.kind = { oneofKind: undefined }
        if (value !== undefined)
            reflectionMergePartial<TreeEvent>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TreeEvent
    ): TreeEvent {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.CreatedEvent created */ 1:
                    message.kind = {
                        oneofKind: 'created',
                        created: CreatedEvent.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.kind as any).created
                        ),
                    }
                    break
                case /* com.daml.ledger.api.v2.ExercisedEvent exercised */ 2:
                    message.kind = {
                        oneofKind: 'exercised',
                        exercised: ExercisedEvent.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.kind as any).exercised
                        ),
                    }
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: TreeEvent,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.CreatedEvent created = 1; */
        if (message.kind.oneofKind === 'created')
            CreatedEvent.internalBinaryWrite(
                message.kind.created,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.ExercisedEvent exercised = 2; */
        if (message.kind.oneofKind === 'exercised')
            ExercisedEvent.internalBinaryWrite(
                message.kind.exercised,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.TreeEvent
 */
export const TreeEvent = new TreeEvent$Type()
// @generated message type with reflection information, may provide speed optimized methods
class TransactionTree$Type extends MessageType<TransactionTree> {
    constructor() {
        super('com.daml.ledger.api.v2.TransactionTree', [
            {
                no: 1,
                name: 'update_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'command_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 3,
                name: 'workflow_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 4,
                name: 'effective_at',
                kind: 'message',
                T: () => Timestamp,
            },
            {
                no: 5,
                name: 'offset',
                kind: 'scalar',
                T: 3 /*ScalarType.INT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            {
                no: 6,
                name: 'events_by_id',
                kind: 'map',
                K: 5 /*ScalarType.INT32*/,
                V: { kind: 'message', T: () => TreeEvent },
            },
            {
                no: 7,
                name: 'synchronizer_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 8,
                name: 'trace_context',
                kind: 'message',
                T: () => TraceContext,
            },
            { no: 9, name: 'record_time', kind: 'message', T: () => Timestamp },
        ])
    }
    create(value?: PartialMessage<TransactionTree>): TransactionTree {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.updateId = ''
        message.commandId = ''
        message.workflowId = ''
        message.offset = 0n
        message.eventsById = {}
        message.synchronizerId = ''
        if (value !== undefined)
            reflectionMergePartial<TransactionTree>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TransactionTree
    ): TransactionTree {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string update_id */ 1:
                    message.updateId = reader.string()
                    break
                case /* string command_id */ 2:
                    message.commandId = reader.string()
                    break
                case /* string workflow_id */ 3:
                    message.workflowId = reader.string()
                    break
                case /* google.protobuf.Timestamp effective_at */ 4:
                    message.effectiveAt = Timestamp.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.effectiveAt
                    )
                    break
                case /* int64 offset */ 5:
                    message.offset = reader.int64().toBigInt()
                    break
                case /* map<int32, com.daml.ledger.api.v2.TreeEvent> events_by_id */ 6:
                    this.binaryReadMap6(message.eventsById, reader, options)
                    break
                case /* string synchronizer_id */ 7:
                    message.synchronizerId = reader.string()
                    break
                case /* com.daml.ledger.api.v2.TraceContext trace_context */ 8:
                    message.traceContext = TraceContext.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.traceContext
                    )
                    break
                case /* google.protobuf.Timestamp record_time */ 9:
                    message.recordTime = Timestamp.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.recordTime
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    private binaryReadMap6(
        map: TransactionTree['eventsById'],
        reader: IBinaryReader,
        options: BinaryReadOptions
    ): void {
        let len = reader.uint32(),
            end = reader.pos + len,
            key: keyof TransactionTree['eventsById'] | undefined,
            val: TransactionTree['eventsById'][any] | undefined
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case 1:
                    key = reader.int32()
                    break
                case 2:
                    val = TreeEvent.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options
                    )
                    break
                default:
                    throw new globalThis.Error(
                        'unknown map entry field for com.daml.ledger.api.v2.TransactionTree.events_by_id'
                    )
            }
        }
        map[key ?? 0] = val ?? TreeEvent.create()
    }
    internalBinaryWrite(
        message: TransactionTree,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string update_id = 1; */
        if (message.updateId !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.updateId)
        /* string command_id = 2; */
        if (message.commandId !== '')
            writer.tag(2, WireType.LengthDelimited).string(message.commandId)
        /* string workflow_id = 3; */
        if (message.workflowId !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.workflowId)
        /* google.protobuf.Timestamp effective_at = 4; */
        if (message.effectiveAt)
            Timestamp.internalBinaryWrite(
                message.effectiveAt,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* int64 offset = 5; */
        if (message.offset !== 0n)
            writer.tag(5, WireType.Varint).int64(message.offset)
        /* map<int32, com.daml.ledger.api.v2.TreeEvent> events_by_id = 6; */
        for (let k of globalThis.Object.keys(message.eventsById)) {
            writer
                .tag(6, WireType.LengthDelimited)
                .fork()
                .tag(1, WireType.Varint)
                .int32(parseInt(k))
            writer.tag(2, WireType.LengthDelimited).fork()
            TreeEvent.internalBinaryWrite(
                message.eventsById[k as any],
                writer,
                options
            )
            writer.join().join()
        }
        /* string synchronizer_id = 7; */
        if (message.synchronizerId !== '')
            writer
                .tag(7, WireType.LengthDelimited)
                .string(message.synchronizerId)
        /* com.daml.ledger.api.v2.TraceContext trace_context = 8; */
        if (message.traceContext)
            TraceContext.internalBinaryWrite(
                message.traceContext,
                writer.tag(8, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* google.protobuf.Timestamp record_time = 9; */
        if (message.recordTime)
            Timestamp.internalBinaryWrite(
                message.recordTime,
                writer.tag(9, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.TransactionTree
 */
export const TransactionTree = new TransactionTree$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Transaction$Type extends MessageType<Transaction> {
    constructor() {
        super('com.daml.ledger.api.v2.Transaction', [
            {
                no: 1,
                name: 'update_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'command_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 3,
                name: 'workflow_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 4,
                name: 'effective_at',
                kind: 'message',
                T: () => Timestamp,
            },
            {
                no: 5,
                name: 'events',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => Event,
            },
            {
                no: 6,
                name: 'offset',
                kind: 'scalar',
                T: 3 /*ScalarType.INT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            {
                no: 7,
                name: 'synchronizer_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 8,
                name: 'trace_context',
                kind: 'message',
                T: () => TraceContext,
            },
            { no: 9, name: 'record_time', kind: 'message', T: () => Timestamp },
        ])
    }
    create(value?: PartialMessage<Transaction>): Transaction {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.updateId = ''
        message.commandId = ''
        message.workflowId = ''
        message.events = []
        message.offset = 0n
        message.synchronizerId = ''
        if (value !== undefined)
            reflectionMergePartial<Transaction>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Transaction
    ): Transaction {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string update_id */ 1:
                    message.updateId = reader.string()
                    break
                case /* string command_id */ 2:
                    message.commandId = reader.string()
                    break
                case /* string workflow_id */ 3:
                    message.workflowId = reader.string()
                    break
                case /* google.protobuf.Timestamp effective_at */ 4:
                    message.effectiveAt = Timestamp.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.effectiveAt
                    )
                    break
                case /* repeated com.daml.ledger.api.v2.Event events */ 5:
                    message.events.push(
                        Event.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                case /* int64 offset */ 6:
                    message.offset = reader.int64().toBigInt()
                    break
                case /* string synchronizer_id */ 7:
                    message.synchronizerId = reader.string()
                    break
                case /* com.daml.ledger.api.v2.TraceContext trace_context */ 8:
                    message.traceContext = TraceContext.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.traceContext
                    )
                    break
                case /* google.protobuf.Timestamp record_time */ 9:
                    message.recordTime = Timestamp.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.recordTime
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: Transaction,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string update_id = 1; */
        if (message.updateId !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.updateId)
        /* string command_id = 2; */
        if (message.commandId !== '')
            writer.tag(2, WireType.LengthDelimited).string(message.commandId)
        /* string workflow_id = 3; */
        if (message.workflowId !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.workflowId)
        /* google.protobuf.Timestamp effective_at = 4; */
        if (message.effectiveAt)
            Timestamp.internalBinaryWrite(
                message.effectiveAt,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* repeated com.daml.ledger.api.v2.Event events = 5; */
        for (let i = 0; i < message.events.length; i++)
            Event.internalBinaryWrite(
                message.events[i],
                writer.tag(5, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* int64 offset = 6; */
        if (message.offset !== 0n)
            writer.tag(6, WireType.Varint).int64(message.offset)
        /* string synchronizer_id = 7; */
        if (message.synchronizerId !== '')
            writer
                .tag(7, WireType.LengthDelimited)
                .string(message.synchronizerId)
        /* com.daml.ledger.api.v2.TraceContext trace_context = 8; */
        if (message.traceContext)
            TraceContext.internalBinaryWrite(
                message.traceContext,
                writer.tag(8, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* google.protobuf.Timestamp record_time = 9; */
        if (message.recordTime)
            Timestamp.internalBinaryWrite(
                message.recordTime,
                writer.tag(9, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.Transaction
 */
export const Transaction = new Transaction$Type()
