// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/state_service.proto" (package "com.daml.ledger.api.v2", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import { ServiceType } from '@protobuf-ts/runtime-rpc'
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { AssignedEvent } from './reassignment.js'
import { UnassignedEvent } from './reassignment.js'
import { CreatedEvent } from './event.js'
import { EventFormat } from './transaction_filter.js'
import { TransactionFilter } from './transaction_filter.js'
/**
 * If the given offset is different than the ledger end, and there are (un)assignments in-flight at the given offset,
 * the snapshot may fail with "FAILED_PRECONDITION/PARTICIPANT_PRUNED_DATA_ACCESSED".
 * Note that it is ok to request acs snapshots for party migration with offsets other than ledger end, because party
 * migration is not concerned with incomplete (un)assignments.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.GetActiveContractsRequest
 */
export interface GetActiveContractsRequest {
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * Templates to include in the served snapshot, per party.
     * Optional, if specified event_format must be unset, if not specified event_format must be set.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.TransactionFilter filter = 1
     */
    filter?: TransactionFilter
    /**
     * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
     * If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
     * In particular, setting the verbose flag to true triggers the ledger to include labels for record fields.
     * Optional, if specified event_format must be unset.
     *
     * @generated from protobuf field: bool verbose = 2
     */
    verbose: boolean
    /**
     * The offset at which the snapshot of the active contracts will be computed.
     * Must be no greater than the current ledger end offset.
     * Must be greater than or equal to the last pruning offset.
     * Required, must be a valid absolute offset (positive integer) or ledger begin offset (zero).
     * If zero, the empty set will be returned.
     *
     * @generated from protobuf field: int64 active_at_offset = 3
     */
    activeAtOffset: bigint
    /**
     * Format of the contract_entries in the result. In case of CreatedEvent the presentation will be of
     * TRANSACTION_SHAPE_ACS_DELTA.
     * Optional for backwards compatibility, defaults to an EventFormat where:
     *
     * - filters_by_party is the filter.filters_by_party from this request
     * - filters_for_any_party is the filter.filters_for_any_party from this request
     * - verbose is the verbose field from this request
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.EventFormat event_format = 4
     */
    eventFormat?: EventFormat
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.GetActiveContractsResponse
 */
export interface GetActiveContractsResponse {
    /**
     * The workflow ID used in command submission which corresponds to the contract_entry. Only set if
     * the ``workflow_id`` for the command was set.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Optional
     *
     * @generated from protobuf field: string workflow_id = 1
     */
    workflowId: string
    /**
     * For a contract there could be multiple contract_entry-s in the entire snapshot. These together define
     * the state of one contract in the snapshot.
     * A contract_entry is included in the result, if and only if there is at least one stakeholder party of the contract
     * that is hosted on the synchronizer at the time of the event and the party satisfies the
     * ``TransactionFilter`` in the query.
     *
     * @generated from protobuf oneof: contract_entry
     */
    contractEntry:
        | {
              oneofKind: 'activeContract'
              /**
               * The contract is active on the assigned synchronizer, meaning: there was an activation event on the given synchronizer (
               * created, assigned), which is not followed by a deactivation event (archived, unassigned) on the same
               * synchronizer, until the active_at_offset.
               * Since activeness is defined as a per synchronizer concept, it is possible, that a contract is active on one
               * synchronizer, but already archived on another.
               * There will be one such message for each synchronizer the contract is active on.
               *
               * @generated from protobuf field: com.daml.ledger.api.v2.ActiveContract active_contract = 2
               */
              activeContract: ActiveContract
          }
        | {
              oneofKind: 'incompleteUnassigned'
              /**
               * Included iff the unassigned event was before or at the active_at_offset, but there was no corresponding
               * assigned event before or at the active_at_offset.
               *
               * @generated from protobuf field: com.daml.ledger.api.v2.IncompleteUnassigned incomplete_unassigned = 3
               */
              incompleteUnassigned: IncompleteUnassigned
          }
        | {
              oneofKind: 'incompleteAssigned'
              /**
               * Important: this message is not indicating that the contract is active on the target synchronizer!
               * Included iff the assigned event was before or at the active_at_offset, but there was no corresponding
               * unassigned event before or at the active_at_offset.
               *
               * @generated from protobuf field: com.daml.ledger.api.v2.IncompleteAssigned incomplete_assigned = 4
               */
              incompleteAssigned: IncompleteAssigned
          }
        | {
              oneofKind: undefined
          }
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.ActiveContract
 */
export interface ActiveContract {
    /**
     * Required
     * The event as it appeared in the context of its last update (i.e. daml transaction or
     * reassignment). In particular, the last offset, node_id pair is preserved.
     * The last update is the most recent update created or assigned this contract on synchronizer_id synchronizer.
     * The offset of the CreatedEvent might point to an already pruned update, therefore it cannot necessarily be used
     * for lookups.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.CreatedEvent created_event = 1
     */
    createdEvent?: CreatedEvent
    /**
     * A valid synchronizer id
     * Required
     *
     * @generated from protobuf field: string synchronizer_id = 2
     */
    synchronizerId: string
    /**
     * Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases
     * with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter
     * equals zero.
     * This field will be the reassignment_counter of the latest observable activation event on this synchronizer, which is
     * before the active_at_offset.
     * Required
     *
     * @generated from protobuf field: uint64 reassignment_counter = 3
     */
    reassignmentCounter: bigint
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.IncompleteUnassigned
 */
export interface IncompleteUnassigned {
    /**
     * Required
     * The event as it appeared in the context of its last activation update (i.e. daml transaction or
     * reassignment). In particular, the last activation offset, node_id pair is preserved.
     * The last activation update is the most recent update created or assigned this contract on synchronizer_id synchronizer before
     * the unassigned_event.
     * The offset of the CreatedEvent might point to an already pruned update, therefore it cannot necessarily be used
     * for lookups.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.CreatedEvent created_event = 1
     */
    createdEvent?: CreatedEvent
    /**
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.UnassignedEvent unassigned_event = 2
     */
    unassignedEvent?: UnassignedEvent
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.IncompleteAssigned
 */
export interface IncompleteAssigned {
    /**
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.AssignedEvent assigned_event = 1
     */
    assignedEvent?: AssignedEvent
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.GetConnectedSynchronizersRequest
 */
export interface GetConnectedSynchronizersRequest {
    /**
     * The party of interest
     * Must be a valid PartyIdString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string party = 1
     */
    party: string
    /**
     * The id of a participant whose mapping of a party to connected synchronizers is requested.
     * Must be a valid participant-id retrieved through a prior call to getParticipantId.
     * Defaults to the participant id of the host participant.
     * Optional
     *
     * @generated from protobuf field: string participant_id = 2
     */
    participantId: string
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.GetConnectedSynchronizersResponse
 */
export interface GetConnectedSynchronizersResponse {
    /**
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.GetConnectedSynchronizersResponse.ConnectedSynchronizer connected_synchronizers = 1
     */
    connectedSynchronizers: GetConnectedSynchronizersResponse_ConnectedSynchronizer[]
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.GetConnectedSynchronizersResponse.ConnectedSynchronizer
 */
export interface GetConnectedSynchronizersResponse_ConnectedSynchronizer {
    /**
     * The alias of the synchronizer
     * Required
     *
     * @generated from protobuf field: string synchronizer_alias = 1
     */
    synchronizerAlias: string
    /**
     * The ID of the synchronizer
     * Required
     *
     * @generated from protobuf field: string synchronizer_id = 2
     */
    synchronizerId: string
    /**
     * The permission on the synchronizer
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.ParticipantPermission permission = 3
     */
    permission: ParticipantPermission
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.GetLedgerEndRequest
 */
export interface GetLedgerEndRequest {}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.GetLedgerEndResponse
 */
export interface GetLedgerEndResponse {
    /**
     * It will always be a non-negative integer.
     * If zero, the participant view of the ledger is empty.
     * If positive, the absolute offset of the ledger as viewed by the participant.
     *
     * @generated from protobuf field: int64 offset = 1
     */
    offset: bigint
}
/**
 * Empty for now, but may contain fields in the future.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.GetLatestPrunedOffsetsRequest
 */
export interface GetLatestPrunedOffsetsRequest {}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.GetLatestPrunedOffsetsResponse
 */
export interface GetLatestPrunedOffsetsResponse {
    /**
     * It will always be a non-negative integer.
     * If positive, the absolute offset up to which the ledger has been pruned,
     * disregarding the state of all divulged contracts pruning.
     * If zero, the ledger has not been pruned yet.
     *
     * @generated from protobuf field: int64 participant_pruned_up_to_inclusive = 1
     */
    participantPrunedUpToInclusive: bigint
    /**
     * It will always be a non-negative integer.
     * If positive, the absolute offset up to which all divulged events have been pruned on the ledger.
     * It can be at or before the ``participant_pruned_up_to_inclusive`` offset.
     * For more details about all divulged events pruning,
     * see ``PruneRequest.prune_all_divulged_contracts`` in ``participant_pruning_service.proto``.
     * If zero, the divulged events have not been pruned yet.
     *
     * @generated from protobuf field: int64 all_divulged_contracts_pruned_up_to_inclusive = 2
     */
    allDivulgedContractsPrunedUpToInclusive: bigint
}
/**
 * Enum indicating the permission level that the participant has for the party
 * whose connected synchronizers are being listed.
 *
 * @generated from protobuf enum com.daml.ledger.api.v2.ParticipantPermission
 */
export enum ParticipantPermission {
    /**
     * @generated from protobuf enum value: PARTICIPANT_PERMISSION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PARTICIPANT_PERMISSION_SUBMISSION = 1;
     */
    SUBMISSION = 1,
    /**
     * participant can only confirm transactions
     *
     * @generated from protobuf enum value: PARTICIPANT_PERMISSION_CONFIRMATION = 2;
     */
    CONFIRMATION = 2,
    /**
     * participant can only observe transactions
     *
     * @generated from protobuf enum value: PARTICIPANT_PERMISSION_OBSERVATION = 3;
     */
    OBSERVATION = 3,
}
// @generated message type with reflection information, may provide speed optimized methods
class GetActiveContractsRequest$Type extends MessageType<GetActiveContractsRequest> {
    constructor() {
        super('com.daml.ledger.api.v2.GetActiveContractsRequest', [
            {
                no: 1,
                name: 'filter',
                kind: 'message',
                T: () => TransactionFilter,
            },
            {
                no: 2,
                name: 'verbose',
                kind: 'scalar',
                T: 8 /*ScalarType.BOOL*/,
            },
            {
                no: 3,
                name: 'active_at_offset',
                kind: 'scalar',
                T: 3 /*ScalarType.INT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            {
                no: 4,
                name: 'event_format',
                kind: 'message',
                T: () => EventFormat,
            },
        ])
    }
    create(
        value?: PartialMessage<GetActiveContractsRequest>
    ): GetActiveContractsRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.verbose = false
        message.activeAtOffset = 0n
        if (value !== undefined)
            reflectionMergePartial<GetActiveContractsRequest>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetActiveContractsRequest
    ): GetActiveContractsRequest {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.TransactionFilter filter */ 1:
                    message.filter = TransactionFilter.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.filter
                    )
                    break
                case /* bool verbose */ 2:
                    message.verbose = reader.bool()
                    break
                case /* int64 active_at_offset */ 3:
                    message.activeAtOffset = reader.int64().toBigInt()
                    break
                case /* com.daml.ledger.api.v2.EventFormat event_format */ 4:
                    message.eventFormat = EventFormat.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.eventFormat
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GetActiveContractsRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.TransactionFilter filter = 1; */
        if (message.filter)
            TransactionFilter.internalBinaryWrite(
                message.filter,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* bool verbose = 2; */
        if (message.verbose !== false)
            writer.tag(2, WireType.Varint).bool(message.verbose)
        /* int64 active_at_offset = 3; */
        if (message.activeAtOffset !== 0n)
            writer.tag(3, WireType.Varint).int64(message.activeAtOffset)
        /* com.daml.ledger.api.v2.EventFormat event_format = 4; */
        if (message.eventFormat)
            EventFormat.internalBinaryWrite(
                message.eventFormat,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetActiveContractsRequest
 */
export const GetActiveContractsRequest = new GetActiveContractsRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetActiveContractsResponse$Type extends MessageType<GetActiveContractsResponse> {
    constructor() {
        super('com.daml.ledger.api.v2.GetActiveContractsResponse', [
            {
                no: 1,
                name: 'workflow_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'active_contract',
                kind: 'message',
                oneof: 'contractEntry',
                T: () => ActiveContract,
            },
            {
                no: 3,
                name: 'incomplete_unassigned',
                kind: 'message',
                oneof: 'contractEntry',
                T: () => IncompleteUnassigned,
            },
            {
                no: 4,
                name: 'incomplete_assigned',
                kind: 'message',
                oneof: 'contractEntry',
                T: () => IncompleteAssigned,
            },
        ])
    }
    create(
        value?: PartialMessage<GetActiveContractsResponse>
    ): GetActiveContractsResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.workflowId = ''
        message.contractEntry = { oneofKind: undefined }
        if (value !== undefined)
            reflectionMergePartial<GetActiveContractsResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetActiveContractsResponse
    ): GetActiveContractsResponse {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string workflow_id */ 1:
                    message.workflowId = reader.string()
                    break
                case /* com.daml.ledger.api.v2.ActiveContract active_contract */ 2:
                    message.contractEntry = {
                        oneofKind: 'activeContract',
                        activeContract: ActiveContract.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.contractEntry as any).activeContract
                        ),
                    }
                    break
                case /* com.daml.ledger.api.v2.IncompleteUnassigned incomplete_unassigned */ 3:
                    message.contractEntry = {
                        oneofKind: 'incompleteUnassigned',
                        incompleteUnassigned:
                            IncompleteUnassigned.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                (message.contractEntry as any)
                                    .incompleteUnassigned
                            ),
                    }
                    break
                case /* com.daml.ledger.api.v2.IncompleteAssigned incomplete_assigned */ 4:
                    message.contractEntry = {
                        oneofKind: 'incompleteAssigned',
                        incompleteAssigned:
                            IncompleteAssigned.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                (message.contractEntry as any)
                                    .incompleteAssigned
                            ),
                    }
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GetActiveContractsResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string workflow_id = 1; */
        if (message.workflowId !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.workflowId)
        /* com.daml.ledger.api.v2.ActiveContract active_contract = 2; */
        if (message.contractEntry.oneofKind === 'activeContract')
            ActiveContract.internalBinaryWrite(
                message.contractEntry.activeContract,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.IncompleteUnassigned incomplete_unassigned = 3; */
        if (message.contractEntry.oneofKind === 'incompleteUnassigned')
            IncompleteUnassigned.internalBinaryWrite(
                message.contractEntry.incompleteUnassigned,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.IncompleteAssigned incomplete_assigned = 4; */
        if (message.contractEntry.oneofKind === 'incompleteAssigned')
            IncompleteAssigned.internalBinaryWrite(
                message.contractEntry.incompleteAssigned,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetActiveContractsResponse
 */
export const GetActiveContractsResponse = new GetActiveContractsResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ActiveContract$Type extends MessageType<ActiveContract> {
    constructor() {
        super('com.daml.ledger.api.v2.ActiveContract', [
            {
                no: 1,
                name: 'created_event',
                kind: 'message',
                T: () => CreatedEvent,
            },
            {
                no: 2,
                name: 'synchronizer_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 3,
                name: 'reassignment_counter',
                kind: 'scalar',
                T: 4 /*ScalarType.UINT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
        ])
    }
    create(value?: PartialMessage<ActiveContract>): ActiveContract {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.synchronizerId = ''
        message.reassignmentCounter = 0n
        if (value !== undefined)
            reflectionMergePartial<ActiveContract>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ActiveContract
    ): ActiveContract {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.CreatedEvent created_event */ 1:
                    message.createdEvent = CreatedEvent.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.createdEvent
                    )
                    break
                case /* string synchronizer_id */ 2:
                    message.synchronizerId = reader.string()
                    break
                case /* uint64 reassignment_counter */ 3:
                    message.reassignmentCounter = reader.uint64().toBigInt()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: ActiveContract,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.CreatedEvent created_event = 1; */
        if (message.createdEvent)
            CreatedEvent.internalBinaryWrite(
                message.createdEvent,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* string synchronizer_id = 2; */
        if (message.synchronizerId !== '')
            writer
                .tag(2, WireType.LengthDelimited)
                .string(message.synchronizerId)
        /* uint64 reassignment_counter = 3; */
        if (message.reassignmentCounter !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.reassignmentCounter)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.ActiveContract
 */
export const ActiveContract = new ActiveContract$Type()
// @generated message type with reflection information, may provide speed optimized methods
class IncompleteUnassigned$Type extends MessageType<IncompleteUnassigned> {
    constructor() {
        super('com.daml.ledger.api.v2.IncompleteUnassigned', [
            {
                no: 1,
                name: 'created_event',
                kind: 'message',
                T: () => CreatedEvent,
            },
            {
                no: 2,
                name: 'unassigned_event',
                kind: 'message',
                T: () => UnassignedEvent,
            },
        ])
    }
    create(value?: PartialMessage<IncompleteUnassigned>): IncompleteUnassigned {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<IncompleteUnassigned>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: IncompleteUnassigned
    ): IncompleteUnassigned {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.CreatedEvent created_event */ 1:
                    message.createdEvent = CreatedEvent.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.createdEvent
                    )
                    break
                case /* com.daml.ledger.api.v2.UnassignedEvent unassigned_event */ 2:
                    message.unassignedEvent =
                        UnassignedEvent.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.unassignedEvent
                        )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: IncompleteUnassigned,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.CreatedEvent created_event = 1; */
        if (message.createdEvent)
            CreatedEvent.internalBinaryWrite(
                message.createdEvent,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.UnassignedEvent unassigned_event = 2; */
        if (message.unassignedEvent)
            UnassignedEvent.internalBinaryWrite(
                message.unassignedEvent,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.IncompleteUnassigned
 */
export const IncompleteUnassigned = new IncompleteUnassigned$Type()
// @generated message type with reflection information, may provide speed optimized methods
class IncompleteAssigned$Type extends MessageType<IncompleteAssigned> {
    constructor() {
        super('com.daml.ledger.api.v2.IncompleteAssigned', [
            {
                no: 1,
                name: 'assigned_event',
                kind: 'message',
                T: () => AssignedEvent,
            },
        ])
    }
    create(value?: PartialMessage<IncompleteAssigned>): IncompleteAssigned {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<IncompleteAssigned>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: IncompleteAssigned
    ): IncompleteAssigned {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.AssignedEvent assigned_event */ 1:
                    message.assignedEvent = AssignedEvent.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.assignedEvent
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: IncompleteAssigned,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.AssignedEvent assigned_event = 1; */
        if (message.assignedEvent)
            AssignedEvent.internalBinaryWrite(
                message.assignedEvent,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.IncompleteAssigned
 */
export const IncompleteAssigned = new IncompleteAssigned$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetConnectedSynchronizersRequest$Type extends MessageType<GetConnectedSynchronizersRequest> {
    constructor() {
        super('com.daml.ledger.api.v2.GetConnectedSynchronizersRequest', [
            {
                no: 1,
                name: 'party',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'participant_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
        ])
    }
    create(
        value?: PartialMessage<GetConnectedSynchronizersRequest>
    ): GetConnectedSynchronizersRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.party = ''
        message.participantId = ''
        if (value !== undefined)
            reflectionMergePartial<GetConnectedSynchronizersRequest>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetConnectedSynchronizersRequest
    ): GetConnectedSynchronizersRequest {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string party */ 1:
                    message.party = reader.string()
                    break
                case /* string participant_id */ 2:
                    message.participantId = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GetConnectedSynchronizersRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string party = 1; */
        if (message.party !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.party)
        /* string participant_id = 2; */
        if (message.participantId !== '')
            writer
                .tag(2, WireType.LengthDelimited)
                .string(message.participantId)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetConnectedSynchronizersRequest
 */
export const GetConnectedSynchronizersRequest =
    new GetConnectedSynchronizersRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetConnectedSynchronizersResponse$Type extends MessageType<GetConnectedSynchronizersResponse> {
    constructor() {
        super('com.daml.ledger.api.v2.GetConnectedSynchronizersResponse', [
            {
                no: 1,
                name: 'connected_synchronizers',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () =>
                    GetConnectedSynchronizersResponse_ConnectedSynchronizer,
            },
        ])
    }
    create(
        value?: PartialMessage<GetConnectedSynchronizersResponse>
    ): GetConnectedSynchronizersResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.connectedSynchronizers = []
        if (value !== undefined)
            reflectionMergePartial<GetConnectedSynchronizersResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetConnectedSynchronizersResponse
    ): GetConnectedSynchronizersResponse {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated com.daml.ledger.api.v2.GetConnectedSynchronizersResponse.ConnectedSynchronizer connected_synchronizers */ 1:
                    message.connectedSynchronizers.push(
                        GetConnectedSynchronizersResponse_ConnectedSynchronizer.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GetConnectedSynchronizersResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated com.daml.ledger.api.v2.GetConnectedSynchronizersResponse.ConnectedSynchronizer connected_synchronizers = 1; */
        for (let i = 0; i < message.connectedSynchronizers.length; i++)
            GetConnectedSynchronizersResponse_ConnectedSynchronizer.internalBinaryWrite(
                message.connectedSynchronizers[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetConnectedSynchronizersResponse
 */
export const GetConnectedSynchronizersResponse =
    new GetConnectedSynchronizersResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetConnectedSynchronizersResponse_ConnectedSynchronizer$Type extends MessageType<GetConnectedSynchronizersResponse_ConnectedSynchronizer> {
    constructor() {
        super(
            'com.daml.ledger.api.v2.GetConnectedSynchronizersResponse.ConnectedSynchronizer',
            [
                {
                    no: 1,
                    name: 'synchronizer_alias',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'synchronizer_id',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 3,
                    name: 'permission',
                    kind: 'enum',
                    T: () => [
                        'com.daml.ledger.api.v2.ParticipantPermission',
                        ParticipantPermission,
                        'PARTICIPANT_PERMISSION_',
                    ],
                },
            ]
        )
    }
    create(
        value?: PartialMessage<GetConnectedSynchronizersResponse_ConnectedSynchronizer>
    ): GetConnectedSynchronizersResponse_ConnectedSynchronizer {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.synchronizerAlias = ''
        message.synchronizerId = ''
        message.permission = 0
        if (value !== undefined)
            reflectionMergePartial<GetConnectedSynchronizersResponse_ConnectedSynchronizer>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetConnectedSynchronizersResponse_ConnectedSynchronizer
    ): GetConnectedSynchronizersResponse_ConnectedSynchronizer {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string synchronizer_alias */ 1:
                    message.synchronizerAlias = reader.string()
                    break
                case /* string synchronizer_id */ 2:
                    message.synchronizerId = reader.string()
                    break
                case /* com.daml.ledger.api.v2.ParticipantPermission permission */ 3:
                    message.permission = reader.int32()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GetConnectedSynchronizersResponse_ConnectedSynchronizer,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string synchronizer_alias = 1; */
        if (message.synchronizerAlias !== '')
            writer
                .tag(1, WireType.LengthDelimited)
                .string(message.synchronizerAlias)
        /* string synchronizer_id = 2; */
        if (message.synchronizerId !== '')
            writer
                .tag(2, WireType.LengthDelimited)
                .string(message.synchronizerId)
        /* com.daml.ledger.api.v2.ParticipantPermission permission = 3; */
        if (message.permission !== 0)
            writer.tag(3, WireType.Varint).int32(message.permission)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetConnectedSynchronizersResponse.ConnectedSynchronizer
 */
export const GetConnectedSynchronizersResponse_ConnectedSynchronizer =
    new GetConnectedSynchronizersResponse_ConnectedSynchronizer$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetLedgerEndRequest$Type extends MessageType<GetLedgerEndRequest> {
    constructor() {
        super('com.daml.ledger.api.v2.GetLedgerEndRequest', [])
    }
    create(value?: PartialMessage<GetLedgerEndRequest>): GetLedgerEndRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<GetLedgerEndRequest>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetLedgerEndRequest
    ): GetLedgerEndRequest {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GetLedgerEndRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetLedgerEndRequest
 */
export const GetLedgerEndRequest = new GetLedgerEndRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetLedgerEndResponse$Type extends MessageType<GetLedgerEndResponse> {
    constructor() {
        super('com.daml.ledger.api.v2.GetLedgerEndResponse', [
            {
                no: 1,
                name: 'offset',
                kind: 'scalar',
                T: 3 /*ScalarType.INT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
        ])
    }
    create(value?: PartialMessage<GetLedgerEndResponse>): GetLedgerEndResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.offset = 0n
        if (value !== undefined)
            reflectionMergePartial<GetLedgerEndResponse>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetLedgerEndResponse
    ): GetLedgerEndResponse {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* int64 offset */ 1:
                    message.offset = reader.int64().toBigInt()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GetLedgerEndResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* int64 offset = 1; */
        if (message.offset !== 0n)
            writer.tag(1, WireType.Varint).int64(message.offset)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetLedgerEndResponse
 */
export const GetLedgerEndResponse = new GetLedgerEndResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetLatestPrunedOffsetsRequest$Type extends MessageType<GetLatestPrunedOffsetsRequest> {
    constructor() {
        super('com.daml.ledger.api.v2.GetLatestPrunedOffsetsRequest', [])
    }
    create(
        value?: PartialMessage<GetLatestPrunedOffsetsRequest>
    ): GetLatestPrunedOffsetsRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<GetLatestPrunedOffsetsRequest>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetLatestPrunedOffsetsRequest
    ): GetLatestPrunedOffsetsRequest {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GetLatestPrunedOffsetsRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetLatestPrunedOffsetsRequest
 */
export const GetLatestPrunedOffsetsRequest =
    new GetLatestPrunedOffsetsRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetLatestPrunedOffsetsResponse$Type extends MessageType<GetLatestPrunedOffsetsResponse> {
    constructor() {
        super('com.daml.ledger.api.v2.GetLatestPrunedOffsetsResponse', [
            {
                no: 1,
                name: 'participant_pruned_up_to_inclusive',
                kind: 'scalar',
                T: 3 /*ScalarType.INT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            {
                no: 2,
                name: 'all_divulged_contracts_pruned_up_to_inclusive',
                kind: 'scalar',
                T: 3 /*ScalarType.INT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
        ])
    }
    create(
        value?: PartialMessage<GetLatestPrunedOffsetsResponse>
    ): GetLatestPrunedOffsetsResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.participantPrunedUpToInclusive = 0n
        message.allDivulgedContractsPrunedUpToInclusive = 0n
        if (value !== undefined)
            reflectionMergePartial<GetLatestPrunedOffsetsResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetLatestPrunedOffsetsResponse
    ): GetLatestPrunedOffsetsResponse {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* int64 participant_pruned_up_to_inclusive */ 1:
                    message.participantPrunedUpToInclusive = reader
                        .int64()
                        .toBigInt()
                    break
                case /* int64 all_divulged_contracts_pruned_up_to_inclusive */ 2:
                    message.allDivulgedContractsPrunedUpToInclusive = reader
                        .int64()
                        .toBigInt()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GetLatestPrunedOffsetsResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* int64 participant_pruned_up_to_inclusive = 1; */
        if (message.participantPrunedUpToInclusive !== 0n)
            writer
                .tag(1, WireType.Varint)
                .int64(message.participantPrunedUpToInclusive)
        /* int64 all_divulged_contracts_pruned_up_to_inclusive = 2; */
        if (message.allDivulgedContractsPrunedUpToInclusive !== 0n)
            writer
                .tag(2, WireType.Varint)
                .int64(message.allDivulgedContractsPrunedUpToInclusive)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.GetLatestPrunedOffsetsResponse
 */
export const GetLatestPrunedOffsetsResponse =
    new GetLatestPrunedOffsetsResponse$Type()
/**
 * @generated ServiceType for protobuf service com.daml.ledger.api.v2.StateService
 */
export const StateService = new ServiceType(
    'com.daml.ledger.api.v2.StateService',
    [
        {
            name: 'GetActiveContracts',
            serverStreaming: true,
            options: {},
            I: GetActiveContractsRequest,
            O: GetActiveContractsResponse,
        },
        {
            name: 'GetConnectedSynchronizers',
            options: {},
            I: GetConnectedSynchronizersRequest,
            O: GetConnectedSynchronizersResponse,
        },
        {
            name: 'GetLedgerEnd',
            options: {},
            I: GetLedgerEndRequest,
            O: GetLedgerEndResponse,
        },
        {
            name: 'GetLatestPrunedOffsets',
            options: {},
            I: GetLatestPrunedOffsetsRequest,
            O: GetLatestPrunedOffsetsResponse,
        },
    ]
)
