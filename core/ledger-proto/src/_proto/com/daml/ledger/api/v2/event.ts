// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/event.proto" (package "com.daml.ledger.api.v2", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { Status } from '../../../../../google/rpc/status.js'
import { Timestamp } from '../../../../../google/protobuf/timestamp.js'
import { Record } from './value.js'
import { Value } from './value.js'
import { Identifier } from './value.js'
/**
 * Events in transactions can have two primary shapes:
 *
 * - ACS delta: events can be CreatedEvent or ArchivedEvent
 * - ledger effects: events can be CreatedEvent or ExercisedEvent
 *
 * In the update service the events are restricted to the events
 * visible for the parties specified in the transaction filter. Each
 * event message type below contains a ``witness_parties`` field which
 * indicates the subset of the requested parties that can see the event
 * in question.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.Event
 */
export interface Event {
    /**
     * @generated from protobuf oneof: event
     */
    event:
        | {
              oneofKind: 'created'
              /**
               * The event as it appeared in the context of its original daml transaction on this participant node.
               * In particular, the offset, node_id pair of the daml transaction are preserved.
               *
               * @generated from protobuf field: com.daml.ledger.api.v2.CreatedEvent created = 1
               */
              created: CreatedEvent
          }
        | {
              oneofKind: 'archived'
              /**
               * @generated from protobuf field: com.daml.ledger.api.v2.ArchivedEvent archived = 2
               */
              archived: ArchivedEvent
          }
        | {
              oneofKind: 'exercised'
              /**
               * @generated from protobuf field: com.daml.ledger.api.v2.ExercisedEvent exercised = 3
               */
              exercised: ExercisedEvent
          }
        | {
              oneofKind: undefined
          }
}
/**
 * Records that a contract has been created, and choices may now be exercised on it.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.CreatedEvent
 */
export interface CreatedEvent {
    /**
     * The offset of origin, which has contextual meaning, please see description at messages that include a CreatedEvent.
     * Offsets are managed by the participant nodes.
     * Transactions can thus NOT be assumed to have the same offsets on different participant nodes.
     * Required, it is a valid absolute offset (positive integer)
     *
     * @generated from protobuf field: int64 offset = 1
     */
    offset: bigint
    /**
     * The position of this event in the originating transaction or reassignment.
     * The origin has contextual meaning, please see description at messages that include a CreatedEvent.
     * Node IDs are not necessarily equal across participants,
     * as these may see different projections/parts of transactions.
     * Required, must be valid node ID (non-negative integer)
     *
     * @generated from protobuf field: int32 node_id = 2
     */
    nodeId: number
    /**
     * The ID of the created contract.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string contract_id = 3
     */
    contractId: string
    /**
     * The template of the created contract.
     * The identifier uses the package-id reference format.
     *
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier template_id = 4
     */
    templateId?: Identifier
    /**
     * The key of the created contract.
     * This will be set if and only if ``create_arguments`` is set and ``template_id`` defines a contract key.
     * Optional
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Value contract_key = 5
     */
    contractKey?: Value
    /**
     * The arguments that have been used to create the contract.
     * Set either:
     *
     * - if there was a party, which is in the ``witness_parties`` of this event,
     *   and for which a ``CumulativeFilter`` exists with the ``template_id`` of this event
     *   among the ``template_filters``,
     * - or if there was a party, which is in the ``witness_parties`` of this event,
     *   and for which a wildcard filter exists (``Filters`` with a ``CumulativeFilter`` of ``WildcardFilter``).
     *
     * Optional
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Record create_arguments = 6
     */
    createArguments?: Record
    /**
     * Opaque representation of contract create event payload intended for forwarding
     * to an API server as a contract disclosed as part of a command
     * submission.
     * Optional
     *
     * @generated from protobuf field: bytes created_event_blob = 7
     */
    createdEventBlob: Uint8Array
    /**
     * Interface views specified in the transaction filter.
     * Includes an ``InterfaceView`` for each interface for which there is a ``InterfaceFilter`` with
     *
     * - its party in the ``witness_parties`` of this event,
     * - and which is implemented by the template of this event,
     * - and which has ``include_interface_view`` set.
     *
     * Optional
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.InterfaceView interface_views = 8
     */
    interfaceViews: InterfaceView[]
    /**
     * The parties that are notified of this event. When a ``CreatedEvent``
     * is returned as part of a transaction tree or ledger-effects transaction, this will include all
     * the parties specified in the ``TransactionFilter`` that are informees
     * of the event. If served as part of a ACS delta transaction those will
     * be limited to all parties specified in the ``TransactionFilter`` that
     * are stakeholders of the contract (i.e. either signatories or observers).
     * If the ``CreatedEvent`` is returned as part of an AssignedEvent,
     * ActiveContract or IncompleteUnassigned (so the event is related to
     * an assignment or unassignment): this will include all parties of the
     * ``TransactionFilter`` that are stakeholders of the contract.
     *
     * The behavior of reading create events visible to parties not hosted
     * on the participant node serving the Ledger API is undefined. Concretely,
     * there is neither a guarantee that the participant node will serve all their
     * create events on the ACS stream, nor is there a guarantee that matching archive
     * events are delivered for such create events.
     *
     * For most clients this is not a problem, as they only read events for parties
     * that are hosted on the participant node. If you need to read events
     * for parties that may not be hosted at all times on the participant node,
     * subscribe to the ``TopologyEvent``s for that party by setting a corresponding
     * ``UpdateFormat``.  Using these events, query the ACS as-of an offset where the
     * party is hosted on the participant node, and ignore create events at offsets
     * where the party is not hosted on the participant node.
     * Required
     *
     * @generated from protobuf field: repeated string witness_parties = 9
     */
    witnessParties: string[]
    /**
     * The signatories for this contract as specified by the template.
     * Required
     *
     * @generated from protobuf field: repeated string signatories = 10
     */
    signatories: string[]
    /**
     * The observers for this contract as specified explicitly by the template or implicitly as choice controllers.
     * This field never contains parties that are signatories.
     * Required
     *
     * @generated from protobuf field: repeated string observers = 11
     */
    observers: string[]
    /**
     * Ledger effective time of the transaction that created the contract.
     * Required
     *
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 12
     */
    createdAt?: Timestamp
    /**
     * The package name of the created contract.
     * Required
     *
     * @generated from protobuf field: string package_name = 13
     */
    packageName: string
}
/**
 * View of a create event matched by an interface filter.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.InterfaceView
 */
export interface InterfaceView {
    /**
     * The interface implemented by the matched event.
     * The identifier uses the package-id reference format.
     *
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier interface_id = 1
     */
    interfaceId?: Identifier
    /**
     * Whether the view was successfully computed, and if not,
     * the reason for the error. The error is reported using the same rules
     * for error codes and messages as the errors returned for API requests.
     * Required
     *
     * @generated from protobuf field: google.rpc.Status view_status = 2
     */
    viewStatus?: Status
    /**
     * The value of the interface's view method on this event.
     * Set if it was requested in the ``InterfaceFilter`` and it could be
     * sucessfully computed.
     * Optional
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Record view_value = 3
     */
    viewValue?: Record
}
/**
 * Records that a contract has been archived, and choices may no longer be exercised on it.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.ArchivedEvent
 */
export interface ArchivedEvent {
    /**
     * The offset of origin.
     * Offsets are managed by the participant nodes.
     * Transactions can thus NOT be assumed to have the same offsets on different participant nodes.
     * Required, it is a valid absolute offset (positive integer)
     *
     * @generated from protobuf field: int64 offset = 1
     */
    offset: bigint
    /**
     * The position of this event in the originating transaction or reassignment.
     * Node IDs are not necessarily equal across participants,
     * as these may see different projections/parts of transactions.
     * Required, must be valid node ID (non-negative integer)
     *
     * @generated from protobuf field: int32 node_id = 2
     */
    nodeId: number
    /**
     * The ID of the archived contract.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string contract_id = 3
     */
    contractId: string
    /**
     * The template of the archived contract.
     * The identifier uses the package-id reference format.
     *
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier template_id = 4
     */
    templateId?: Identifier
    /**
     * The parties that are notified of this event. For an ``ArchivedEvent``,
     * these are the intersection of the stakeholders of the contract in
     * question and the parties specified in the ``TransactionFilter``. The
     * stakeholders are the union of the signatories and the observers of
     * the contract.
     * Each one of its elements must be a valid PartyIdString (as described
     * in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: repeated string witness_parties = 5
     */
    witnessParties: string[]
    /**
     * The package name of the contract.
     * Required
     *
     * @generated from protobuf field: string package_name = 6
     */
    packageName: string
    /**
     * The interfaces implemented by the target template that have been
     * matched from the interface filter query.
     * Populated only in case interface filters with include_interface_view set.
     *
     * If defined, the identifier uses the package-id reference format.
     *
     * Optional
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.Identifier implemented_interfaces = 7
     */
    implementedInterfaces: Identifier[]
}
/**
 * Records that a choice has been exercised on a target contract.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.ExercisedEvent
 */
export interface ExercisedEvent {
    /**
     * The offset of origin.
     * Offsets are managed by the participant nodes.
     * Transactions can thus NOT be assumed to have the same offsets on different participant nodes.
     * Required, it is a valid absolute offset (positive integer)
     *
     * @generated from protobuf field: int64 offset = 1
     */
    offset: bigint
    /**
     * The position of this event in the originating transaction or reassignment.
     * Node IDs are not necessarily equal across participants,
     * as these may see different projections/parts of transactions.
     * Required, must be valid node ID (non-negative integer)
     *
     * @generated from protobuf field: int32 node_id = 2
     */
    nodeId: number
    /**
     * The ID of the target contract.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string contract_id = 3
     */
    contractId: string
    /**
     * The template of the target contract.
     * The identifier uses the package-id reference format.
     *
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier template_id = 4
     */
    templateId?: Identifier
    /**
     * The interface where the choice is defined, if inherited.
     * If defined, the identifier uses the package-id reference format.
     *
     * Optional
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier interface_id = 5
     */
    interfaceId?: Identifier
    /**
     * The choice that was exercised on the target contract.
     * Must be a valid NameString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string choice = 6
     */
    choice: string
    /**
     * The argument of the exercised choice.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Value choice_argument = 7
     */
    choiceArgument?: Value
    /**
     * The parties that exercised the choice.
     * Each element must be a valid PartyIdString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: repeated string acting_parties = 8
     */
    actingParties: string[]
    /**
     * If true, the target contract may no longer be exercised.
     * Required
     *
     * @generated from protobuf field: bool consuming = 9
     */
    consuming: boolean
    /**
     * The parties that are notified of this event. The witnesses of an exercise
     * node will depend on whether the exercise was consuming or not.
     * If consuming, the witnesses are the union of the stakeholders and
     * the actors.
     * If not consuming, the witnesses are the union of the signatories and
     * the actors. Note that the actors might not necessarily be observers
     * and thus signatories. This is the case when the controllers of a
     * choice are specified using "flexible controllers", using the
     * ``choice ... controller`` syntax, and said controllers are not
     * explicitly marked as observers.
     * Each element must be a valid PartyIdString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: repeated string witness_parties = 10
     */
    witnessParties: string[]
    /**
     * Specifies the upper boundary of the node ids of the events in the same transaction that appeared as a result of
     * this ``ExercisedEvent``. This allows unambiguous identification of all the members of the subtree rooted at this
     * node. A full subtree can be constructed when all descendant nodes are present in the stream. If nodes are heavily
     * filtered, it is only possible to determine if a node is in a consequent subtree or not.
     * Required
     *
     * @generated from protobuf field: int32 last_descendant_node_id = 11
     */
    lastDescendantNodeId: number
    /**
     * The result of exercising the choice.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Value exercise_result = 12
     */
    exerciseResult?: Value
    /**
     * The package name of the contract.
     * Required
     *
     * @generated from protobuf field: string package_name = 13
     */
    packageName: string
    /**
     * If the event is consuming, the interfaces implemented by the target template that have been
     * matched from the interface filter query.
     * Populated only in case interface filters with include_interface_view set.
     *
     * The identifier uses the package-id reference format.
     *
     * Optional
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.Identifier implemented_interfaces = 14
     */
    implementedInterfaces: Identifier[]
}
// @generated message type with reflection information, may provide speed optimized methods
class Event$Type extends MessageType<Event> {
    constructor() {
        super('com.daml.ledger.api.v2.Event', [
            {
                no: 1,
                name: 'created',
                kind: 'message',
                oneof: 'event',
                T: () => CreatedEvent,
            },
            {
                no: 2,
                name: 'archived',
                kind: 'message',
                oneof: 'event',
                T: () => ArchivedEvent,
            },
            {
                no: 3,
                name: 'exercised',
                kind: 'message',
                oneof: 'event',
                T: () => ExercisedEvent,
            },
        ])
    }
    create(value?: PartialMessage<Event>): Event {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.event = { oneofKind: undefined }
        if (value !== undefined)
            reflectionMergePartial<Event>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Event
    ): Event {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.CreatedEvent created */ 1:
                    message.event = {
                        oneofKind: 'created',
                        created: CreatedEvent.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.event as any).created
                        ),
                    }
                    break
                case /* com.daml.ledger.api.v2.ArchivedEvent archived */ 2:
                    message.event = {
                        oneofKind: 'archived',
                        archived: ArchivedEvent.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.event as any).archived
                        ),
                    }
                    break
                case /* com.daml.ledger.api.v2.ExercisedEvent exercised */ 3:
                    message.event = {
                        oneofKind: 'exercised',
                        exercised: ExercisedEvent.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.event as any).exercised
                        ),
                    }
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: Event,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.CreatedEvent created = 1; */
        if (message.event.oneofKind === 'created')
            CreatedEvent.internalBinaryWrite(
                message.event.created,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.ArchivedEvent archived = 2; */
        if (message.event.oneofKind === 'archived')
            ArchivedEvent.internalBinaryWrite(
                message.event.archived,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.ExercisedEvent exercised = 3; */
        if (message.event.oneofKind === 'exercised')
            ExercisedEvent.internalBinaryWrite(
                message.event.exercised,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.Event
 */
export const Event = new Event$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CreatedEvent$Type extends MessageType<CreatedEvent> {
    constructor() {
        super('com.daml.ledger.api.v2.CreatedEvent', [
            {
                no: 1,
                name: 'offset',
                kind: 'scalar',
                T: 3 /*ScalarType.INT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            {
                no: 2,
                name: 'node_id',
                kind: 'scalar',
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 3,
                name: 'contract_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 4,
                name: 'template_id',
                kind: 'message',
                T: () => Identifier,
            },
            { no: 5, name: 'contract_key', kind: 'message', T: () => Value },
            {
                no: 6,
                name: 'create_arguments',
                kind: 'message',
                T: () => Record,
            },
            {
                no: 7,
                name: 'created_event_blob',
                kind: 'scalar',
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 8,
                name: 'interface_views',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => InterfaceView,
            },
            {
                no: 9,
                name: 'witness_parties',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 10,
                name: 'signatories',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 11,
                name: 'observers',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/,
            },
            { no: 12, name: 'created_at', kind: 'message', T: () => Timestamp },
            {
                no: 13,
                name: 'package_name',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
        ])
    }
    create(value?: PartialMessage<CreatedEvent>): CreatedEvent {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.offset = 0n
        message.nodeId = 0
        message.contractId = ''
        message.createdEventBlob = new Uint8Array(0)
        message.interfaceViews = []
        message.witnessParties = []
        message.signatories = []
        message.observers = []
        message.packageName = ''
        if (value !== undefined)
            reflectionMergePartial<CreatedEvent>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CreatedEvent
    ): CreatedEvent {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* int64 offset */ 1:
                    message.offset = reader.int64().toBigInt()
                    break
                case /* int32 node_id */ 2:
                    message.nodeId = reader.int32()
                    break
                case /* string contract_id */ 3:
                    message.contractId = reader.string()
                    break
                case /* com.daml.ledger.api.v2.Identifier template_id */ 4:
                    message.templateId = Identifier.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.templateId
                    )
                    break
                case /* com.daml.ledger.api.v2.Value contract_key */ 5:
                    message.contractKey = Value.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.contractKey
                    )
                    break
                case /* com.daml.ledger.api.v2.Record create_arguments */ 6:
                    message.createArguments = Record.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.createArguments
                    )
                    break
                case /* bytes created_event_blob */ 7:
                    message.createdEventBlob = reader.bytes()
                    break
                case /* repeated com.daml.ledger.api.v2.InterfaceView interface_views */ 8:
                    message.interfaceViews.push(
                        InterfaceView.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                case /* repeated string witness_parties */ 9:
                    message.witnessParties.push(reader.string())
                    break
                case /* repeated string signatories */ 10:
                    message.signatories.push(reader.string())
                    break
                case /* repeated string observers */ 11:
                    message.observers.push(reader.string())
                    break
                case /* google.protobuf.Timestamp created_at */ 12:
                    message.createdAt = Timestamp.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.createdAt
                    )
                    break
                case /* string package_name */ 13:
                    message.packageName = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: CreatedEvent,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* int64 offset = 1; */
        if (message.offset !== 0n)
            writer.tag(1, WireType.Varint).int64(message.offset)
        /* int32 node_id = 2; */
        if (message.nodeId !== 0)
            writer.tag(2, WireType.Varint).int32(message.nodeId)
        /* string contract_id = 3; */
        if (message.contractId !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.contractId)
        /* com.daml.ledger.api.v2.Identifier template_id = 4; */
        if (message.templateId)
            Identifier.internalBinaryWrite(
                message.templateId,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.Value contract_key = 5; */
        if (message.contractKey)
            Value.internalBinaryWrite(
                message.contractKey,
                writer.tag(5, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.Record create_arguments = 6; */
        if (message.createArguments)
            Record.internalBinaryWrite(
                message.createArguments,
                writer.tag(6, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* bytes created_event_blob = 7; */
        if (message.createdEventBlob.length)
            writer
                .tag(7, WireType.LengthDelimited)
                .bytes(message.createdEventBlob)
        /* repeated com.daml.ledger.api.v2.InterfaceView interface_views = 8; */
        for (let i = 0; i < message.interfaceViews.length; i++)
            InterfaceView.internalBinaryWrite(
                message.interfaceViews[i],
                writer.tag(8, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* repeated string witness_parties = 9; */
        for (let i = 0; i < message.witnessParties.length; i++)
            writer
                .tag(9, WireType.LengthDelimited)
                .string(message.witnessParties[i])
        /* repeated string signatories = 10; */
        for (let i = 0; i < message.signatories.length; i++)
            writer
                .tag(10, WireType.LengthDelimited)
                .string(message.signatories[i])
        /* repeated string observers = 11; */
        for (let i = 0; i < message.observers.length; i++)
            writer
                .tag(11, WireType.LengthDelimited)
                .string(message.observers[i])
        /* google.protobuf.Timestamp created_at = 12; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(
                message.createdAt,
                writer.tag(12, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* string package_name = 13; */
        if (message.packageName !== '')
            writer.tag(13, WireType.LengthDelimited).string(message.packageName)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.CreatedEvent
 */
export const CreatedEvent = new CreatedEvent$Type()
// @generated message type with reflection information, may provide speed optimized methods
class InterfaceView$Type extends MessageType<InterfaceView> {
    constructor() {
        super('com.daml.ledger.api.v2.InterfaceView', [
            {
                no: 1,
                name: 'interface_id',
                kind: 'message',
                T: () => Identifier,
            },
            { no: 2, name: 'view_status', kind: 'message', T: () => Status },
            { no: 3, name: 'view_value', kind: 'message', T: () => Record },
        ])
    }
    create(value?: PartialMessage<InterfaceView>): InterfaceView {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<InterfaceView>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: InterfaceView
    ): InterfaceView {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Identifier interface_id */ 1:
                    message.interfaceId = Identifier.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.interfaceId
                    )
                    break
                case /* google.rpc.Status view_status */ 2:
                    message.viewStatus = Status.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.viewStatus
                    )
                    break
                case /* com.daml.ledger.api.v2.Record view_value */ 3:
                    message.viewValue = Record.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.viewValue
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: InterfaceView,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.Identifier interface_id = 1; */
        if (message.interfaceId)
            Identifier.internalBinaryWrite(
                message.interfaceId,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* google.rpc.Status view_status = 2; */
        if (message.viewStatus)
            Status.internalBinaryWrite(
                message.viewStatus,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.Record view_value = 3; */
        if (message.viewValue)
            Record.internalBinaryWrite(
                message.viewValue,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.InterfaceView
 */
export const InterfaceView = new InterfaceView$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ArchivedEvent$Type extends MessageType<ArchivedEvent> {
    constructor() {
        super('com.daml.ledger.api.v2.ArchivedEvent', [
            {
                no: 1,
                name: 'offset',
                kind: 'scalar',
                T: 3 /*ScalarType.INT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            {
                no: 2,
                name: 'node_id',
                kind: 'scalar',
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 3,
                name: 'contract_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 4,
                name: 'template_id',
                kind: 'message',
                T: () => Identifier,
            },
            {
                no: 5,
                name: 'witness_parties',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 6,
                name: 'package_name',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 7,
                name: 'implemented_interfaces',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => Identifier,
            },
        ])
    }
    create(value?: PartialMessage<ArchivedEvent>): ArchivedEvent {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.offset = 0n
        message.nodeId = 0
        message.contractId = ''
        message.witnessParties = []
        message.packageName = ''
        message.implementedInterfaces = []
        if (value !== undefined)
            reflectionMergePartial<ArchivedEvent>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ArchivedEvent
    ): ArchivedEvent {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* int64 offset */ 1:
                    message.offset = reader.int64().toBigInt()
                    break
                case /* int32 node_id */ 2:
                    message.nodeId = reader.int32()
                    break
                case /* string contract_id */ 3:
                    message.contractId = reader.string()
                    break
                case /* com.daml.ledger.api.v2.Identifier template_id */ 4:
                    message.templateId = Identifier.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.templateId
                    )
                    break
                case /* repeated string witness_parties */ 5:
                    message.witnessParties.push(reader.string())
                    break
                case /* string package_name */ 6:
                    message.packageName = reader.string()
                    break
                case /* repeated com.daml.ledger.api.v2.Identifier implemented_interfaces */ 7:
                    message.implementedInterfaces.push(
                        Identifier.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: ArchivedEvent,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* int64 offset = 1; */
        if (message.offset !== 0n)
            writer.tag(1, WireType.Varint).int64(message.offset)
        /* int32 node_id = 2; */
        if (message.nodeId !== 0)
            writer.tag(2, WireType.Varint).int32(message.nodeId)
        /* string contract_id = 3; */
        if (message.contractId !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.contractId)
        /* com.daml.ledger.api.v2.Identifier template_id = 4; */
        if (message.templateId)
            Identifier.internalBinaryWrite(
                message.templateId,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* repeated string witness_parties = 5; */
        for (let i = 0; i < message.witnessParties.length; i++)
            writer
                .tag(5, WireType.LengthDelimited)
                .string(message.witnessParties[i])
        /* string package_name = 6; */
        if (message.packageName !== '')
            writer.tag(6, WireType.LengthDelimited).string(message.packageName)
        /* repeated com.daml.ledger.api.v2.Identifier implemented_interfaces = 7; */
        for (let i = 0; i < message.implementedInterfaces.length; i++)
            Identifier.internalBinaryWrite(
                message.implementedInterfaces[i],
                writer.tag(7, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.ArchivedEvent
 */
export const ArchivedEvent = new ArchivedEvent$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ExercisedEvent$Type extends MessageType<ExercisedEvent> {
    constructor() {
        super('com.daml.ledger.api.v2.ExercisedEvent', [
            {
                no: 1,
                name: 'offset',
                kind: 'scalar',
                T: 3 /*ScalarType.INT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            {
                no: 2,
                name: 'node_id',
                kind: 'scalar',
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 3,
                name: 'contract_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 4,
                name: 'template_id',
                kind: 'message',
                T: () => Identifier,
            },
            {
                no: 5,
                name: 'interface_id',
                kind: 'message',
                T: () => Identifier,
            },
            {
                no: 6,
                name: 'choice',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            { no: 7, name: 'choice_argument', kind: 'message', T: () => Value },
            {
                no: 8,
                name: 'acting_parties',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 9,
                name: 'consuming',
                kind: 'scalar',
                T: 8 /*ScalarType.BOOL*/,
            },
            {
                no: 10,
                name: 'witness_parties',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 11,
                name: 'last_descendant_node_id',
                kind: 'scalar',
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 12,
                name: 'exercise_result',
                kind: 'message',
                T: () => Value,
            },
            {
                no: 13,
                name: 'package_name',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 14,
                name: 'implemented_interfaces',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => Identifier,
            },
        ])
    }
    create(value?: PartialMessage<ExercisedEvent>): ExercisedEvent {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.offset = 0n
        message.nodeId = 0
        message.contractId = ''
        message.choice = ''
        message.actingParties = []
        message.consuming = false
        message.witnessParties = []
        message.lastDescendantNodeId = 0
        message.packageName = ''
        message.implementedInterfaces = []
        if (value !== undefined)
            reflectionMergePartial<ExercisedEvent>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ExercisedEvent
    ): ExercisedEvent {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* int64 offset */ 1:
                    message.offset = reader.int64().toBigInt()
                    break
                case /* int32 node_id */ 2:
                    message.nodeId = reader.int32()
                    break
                case /* string contract_id */ 3:
                    message.contractId = reader.string()
                    break
                case /* com.daml.ledger.api.v2.Identifier template_id */ 4:
                    message.templateId = Identifier.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.templateId
                    )
                    break
                case /* com.daml.ledger.api.v2.Identifier interface_id */ 5:
                    message.interfaceId = Identifier.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.interfaceId
                    )
                    break
                case /* string choice */ 6:
                    message.choice = reader.string()
                    break
                case /* com.daml.ledger.api.v2.Value choice_argument */ 7:
                    message.choiceArgument = Value.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.choiceArgument
                    )
                    break
                case /* repeated string acting_parties */ 8:
                    message.actingParties.push(reader.string())
                    break
                case /* bool consuming */ 9:
                    message.consuming = reader.bool()
                    break
                case /* repeated string witness_parties */ 10:
                    message.witnessParties.push(reader.string())
                    break
                case /* int32 last_descendant_node_id */ 11:
                    message.lastDescendantNodeId = reader.int32()
                    break
                case /* com.daml.ledger.api.v2.Value exercise_result */ 12:
                    message.exerciseResult = Value.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.exerciseResult
                    )
                    break
                case /* string package_name */ 13:
                    message.packageName = reader.string()
                    break
                case /* repeated com.daml.ledger.api.v2.Identifier implemented_interfaces */ 14:
                    message.implementedInterfaces.push(
                        Identifier.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: ExercisedEvent,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* int64 offset = 1; */
        if (message.offset !== 0n)
            writer.tag(1, WireType.Varint).int64(message.offset)
        /* int32 node_id = 2; */
        if (message.nodeId !== 0)
            writer.tag(2, WireType.Varint).int32(message.nodeId)
        /* string contract_id = 3; */
        if (message.contractId !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.contractId)
        /* com.daml.ledger.api.v2.Identifier template_id = 4; */
        if (message.templateId)
            Identifier.internalBinaryWrite(
                message.templateId,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.Identifier interface_id = 5; */
        if (message.interfaceId)
            Identifier.internalBinaryWrite(
                message.interfaceId,
                writer.tag(5, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* string choice = 6; */
        if (message.choice !== '')
            writer.tag(6, WireType.LengthDelimited).string(message.choice)
        /* com.daml.ledger.api.v2.Value choice_argument = 7; */
        if (message.choiceArgument)
            Value.internalBinaryWrite(
                message.choiceArgument,
                writer.tag(7, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* repeated string acting_parties = 8; */
        for (let i = 0; i < message.actingParties.length; i++)
            writer
                .tag(8, WireType.LengthDelimited)
                .string(message.actingParties[i])
        /* bool consuming = 9; */
        if (message.consuming !== false)
            writer.tag(9, WireType.Varint).bool(message.consuming)
        /* repeated string witness_parties = 10; */
        for (let i = 0; i < message.witnessParties.length; i++)
            writer
                .tag(10, WireType.LengthDelimited)
                .string(message.witnessParties[i])
        /* int32 last_descendant_node_id = 11; */
        if (message.lastDescendantNodeId !== 0)
            writer.tag(11, WireType.Varint).int32(message.lastDescendantNodeId)
        /* com.daml.ledger.api.v2.Value exercise_result = 12; */
        if (message.exerciseResult)
            Value.internalBinaryWrite(
                message.exerciseResult,
                writer.tag(12, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* string package_name = 13; */
        if (message.packageName !== '')
            writer.tag(13, WireType.LengthDelimited).string(message.packageName)
        /* repeated com.daml.ledger.api.v2.Identifier implemented_interfaces = 14; */
        for (let i = 0; i < message.implementedInterfaces.length; i++)
            Identifier.internalBinaryWrite(
                message.implementedInterfaces[i],
                writer.tag(14, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.ExercisedEvent
 */
export const ExercisedEvent = new ExercisedEvent$Type()
