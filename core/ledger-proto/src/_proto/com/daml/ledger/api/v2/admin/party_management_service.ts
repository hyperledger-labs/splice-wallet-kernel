// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/admin/party_management_service.proto" (package "com.daml.ledger.api.v2.admin", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import { ServiceType } from '@protobuf-ts/runtime-rpc'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { SigningPublicKey } from '../crypto.js'
import { FieldMask } from '../../../../../../google/protobuf/field_mask.js'
import { Signature } from '../interactive/interactive_submission_service.js'
import { ObjectMeta } from './object_meta.js'
/**
 * Required authorization: ``HasRight(ParticipantAdmin)``
 *
 * @generated from protobuf message com.daml.ledger.api.v2.admin.GetParticipantIdRequest
 */
export interface GetParticipantIdRequest {}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.admin.GetParticipantIdResponse
 */
export interface GetParticipantIdResponse {
    /**
     * Identifier of the participant, which SHOULD be globally unique.
     * Must be a valid LedgerString (as describe in ``value.proto``).
     *
     * @generated from protobuf field: string participant_id = 1
     */
    participantId: string
}
/**
 * Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
 *
 * @generated from protobuf message com.daml.ledger.api.v2.admin.GetPartiesRequest
 */
export interface GetPartiesRequest {
    /**
     * The stable, unique identifier of the Daml parties.
     * Must be valid PartyIdStrings (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: repeated string parties = 1
     */
    parties: string[]
    /**
     * The id of the ``Identity Provider`` whose parties should be retrieved.
     * Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.
     *
     * @generated from protobuf field: string identity_provider_id = 2
     */
    identityProviderId: string
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.admin.GetPartiesResponse
 */
export interface GetPartiesResponse {
    /**
     * The details of the requested Daml parties by the participant, if known.
     * The party details may not be in the same order as requested.
     * Required
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.admin.PartyDetails party_details = 1
     */
    partyDetails: PartyDetails[]
}
/**
 * Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
 *
 * @generated from protobuf message com.daml.ledger.api.v2.admin.ListKnownPartiesRequest
 */
export interface ListKnownPartiesRequest {
    /**
     * Pagination token to determine the specific page to fetch. Using the token guarantees that parties on a subsequent
     * page are all lexically greater than the last party on a previous page. Server does not store intermediate results
     * between calls chained by a series of page tokens. As a consequence, if new parties are being added and a page is
     * requested twice using the same token, more parties can be returned on the second call.
     * Leave empty to fetch the first page.
     * Optional
     *
     * @generated from protobuf field: string page_token = 2
     */
    pageToken: string
    /**
     * Maximum number of results to be returned by the server. The server will return no more than that many results,
     * but it might return fewer. If the page_size is 0, the server will decide the number of results to be returned.
     * If the page_size exceeds the maximum supported by the server, an error will be returned. To obtain the server's
     * maximum consult the PartyManagementFeature descriptor available in the VersionService.
     * Optional
     *
     * @generated from protobuf field: int32 page_size = 3
     */
    pageSize: number
    /**
     * The id of the ``Identity Provider`` whose parties should be retrieved.
     * Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.
     *
     * @generated from protobuf field: string identity_provider_id = 1
     */
    identityProviderId: string
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.admin.ListKnownPartiesResponse
 */
export interface ListKnownPartiesResponse {
    /**
     * The details of all Daml parties known by the participant.
     * Required
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.admin.PartyDetails party_details = 1
     */
    partyDetails: PartyDetails[]
    /**
     * Pagination token to retrieve the next page.
     * Empty, if there are no further results.
     *
     * @generated from protobuf field: string next_page_token = 2
     */
    nextPageToken: string
}
/**
 * Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
 *
 * @generated from protobuf message com.daml.ledger.api.v2.admin.AllocatePartyRequest
 */
export interface AllocatePartyRequest {
    /**
     * A hint to the participant which party ID to allocate. It can be
     * ignored.
     * Must be a valid PartyIdString (as described in ``value.proto``).
     * Optional
     *
     * @generated from protobuf field: string party_id_hint = 1
     */
    partyIdHint: string
    /**
     * Participant-local metadata to be stored in the ``PartyDetails`` of this newly allocated party.
     * Optional
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.admin.ObjectMeta local_metadata = 3
     */
    localMetadata?: ObjectMeta
    /**
     * The id of the ``Identity Provider``
     * Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.
     *
     * @generated from protobuf field: string identity_provider_id = 4
     */
    identityProviderId: string
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.admin.AllocatePartyResponse
 */
export interface AllocatePartyResponse {
    /**
     * @generated from protobuf field: com.daml.ledger.api.v2.admin.PartyDetails party_details = 1
     */
    partyDetails?: PartyDetails
}
/**
 * Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)``
 *
 * @generated from protobuf message com.daml.ledger.api.v2.admin.AllocateExternalPartyRequest
 */
export interface AllocateExternalPartyRequest {
    /**
     * TODO(#27670) support synchronizer aliases
     * Synchronizer ID on which to onboard the party
     * Required
     *
     * @generated from protobuf field: string synchronizer = 1
     */
    synchronizer: string
    /**
     * TopologyTransactions to onboard the external party
     * Can contain:
     * - A namespace for the party.
     * This can be either a single NamespaceDelegation,
     * or DecentralizedNamespaceDefinition along with its authorized namespace owners in the form of NamespaceDelegations.
     * May be provided, if so it must be fully authorized by the signatures in this request combined with the existing topology state.
     * - A PartyToKeyMapping to register the party's signing keys.
     * May be provided, if so it must be fully authorized by the signatures in this request combined with the existing topology state.
     * - A PartyToParticipant to register the hosting relationship of the party.
     * Must be provided.
     * Required
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.admin.AllocateExternalPartyRequest.SignedTransaction onboarding_transactions = 2
     */
    onboardingTransactions: AllocateExternalPartyRequest_SignedTransaction[]
    /**
     * Optional signatures of the combined hash of all onboarding_transactions
     * This may be used instead of providing signatures on each individual transaction
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.interactive.Signature multi_hash_signatures = 3
     */
    multiHashSignatures: Signature[]
    /**
     * The id of the ``Identity Provider``
     * If not set, assume the party is managed by the default identity provider.
     * Optional
     *
     * @generated from protobuf field: string identity_provider_id = 4
     */
    identityProviderId: string
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.admin.AllocateExternalPartyRequest.SignedTransaction
 */
export interface AllocateExternalPartyRequest_SignedTransaction {
    /**
     * The serialized TopologyTransaction
     *
     * @generated from protobuf field: bytes transaction = 1
     */
    transaction: Uint8Array
    /**
     * Additional signatures for this transaction specifically
     * Use for transactions that require additional signatures beyond the namespace key signatures
     * e.g: PartyToKeyMapping must be signed by all registered keys
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.interactive.Signature signatures = 2
     */
    signatures: Signature[]
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.admin.AllocateExternalPartyResponse
 */
export interface AllocateExternalPartyResponse {
    /**
     * @generated from protobuf field: string party_id = 1
     */
    partyId: string
}
/**
 * Required authorization: ``HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(party_details.identity_provider_id)``
 *
 * @generated from protobuf message com.daml.ledger.api.v2.admin.UpdatePartyDetailsRequest
 */
export interface UpdatePartyDetailsRequest {
    /**
     * Party to be updated
     * Required,
     * Modifiable
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.admin.PartyDetails party_details = 1
     */
    partyDetails?: PartyDetails
    /**
     * An update mask specifies how and which properties of the ``PartyDetails`` message are to be updated.
     * An update mask consists of a set of update paths.
     * A valid update path points to a field or a subfield relative to the ``PartyDetails`` message.
     * A valid update mask must:
     *
     * 1. contain at least one update path,
     * 2. contain only valid update paths.
     *
     * Fields that can be updated are marked as ``Modifiable``.
     * An update path can also point to non-``Modifiable`` fields such as 'party' and 'local_metadata.resource_version'
     * because they are used:
     *
     * 1. to identify the party details resource subject to the update,
     * 2. for concurrent change control.
     *
     * An update path can also point to non-``Modifiable`` fields such as 'is_local'
     * as long as the values provided in the update request match the server values.
     * Examples of update paths: 'local_metadata.annotations', 'local_metadata'.
     * For additional information see the documentation for standard protobuf3's ``google.protobuf.FieldMask``.
     * For similar Ledger API see ``com.daml.ledger.api.v2.admin.UpdateUserRequest``.
     * Required
     *
     * @generated from protobuf field: google.protobuf.FieldMask update_mask = 2
     */
    updateMask?: FieldMask
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.admin.UpdatePartyDetailsResponse
 */
export interface UpdatePartyDetailsResponse {
    /**
     * Updated party details
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.admin.PartyDetails party_details = 1
     */
    partyDetails?: PartyDetails
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.admin.PartyDetails
 */
export interface PartyDetails {
    /**
     * The stable unique identifier of a Daml party.
     * Must be a valid PartyIdString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string party = 1
     */
    party: string
    /**
     * true if party is hosted by the participant and the party shares the same identity provider as the user issuing the request.
     * Optional
     *
     * @generated from protobuf field: bool is_local = 3
     */
    isLocal: boolean
    /**
     * Participant-local metadata of this party.
     * Optional,
     * Modifiable
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.admin.ObjectMeta local_metadata = 4
     */
    localMetadata?: ObjectMeta
    /**
     * The id of the ``Identity Provider``
     * Optional, if not set, there could be 3 options:
     *
     * 1. the party is managed by the default identity provider.
     * 2. party is not hosted by the participant.
     * 3. party is hosted by the participant, but is outside of the user's identity provider.
     *
     * @generated from protobuf field: string identity_provider_id = 5
     */
    identityProviderId: string
}
/**
 * Required authorization: ``HasRight(ParticipantAdmin)``
 *
 * @generated from protobuf message com.daml.ledger.api.v2.admin.UpdatePartyIdentityProviderIdRequest
 */
export interface UpdatePartyIdentityProviderIdRequest {
    /**
     * Party to update
     *
     * @generated from protobuf field: string party = 1
     */
    party: string
    /**
     * Current identity provider id of the party
     *
     * @generated from protobuf field: string source_identity_provider_id = 2
     */
    sourceIdentityProviderId: string
    /**
     * Target identity provider id of the party
     *
     * @generated from protobuf field: string target_identity_provider_id = 3
     */
    targetIdentityProviderId: string
}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.admin.UpdatePartyIdentityProviderIdResponse
 */
export interface UpdatePartyIdentityProviderIdResponse {}
/**
 * @generated from protobuf message com.daml.ledger.api.v2.admin.GenerateExternalPartyTopologyRequest
 */
export interface GenerateExternalPartyTopologyRequest {
    /**
     * TODO(#27670) support synchronizer aliases
     * Required: synchronizer-id for which we are building this request.
     *
     * @generated from protobuf field: string synchronizer = 1
     */
    synchronizer: string
    /**
     * Required: the actual party id will be constructed from this hint and a fingerprint of the public key
     *
     * @generated from protobuf field: string party_hint = 2
     */
    partyHint: string
    /**
     * Required: public key
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.SigningPublicKey public_key = 3
     */
    publicKey?: SigningPublicKey
    /**
     * Optional: if true, then the local participant will only be observing, not confirming. Default false.
     *
     * @generated from protobuf field: bool local_participant_observation_only = 4
     */
    localParticipantObservationOnly: boolean
    /**
     * Optional: other participant ids which should be confirming for this party
     *
     * @generated from protobuf field: repeated string other_confirming_participant_uids = 5
     */
    otherConfirmingParticipantUids: string[]
    /**
     * Optional: Confirmation threshold >= 1 for the party. Defaults to all available confirmers (or if set to 0).
     *
     * @generated from protobuf field: uint32 confirmation_threshold = 6
     */
    confirmationThreshold: number
    /**
     * Optional: other observing participant ids for this party
     *
     * @generated from protobuf field: repeated string observing_participant_uids = 7
     */
    observingParticipantUids: string[]
}
/**
 * Response message with topology transactions and the multi-hash to be signed.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.admin.GenerateExternalPartyTopologyResponse
 */
export interface GenerateExternalPartyTopologyResponse {
    /**
     * the generated party id
     *
     * @generated from protobuf field: string party_id = 1
     */
    partyId: string
    /**
     * the fingerprint of the supplied public key
     *
     * @generated from protobuf field: string public_key_fingerprint = 2
     */
    publicKeyFingerprint: string
    /**
     * The serialized topology transactions which need to be signed and submitted as part of the allocate party process
     * Note that the serialization includes the versioning information. Therefore, the transaction here is serialized
     * as an `UntypedVersionedMessage` which in turn contains the serialized `TopologyTransaction` in the version
     * supported by the synchronizer.
     *
     * @generated from protobuf field: repeated bytes topology_transactions = 3
     */
    topologyTransactions: Uint8Array[]
    /**
     * the multi-hash which may be signed instead of each individual transaction
     *
     * @generated from protobuf field: bytes multi_hash = 4
     */
    multiHash: Uint8Array
}
// @generated message type with reflection information, may provide speed optimized methods
class GetParticipantIdRequest$Type extends MessageType<GetParticipantIdRequest> {
    constructor() {
        super('com.daml.ledger.api.v2.admin.GetParticipantIdRequest', [])
    }
    create(
        value?: PartialMessage<GetParticipantIdRequest>
    ): GetParticipantIdRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<GetParticipantIdRequest>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetParticipantIdRequest
    ): GetParticipantIdRequest {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GetParticipantIdRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.GetParticipantIdRequest
 */
export const GetParticipantIdRequest = new GetParticipantIdRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetParticipantIdResponse$Type extends MessageType<GetParticipantIdResponse> {
    constructor() {
        super('com.daml.ledger.api.v2.admin.GetParticipantIdResponse', [
            {
                no: 1,
                name: 'participant_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
        ])
    }
    create(
        value?: PartialMessage<GetParticipantIdResponse>
    ): GetParticipantIdResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.participantId = ''
        if (value !== undefined)
            reflectionMergePartial<GetParticipantIdResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetParticipantIdResponse
    ): GetParticipantIdResponse {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string participant_id */ 1:
                    message.participantId = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GetParticipantIdResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string participant_id = 1; */
        if (message.participantId !== '')
            writer
                .tag(1, WireType.LengthDelimited)
                .string(message.participantId)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.GetParticipantIdResponse
 */
export const GetParticipantIdResponse = new GetParticipantIdResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetPartiesRequest$Type extends MessageType<GetPartiesRequest> {
    constructor() {
        super('com.daml.ledger.api.v2.admin.GetPartiesRequest', [
            {
                no: 1,
                name: 'parties',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'identity_provider_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
        ])
    }
    create(value?: PartialMessage<GetPartiesRequest>): GetPartiesRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.parties = []
        message.identityProviderId = ''
        if (value !== undefined)
            reflectionMergePartial<GetPartiesRequest>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetPartiesRequest
    ): GetPartiesRequest {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated string parties */ 1:
                    message.parties.push(reader.string())
                    break
                case /* string identity_provider_id */ 2:
                    message.identityProviderId = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GetPartiesRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated string parties = 1; */
        for (let i = 0; i < message.parties.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.parties[i])
        /* string identity_provider_id = 2; */
        if (message.identityProviderId !== '')
            writer
                .tag(2, WireType.LengthDelimited)
                .string(message.identityProviderId)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.GetPartiesRequest
 */
export const GetPartiesRequest = new GetPartiesRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GetPartiesResponse$Type extends MessageType<GetPartiesResponse> {
    constructor() {
        super('com.daml.ledger.api.v2.admin.GetPartiesResponse', [
            {
                no: 1,
                name: 'party_details',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => PartyDetails,
            },
        ])
    }
    create(value?: PartialMessage<GetPartiesResponse>): GetPartiesResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.partyDetails = []
        if (value !== undefined)
            reflectionMergePartial<GetPartiesResponse>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GetPartiesResponse
    ): GetPartiesResponse {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated com.daml.ledger.api.v2.admin.PartyDetails party_details */ 1:
                    message.partyDetails.push(
                        PartyDetails.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GetPartiesResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated com.daml.ledger.api.v2.admin.PartyDetails party_details = 1; */
        for (let i = 0; i < message.partyDetails.length; i++)
            PartyDetails.internalBinaryWrite(
                message.partyDetails[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.GetPartiesResponse
 */
export const GetPartiesResponse = new GetPartiesResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ListKnownPartiesRequest$Type extends MessageType<ListKnownPartiesRequest> {
    constructor() {
        super('com.daml.ledger.api.v2.admin.ListKnownPartiesRequest', [
            {
                no: 2,
                name: 'page_token',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 3,
                name: 'page_size',
                kind: 'scalar',
                T: 5 /*ScalarType.INT32*/,
            },
            {
                no: 1,
                name: 'identity_provider_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
        ])
    }
    create(
        value?: PartialMessage<ListKnownPartiesRequest>
    ): ListKnownPartiesRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.pageToken = ''
        message.pageSize = 0
        message.identityProviderId = ''
        if (value !== undefined)
            reflectionMergePartial<ListKnownPartiesRequest>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ListKnownPartiesRequest
    ): ListKnownPartiesRequest {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string page_token */ 2:
                    message.pageToken = reader.string()
                    break
                case /* int32 page_size */ 3:
                    message.pageSize = reader.int32()
                    break
                case /* string identity_provider_id */ 1:
                    message.identityProviderId = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: ListKnownPartiesRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string identity_provider_id = 1; */
        if (message.identityProviderId !== '')
            writer
                .tag(1, WireType.LengthDelimited)
                .string(message.identityProviderId)
        /* string page_token = 2; */
        if (message.pageToken !== '')
            writer.tag(2, WireType.LengthDelimited).string(message.pageToken)
        /* int32 page_size = 3; */
        if (message.pageSize !== 0)
            writer.tag(3, WireType.Varint).int32(message.pageSize)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.ListKnownPartiesRequest
 */
export const ListKnownPartiesRequest = new ListKnownPartiesRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ListKnownPartiesResponse$Type extends MessageType<ListKnownPartiesResponse> {
    constructor() {
        super('com.daml.ledger.api.v2.admin.ListKnownPartiesResponse', [
            {
                no: 1,
                name: 'party_details',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => PartyDetails,
            },
            {
                no: 2,
                name: 'next_page_token',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
        ])
    }
    create(
        value?: PartialMessage<ListKnownPartiesResponse>
    ): ListKnownPartiesResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.partyDetails = []
        message.nextPageToken = ''
        if (value !== undefined)
            reflectionMergePartial<ListKnownPartiesResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ListKnownPartiesResponse
    ): ListKnownPartiesResponse {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated com.daml.ledger.api.v2.admin.PartyDetails party_details */ 1:
                    message.partyDetails.push(
                        PartyDetails.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: ListKnownPartiesResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated com.daml.ledger.api.v2.admin.PartyDetails party_details = 1; */
        for (let i = 0; i < message.partyDetails.length; i++)
            PartyDetails.internalBinaryWrite(
                message.partyDetails[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* string next_page_token = 2; */
        if (message.nextPageToken !== '')
            writer
                .tag(2, WireType.LengthDelimited)
                .string(message.nextPageToken)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.ListKnownPartiesResponse
 */
export const ListKnownPartiesResponse = new ListKnownPartiesResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AllocatePartyRequest$Type extends MessageType<AllocatePartyRequest> {
    constructor() {
        super('com.daml.ledger.api.v2.admin.AllocatePartyRequest', [
            {
                no: 1,
                name: 'party_id_hint',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 3,
                name: 'local_metadata',
                kind: 'message',
                T: () => ObjectMeta,
            },
            {
                no: 4,
                name: 'identity_provider_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
        ])
    }
    create(value?: PartialMessage<AllocatePartyRequest>): AllocatePartyRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.partyIdHint = ''
        message.identityProviderId = ''
        if (value !== undefined)
            reflectionMergePartial<AllocatePartyRequest>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: AllocatePartyRequest
    ): AllocatePartyRequest {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string party_id_hint */ 1:
                    message.partyIdHint = reader.string()
                    break
                case /* com.daml.ledger.api.v2.admin.ObjectMeta local_metadata */ 3:
                    message.localMetadata = ObjectMeta.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.localMetadata
                    )
                    break
                case /* string identity_provider_id */ 4:
                    message.identityProviderId = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: AllocatePartyRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string party_id_hint = 1; */
        if (message.partyIdHint !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.partyIdHint)
        /* com.daml.ledger.api.v2.admin.ObjectMeta local_metadata = 3; */
        if (message.localMetadata)
            ObjectMeta.internalBinaryWrite(
                message.localMetadata,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* string identity_provider_id = 4; */
        if (message.identityProviderId !== '')
            writer
                .tag(4, WireType.LengthDelimited)
                .string(message.identityProviderId)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.AllocatePartyRequest
 */
export const AllocatePartyRequest = new AllocatePartyRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AllocatePartyResponse$Type extends MessageType<AllocatePartyResponse> {
    constructor() {
        super('com.daml.ledger.api.v2.admin.AllocatePartyResponse', [
            {
                no: 1,
                name: 'party_details',
                kind: 'message',
                T: () => PartyDetails,
            },
        ])
    }
    create(
        value?: PartialMessage<AllocatePartyResponse>
    ): AllocatePartyResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<AllocatePartyResponse>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: AllocatePartyResponse
    ): AllocatePartyResponse {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.admin.PartyDetails party_details */ 1:
                    message.partyDetails = PartyDetails.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.partyDetails
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: AllocatePartyResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.admin.PartyDetails party_details = 1; */
        if (message.partyDetails)
            PartyDetails.internalBinaryWrite(
                message.partyDetails,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.AllocatePartyResponse
 */
export const AllocatePartyResponse = new AllocatePartyResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AllocateExternalPartyRequest$Type extends MessageType<AllocateExternalPartyRequest> {
    constructor() {
        super('com.daml.ledger.api.v2.admin.AllocateExternalPartyRequest', [
            {
                no: 1,
                name: 'synchronizer',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'onboarding_transactions',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => AllocateExternalPartyRequest_SignedTransaction,
            },
            {
                no: 3,
                name: 'multi_hash_signatures',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => Signature,
            },
            {
                no: 4,
                name: 'identity_provider_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
        ])
    }
    create(
        value?: PartialMessage<AllocateExternalPartyRequest>
    ): AllocateExternalPartyRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.synchronizer = ''
        message.onboardingTransactions = []
        message.multiHashSignatures = []
        message.identityProviderId = ''
        if (value !== undefined)
            reflectionMergePartial<AllocateExternalPartyRequest>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: AllocateExternalPartyRequest
    ): AllocateExternalPartyRequest {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string synchronizer */ 1:
                    message.synchronizer = reader.string()
                    break
                case /* repeated com.daml.ledger.api.v2.admin.AllocateExternalPartyRequest.SignedTransaction onboarding_transactions */ 2:
                    message.onboardingTransactions.push(
                        AllocateExternalPartyRequest_SignedTransaction.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                case /* repeated com.daml.ledger.api.v2.interactive.Signature multi_hash_signatures */ 3:
                    message.multiHashSignatures.push(
                        Signature.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                case /* string identity_provider_id */ 4:
                    message.identityProviderId = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: AllocateExternalPartyRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string synchronizer = 1; */
        if (message.synchronizer !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.synchronizer)
        /* repeated com.daml.ledger.api.v2.admin.AllocateExternalPartyRequest.SignedTransaction onboarding_transactions = 2; */
        for (let i = 0; i < message.onboardingTransactions.length; i++)
            AllocateExternalPartyRequest_SignedTransaction.internalBinaryWrite(
                message.onboardingTransactions[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* repeated com.daml.ledger.api.v2.interactive.Signature multi_hash_signatures = 3; */
        for (let i = 0; i < message.multiHashSignatures.length; i++)
            Signature.internalBinaryWrite(
                message.multiHashSignatures[i],
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* string identity_provider_id = 4; */
        if (message.identityProviderId !== '')
            writer
                .tag(4, WireType.LengthDelimited)
                .string(message.identityProviderId)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.AllocateExternalPartyRequest
 */
export const AllocateExternalPartyRequest =
    new AllocateExternalPartyRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AllocateExternalPartyRequest_SignedTransaction$Type extends MessageType<AllocateExternalPartyRequest_SignedTransaction> {
    constructor() {
        super(
            'com.daml.ledger.api.v2.admin.AllocateExternalPartyRequest.SignedTransaction',
            [
                {
                    no: 1,
                    name: 'transaction',
                    kind: 'scalar',
                    T: 12 /*ScalarType.BYTES*/,
                },
                {
                    no: 2,
                    name: 'signatures',
                    kind: 'message',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: () => Signature,
                },
            ]
        )
    }
    create(
        value?: PartialMessage<AllocateExternalPartyRequest_SignedTransaction>
    ): AllocateExternalPartyRequest_SignedTransaction {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.transaction = new Uint8Array(0)
        message.signatures = []
        if (value !== undefined)
            reflectionMergePartial<AllocateExternalPartyRequest_SignedTransaction>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: AllocateExternalPartyRequest_SignedTransaction
    ): AllocateExternalPartyRequest_SignedTransaction {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* bytes transaction */ 1:
                    message.transaction = reader.bytes()
                    break
                case /* repeated com.daml.ledger.api.v2.interactive.Signature signatures */ 2:
                    message.signatures.push(
                        Signature.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: AllocateExternalPartyRequest_SignedTransaction,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* bytes transaction = 1; */
        if (message.transaction.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.transaction)
        /* repeated com.daml.ledger.api.v2.interactive.Signature signatures = 2; */
        for (let i = 0; i < message.signatures.length; i++)
            Signature.internalBinaryWrite(
                message.signatures[i],
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.AllocateExternalPartyRequest.SignedTransaction
 */
export const AllocateExternalPartyRequest_SignedTransaction =
    new AllocateExternalPartyRequest_SignedTransaction$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AllocateExternalPartyResponse$Type extends MessageType<AllocateExternalPartyResponse> {
    constructor() {
        super('com.daml.ledger.api.v2.admin.AllocateExternalPartyResponse', [
            {
                no: 1,
                name: 'party_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
        ])
    }
    create(
        value?: PartialMessage<AllocateExternalPartyResponse>
    ): AllocateExternalPartyResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.partyId = ''
        if (value !== undefined)
            reflectionMergePartial<AllocateExternalPartyResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: AllocateExternalPartyResponse
    ): AllocateExternalPartyResponse {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string party_id */ 1:
                    message.partyId = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: AllocateExternalPartyResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string party_id = 1; */
        if (message.partyId !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.partyId)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.AllocateExternalPartyResponse
 */
export const AllocateExternalPartyResponse =
    new AllocateExternalPartyResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePartyDetailsRequest$Type extends MessageType<UpdatePartyDetailsRequest> {
    constructor() {
        super('com.daml.ledger.api.v2.admin.UpdatePartyDetailsRequest', [
            {
                no: 1,
                name: 'party_details',
                kind: 'message',
                T: () => PartyDetails,
            },
            { no: 2, name: 'update_mask', kind: 'message', T: () => FieldMask },
        ])
    }
    create(
        value?: PartialMessage<UpdatePartyDetailsRequest>
    ): UpdatePartyDetailsRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<UpdatePartyDetailsRequest>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: UpdatePartyDetailsRequest
    ): UpdatePartyDetailsRequest {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.admin.PartyDetails party_details */ 1:
                    message.partyDetails = PartyDetails.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.partyDetails
                    )
                    break
                case /* google.protobuf.FieldMask update_mask */ 2:
                    message.updateMask = FieldMask.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.updateMask
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: UpdatePartyDetailsRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.admin.PartyDetails party_details = 1; */
        if (message.partyDetails)
            PartyDetails.internalBinaryWrite(
                message.partyDetails,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* google.protobuf.FieldMask update_mask = 2; */
        if (message.updateMask)
            FieldMask.internalBinaryWrite(
                message.updateMask,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.UpdatePartyDetailsRequest
 */
export const UpdatePartyDetailsRequest = new UpdatePartyDetailsRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePartyDetailsResponse$Type extends MessageType<UpdatePartyDetailsResponse> {
    constructor() {
        super('com.daml.ledger.api.v2.admin.UpdatePartyDetailsResponse', [
            {
                no: 1,
                name: 'party_details',
                kind: 'message',
                T: () => PartyDetails,
            },
        ])
    }
    create(
        value?: PartialMessage<UpdatePartyDetailsResponse>
    ): UpdatePartyDetailsResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<UpdatePartyDetailsResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: UpdatePartyDetailsResponse
    ): UpdatePartyDetailsResponse {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.admin.PartyDetails party_details */ 1:
                    message.partyDetails = PartyDetails.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.partyDetails
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: UpdatePartyDetailsResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.admin.PartyDetails party_details = 1; */
        if (message.partyDetails)
            PartyDetails.internalBinaryWrite(
                message.partyDetails,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.UpdatePartyDetailsResponse
 */
export const UpdatePartyDetailsResponse = new UpdatePartyDetailsResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PartyDetails$Type extends MessageType<PartyDetails> {
    constructor() {
        super('com.daml.ledger.api.v2.admin.PartyDetails', [
            {
                no: 1,
                name: 'party',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 3,
                name: 'is_local',
                kind: 'scalar',
                T: 8 /*ScalarType.BOOL*/,
            },
            {
                no: 4,
                name: 'local_metadata',
                kind: 'message',
                T: () => ObjectMeta,
            },
            {
                no: 5,
                name: 'identity_provider_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
        ])
    }
    create(value?: PartialMessage<PartyDetails>): PartyDetails {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.party = ''
        message.isLocal = false
        message.identityProviderId = ''
        if (value !== undefined)
            reflectionMergePartial<PartyDetails>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: PartyDetails
    ): PartyDetails {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string party */ 1:
                    message.party = reader.string()
                    break
                case /* bool is_local */ 3:
                    message.isLocal = reader.bool()
                    break
                case /* com.daml.ledger.api.v2.admin.ObjectMeta local_metadata */ 4:
                    message.localMetadata = ObjectMeta.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.localMetadata
                    )
                    break
                case /* string identity_provider_id */ 5:
                    message.identityProviderId = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: PartyDetails,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string party = 1; */
        if (message.party !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.party)
        /* bool is_local = 3; */
        if (message.isLocal !== false)
            writer.tag(3, WireType.Varint).bool(message.isLocal)
        /* com.daml.ledger.api.v2.admin.ObjectMeta local_metadata = 4; */
        if (message.localMetadata)
            ObjectMeta.internalBinaryWrite(
                message.localMetadata,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* string identity_provider_id = 5; */
        if (message.identityProviderId !== '')
            writer
                .tag(5, WireType.LengthDelimited)
                .string(message.identityProviderId)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.PartyDetails
 */
export const PartyDetails = new PartyDetails$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePartyIdentityProviderIdRequest$Type extends MessageType<UpdatePartyIdentityProviderIdRequest> {
    constructor() {
        super(
            'com.daml.ledger.api.v2.admin.UpdatePartyIdentityProviderIdRequest',
            [
                {
                    no: 1,
                    name: 'party',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'source_identity_provider_id',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 3,
                    name: 'target_identity_provider_id',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
            ]
        )
    }
    create(
        value?: PartialMessage<UpdatePartyIdentityProviderIdRequest>
    ): UpdatePartyIdentityProviderIdRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.party = ''
        message.sourceIdentityProviderId = ''
        message.targetIdentityProviderId = ''
        if (value !== undefined)
            reflectionMergePartial<UpdatePartyIdentityProviderIdRequest>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: UpdatePartyIdentityProviderIdRequest
    ): UpdatePartyIdentityProviderIdRequest {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string party */ 1:
                    message.party = reader.string()
                    break
                case /* string source_identity_provider_id */ 2:
                    message.sourceIdentityProviderId = reader.string()
                    break
                case /* string target_identity_provider_id */ 3:
                    message.targetIdentityProviderId = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: UpdatePartyIdentityProviderIdRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string party = 1; */
        if (message.party !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.party)
        /* string source_identity_provider_id = 2; */
        if (message.sourceIdentityProviderId !== '')
            writer
                .tag(2, WireType.LengthDelimited)
                .string(message.sourceIdentityProviderId)
        /* string target_identity_provider_id = 3; */
        if (message.targetIdentityProviderId !== '')
            writer
                .tag(3, WireType.LengthDelimited)
                .string(message.targetIdentityProviderId)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.UpdatePartyIdentityProviderIdRequest
 */
export const UpdatePartyIdentityProviderIdRequest =
    new UpdatePartyIdentityProviderIdRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePartyIdentityProviderIdResponse$Type extends MessageType<UpdatePartyIdentityProviderIdResponse> {
    constructor() {
        super(
            'com.daml.ledger.api.v2.admin.UpdatePartyIdentityProviderIdResponse',
            []
        )
    }
    create(
        value?: PartialMessage<UpdatePartyIdentityProviderIdResponse>
    ): UpdatePartyIdentityProviderIdResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<UpdatePartyIdentityProviderIdResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: UpdatePartyIdentityProviderIdResponse
    ): UpdatePartyIdentityProviderIdResponse {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: UpdatePartyIdentityProviderIdResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.UpdatePartyIdentityProviderIdResponse
 */
export const UpdatePartyIdentityProviderIdResponse =
    new UpdatePartyIdentityProviderIdResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GenerateExternalPartyTopologyRequest$Type extends MessageType<GenerateExternalPartyTopologyRequest> {
    constructor() {
        super(
            'com.daml.ledger.api.v2.admin.GenerateExternalPartyTopologyRequest',
            [
                {
                    no: 1,
                    name: 'synchronizer',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'party_hint',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 3,
                    name: 'public_key',
                    kind: 'message',
                    T: () => SigningPublicKey,
                },
                {
                    no: 4,
                    name: 'local_participant_observation_only',
                    kind: 'scalar',
                    T: 8 /*ScalarType.BOOL*/,
                },
                {
                    no: 5,
                    name: 'other_confirming_participant_uids',
                    kind: 'scalar',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 6,
                    name: 'confirmation_threshold',
                    kind: 'scalar',
                    T: 13 /*ScalarType.UINT32*/,
                },
                {
                    no: 7,
                    name: 'observing_participant_uids',
                    kind: 'scalar',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: 9 /*ScalarType.STRING*/,
                },
            ]
        )
    }
    create(
        value?: PartialMessage<GenerateExternalPartyTopologyRequest>
    ): GenerateExternalPartyTopologyRequest {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.synchronizer = ''
        message.partyHint = ''
        message.localParticipantObservationOnly = false
        message.otherConfirmingParticipantUids = []
        message.confirmationThreshold = 0
        message.observingParticipantUids = []
        if (value !== undefined)
            reflectionMergePartial<GenerateExternalPartyTopologyRequest>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GenerateExternalPartyTopologyRequest
    ): GenerateExternalPartyTopologyRequest {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string synchronizer */ 1:
                    message.synchronizer = reader.string()
                    break
                case /* string party_hint */ 2:
                    message.partyHint = reader.string()
                    break
                case /* com.daml.ledger.api.v2.SigningPublicKey public_key */ 3:
                    message.publicKey = SigningPublicKey.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.publicKey
                    )
                    break
                case /* bool local_participant_observation_only */ 4:
                    message.localParticipantObservationOnly = reader.bool()
                    break
                case /* repeated string other_confirming_participant_uids */ 5:
                    message.otherConfirmingParticipantUids.push(reader.string())
                    break
                case /* uint32 confirmation_threshold */ 6:
                    message.confirmationThreshold = reader.uint32()
                    break
                case /* repeated string observing_participant_uids */ 7:
                    message.observingParticipantUids.push(reader.string())
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GenerateExternalPartyTopologyRequest,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string synchronizer = 1; */
        if (message.synchronizer !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.synchronizer)
        /* string party_hint = 2; */
        if (message.partyHint !== '')
            writer.tag(2, WireType.LengthDelimited).string(message.partyHint)
        /* com.daml.ledger.api.v2.SigningPublicKey public_key = 3; */
        if (message.publicKey)
            SigningPublicKey.internalBinaryWrite(
                message.publicKey,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* bool local_participant_observation_only = 4; */
        if (message.localParticipantObservationOnly !== false)
            writer
                .tag(4, WireType.Varint)
                .bool(message.localParticipantObservationOnly)
        /* repeated string other_confirming_participant_uids = 5; */
        for (let i = 0; i < message.otherConfirmingParticipantUids.length; i++)
            writer
                .tag(5, WireType.LengthDelimited)
                .string(message.otherConfirmingParticipantUids[i])
        /* uint32 confirmation_threshold = 6; */
        if (message.confirmationThreshold !== 0)
            writer.tag(6, WireType.Varint).uint32(message.confirmationThreshold)
        /* repeated string observing_participant_uids = 7; */
        for (let i = 0; i < message.observingParticipantUids.length; i++)
            writer
                .tag(7, WireType.LengthDelimited)
                .string(message.observingParticipantUids[i])
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.GenerateExternalPartyTopologyRequest
 */
export const GenerateExternalPartyTopologyRequest =
    new GenerateExternalPartyTopologyRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class GenerateExternalPartyTopologyResponse$Type extends MessageType<GenerateExternalPartyTopologyResponse> {
    constructor() {
        super(
            'com.daml.ledger.api.v2.admin.GenerateExternalPartyTopologyResponse',
            [
                {
                    no: 1,
                    name: 'party_id',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 2,
                    name: 'public_key_fingerprint',
                    kind: 'scalar',
                    T: 9 /*ScalarType.STRING*/,
                },
                {
                    no: 3,
                    name: 'topology_transactions',
                    kind: 'scalar',
                    repeat: 2 /*RepeatType.UNPACKED*/,
                    T: 12 /*ScalarType.BYTES*/,
                },
                {
                    no: 4,
                    name: 'multi_hash',
                    kind: 'scalar',
                    T: 12 /*ScalarType.BYTES*/,
                },
            ]
        )
    }
    create(
        value?: PartialMessage<GenerateExternalPartyTopologyResponse>
    ): GenerateExternalPartyTopologyResponse {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.partyId = ''
        message.publicKeyFingerprint = ''
        message.topologyTransactions = []
        message.multiHash = new Uint8Array(0)
        if (value !== undefined)
            reflectionMergePartial<GenerateExternalPartyTopologyResponse>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: GenerateExternalPartyTopologyResponse
    ): GenerateExternalPartyTopologyResponse {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string party_id */ 1:
                    message.partyId = reader.string()
                    break
                case /* string public_key_fingerprint */ 2:
                    message.publicKeyFingerprint = reader.string()
                    break
                case /* repeated bytes topology_transactions */ 3:
                    message.topologyTransactions.push(reader.bytes())
                    break
                case /* bytes multi_hash */ 4:
                    message.multiHash = reader.bytes()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: GenerateExternalPartyTopologyResponse,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string party_id = 1; */
        if (message.partyId !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.partyId)
        /* string public_key_fingerprint = 2; */
        if (message.publicKeyFingerprint !== '')
            writer
                .tag(2, WireType.LengthDelimited)
                .string(message.publicKeyFingerprint)
        /* repeated bytes topology_transactions = 3; */
        for (let i = 0; i < message.topologyTransactions.length; i++)
            writer
                .tag(3, WireType.LengthDelimited)
                .bytes(message.topologyTransactions[i])
        /* bytes multi_hash = 4; */
        if (message.multiHash.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.multiHash)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.admin.GenerateExternalPartyTopologyResponse
 */
export const GenerateExternalPartyTopologyResponse =
    new GenerateExternalPartyTopologyResponse$Type()
/**
 * @generated ServiceType for protobuf service com.daml.ledger.api.v2.admin.PartyManagementService
 */
export const PartyManagementService = new ServiceType(
    'com.daml.ledger.api.v2.admin.PartyManagementService',
    [
        {
            name: 'GetParticipantId',
            options: {},
            I: GetParticipantIdRequest,
            O: GetParticipantIdResponse,
        },
        {
            name: 'GetParties',
            options: {},
            I: GetPartiesRequest,
            O: GetPartiesResponse,
        },
        {
            name: 'ListKnownParties',
            options: {},
            I: ListKnownPartiesRequest,
            O: ListKnownPartiesResponse,
        },
        {
            name: 'AllocateParty',
            options: {},
            I: AllocatePartyRequest,
            O: AllocatePartyResponse,
        },
        {
            name: 'AllocateExternalParty',
            options: {},
            I: AllocateExternalPartyRequest,
            O: AllocateExternalPartyResponse,
        },
        {
            name: 'UpdatePartyDetails',
            options: {},
            I: UpdatePartyDetailsRequest,
            O: UpdatePartyDetailsResponse,
        },
        {
            name: 'UpdatePartyIdentityProviderId',
            options: {},
            I: UpdatePartyIdentityProviderIdRequest,
            O: UpdatePartyIdentityProviderIdResponse,
        },
        {
            name: 'GenerateExternalPartyTopology',
            options: {},
            I: GenerateExternalPartyTopologyRequest,
            O: GenerateExternalPartyTopologyResponse,
        },
    ]
)
