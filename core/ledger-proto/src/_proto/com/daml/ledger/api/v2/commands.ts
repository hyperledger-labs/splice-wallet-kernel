// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/commands.proto" (package "com.daml.ledger.api.v2", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { Timestamp } from '../../../../../google/protobuf/timestamp.js'
import { Duration } from '../../../../../google/protobuf/duration.js'
import { Value } from './value.js'
import { Record } from './value.js'
import { Identifier } from './value.js'
/**
 * A command can either create a new contract or exercise a choice on an existing contract.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.Command
 */
export interface Command {
    /**
     * @generated from protobuf oneof: command
     */
    command:
        | {
              oneofKind: 'create'
              /**
               * @generated from protobuf field: com.daml.ledger.api.v2.CreateCommand create = 1
               */
              create: CreateCommand
          }
        | {
              oneofKind: 'exercise'
              /**
               * @generated from protobuf field: com.daml.ledger.api.v2.ExerciseCommand exercise = 2
               */
              exercise: ExerciseCommand
          }
        | {
              oneofKind: 'exerciseByKey'
              /**
               * @generated from protobuf field: com.daml.ledger.api.v2.ExerciseByKeyCommand exercise_by_key = 4
               */
              exerciseByKey: ExerciseByKeyCommand
          }
        | {
              oneofKind: 'createAndExercise'
              /**
               * @generated from protobuf field: com.daml.ledger.api.v2.CreateAndExerciseCommand create_and_exercise = 3
               */
              createAndExercise: CreateAndExerciseCommand
          }
        | {
              oneofKind: undefined
          }
}
/**
 * Create a new contract instance based on a template.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.CreateCommand
 */
export interface CreateCommand {
    /**
     * The template of contract the client wants to create.
     * Both package-name and package-id reference identifier formats for the template-id are supported.
     * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
     *
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier template_id = 1
     */
    templateId?: Identifier
    /**
     * The arguments required for creating a contract from this template.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Record create_arguments = 2
     */
    createArguments?: Record
}
/**
 * Exercise a choice on an existing contract.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.ExerciseCommand
 */
export interface ExerciseCommand {
    /**
     * The template or interface of the contract the client wants to exercise.
     * Both package-name and package-id reference identifier formats for the template-id are supported.
     * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
     * To exercise a choice on an interface, specify the interface identifier in the template_id field.
     *
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier template_id = 1
     */
    templateId?: Identifier
    /**
     * The ID of the contract the client wants to exercise upon.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string contract_id = 2
     */
    contractId: string
    /**
     * The name of the choice the client wants to exercise.
     * Must be a valid NameString (as described in ``value.proto``)
     * Required
     *
     * @generated from protobuf field: string choice = 3
     */
    choice: string
    /**
     * The argument for this choice.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Value choice_argument = 4
     */
    choiceArgument?: Value
}
/**
 * Exercise a choice on an existing contract specified by its key.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.ExerciseByKeyCommand
 */
export interface ExerciseByKeyCommand {
    /**
     * The template of contract the client wants to exercise.
     * Both package-name and package-id reference identifier formats for the template-id are supported.
     * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
     *
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier template_id = 1
     */
    templateId?: Identifier
    /**
     * The key of the contract the client wants to exercise upon.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Value contract_key = 2
     */
    contractKey?: Value
    /**
     * The name of the choice the client wants to exercise.
     * Must be a valid NameString (as described in ``value.proto``)
     * Required
     *
     * @generated from protobuf field: string choice = 3
     */
    choice: string
    /**
     * The argument for this choice.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Value choice_argument = 4
     */
    choiceArgument?: Value
}
/**
 * Create a contract and exercise a choice on it in the same transaction.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.CreateAndExerciseCommand
 */
export interface CreateAndExerciseCommand {
    /**
     * The template of the contract the client wants to create.
     * Both package-name and package-id reference identifier formats for the template-id are supported.
     * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
     *
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier template_id = 1
     */
    templateId?: Identifier
    /**
     * The arguments required for creating a contract from this template.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Record create_arguments = 2
     */
    createArguments?: Record
    /**
     * The name of the choice the client wants to exercise.
     * Must be a valid NameString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string choice = 3
     */
    choice: string
    /**
     * The argument for this choice.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Value choice_argument = 4
     */
    choiceArgument?: Value
}
/**
 * An additional contract that is used to resolve
 * contract & contract key lookups.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.DisclosedContract
 */
export interface DisclosedContract {
    /**
     * The template id of the contract.
     * The identifier uses the package-id reference format.
     *
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier template_id = 1
     */
    templateId?: Identifier
    /**
     * The contract id
     * Required
     *
     * @generated from protobuf field: string contract_id = 2
     */
    contractId: string
    /**
     * Opaque byte string containing the complete payload required by the Daml engine
     * to reconstruct a contract not known to the receiving participant.
     * Required
     *
     * @generated from protobuf field: bytes created_event_blob = 3
     */
    createdEventBlob: Uint8Array
    /**
     * The ID of the synchronizer where the contract is currently assigned
     * Optional
     *
     * @generated from protobuf field: string synchronizer_id = 4
     */
    synchronizerId: string
}
/**
 * A composite command that groups multiple commands together.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.Commands
 */
export interface Commands {
    /**
     * Identifier of the on-ledger workflow that this command is a part of.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Optional
     *
     * @generated from protobuf field: string workflow_id = 1
     */
    workflowId: string
    /**
     * Uniquely identifies the participant user that issued the command.
     * Must be a valid UserIdString (as described in ``value.proto``).
     * Required unless authentication is used with a user token.
     * In that case, the token's user-id will be used for the request's user_id.
     *
     * @generated from protobuf field: string user_id = 2
     */
    userId: string
    /**
     * Uniquely identifies the command.
     * The triple (user_id, act_as, command_id) constitutes the change ID for the intended ledger change,
     * where act_as is interpreted as a set of party names.
     * The change ID can be used for matching the intended ledger changes with all their completions.
     * Must be a valid LedgerString (as described in ``value.proto``).
     * Required
     *
     * @generated from protobuf field: string command_id = 3
     */
    commandId: string
    /**
     * Individual elements of this atomic command. Must be non-empty.
     * Required
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.Command commands = 4
     */
    commands: Command[]
    /**
     * Specifies the deduplication period for the change ID.
     * If omitted, the participant will assume the configured maximum deduplication time.
     *
     * @generated from protobuf oneof: deduplication_period
     */
    deduplicationPeriod:
        | {
              oneofKind: 'deduplicationDuration'
              /**
               * Specifies the length of the deduplication period.
               * It is interpreted relative to the local clock at some point during the submission's processing.
               * Must be non-negative. Must not exceed the maximum deduplication time.
               *
               * @generated from protobuf field: google.protobuf.Duration deduplication_duration = 5
               */
              deduplicationDuration: Duration
          }
        | {
              oneofKind: 'deduplicationOffset'
              /**
               * Specifies the start of the deduplication period by a completion stream offset (exclusive).
               * Must be a valid absolute offset (positive integer) or participant begin (zero).
               *
               * @generated from protobuf field: int64 deduplication_offset = 6
               */
              deduplicationOffset: bigint
          }
        | {
              oneofKind: undefined
          }
    /**
     * Lower bound for the ledger time assigned to the resulting transaction.
     * Note: The ledger time of a transaction is assigned as part of command interpretation.
     * Use this property if you expect that command interpretation will take a considerate amount of time, such that by
     * the time the resulting transaction is sequenced, its assigned ledger time is not valid anymore.
     * Must not be set at the same time as min_ledger_time_rel.
     * Optional
     *
     * @generated from protobuf field: google.protobuf.Timestamp min_ledger_time_abs = 7
     */
    minLedgerTimeAbs?: Timestamp
    /**
     * Same as min_ledger_time_abs, but specified as a duration, starting from the time the command is received by the server.
     * Must not be set at the same time as min_ledger_time_abs.
     * Optional
     *
     * @generated from protobuf field: google.protobuf.Duration min_ledger_time_rel = 8
     */
    minLedgerTimeRel?: Duration
    /**
     * Set of parties on whose behalf the command should be executed.
     * If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
     * to act on behalf of each of the given parties.
     * Each element must be a valid PartyIdString (as described in ``value.proto``).
     * Required, must be non-empty.
     *
     * @generated from protobuf field: repeated string act_as = 9
     */
    actAs: string[]
    /**
     * Set of parties on whose behalf (in addition to all parties listed in ``act_as``) contracts can be retrieved.
     * This affects Daml operations such as ``fetch``, ``fetchByKey``, ``lookupByKey``, ``exercise``, and ``exerciseByKey``.
     * Note: A participant node of a Daml network can host multiple parties. Each contract present on the participant
     * node is only visible to a subset of these parties. A command can only use contracts that are visible to at least
     * one of the parties in ``act_as`` or ``read_as``. This visibility check is independent from the Daml authorization
     * rules for fetch operations.
     * If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request
     * to read contract data on behalf of each of the given parties.
     * Optional
     *
     * @generated from protobuf field: repeated string read_as = 10
     */
    readAs: string[]
    /**
     * A unique identifier to distinguish completions for different submissions with the same change ID.
     * Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission
     * with the same change ID.
     * Must be a valid LedgerString (as described in ``value.proto``).
     *
     * If omitted, the participant or the committer may set a value of their choice.
     * Optional
     *
     * @generated from protobuf field: string submission_id = 11
     */
    submissionId: string
    /**
     * Additional contracts used to resolve contract & contract key lookups.
     * Optional
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.DisclosedContract disclosed_contracts = 12
     */
    disclosedContracts: DisclosedContract[]
    /**
     * Must be a valid synchronizer id
     * Optional
     *
     * @generated from protobuf field: string synchronizer_id = 13
     */
    synchronizerId: string
    /**
     * The package-id selection preference of the client for resolving
     * package names and interface instances in command submission and interpretation
     *
     * @generated from protobuf field: repeated string package_id_selection_preference = 14
     */
    packageIdSelectionPreference: string[]
    /**
     * Fetches the contract keys into the caches to speed up the command processing.
     * Should only contain contract keys that are expected to be resolved during interpretation of the commands.
     * Keys of disclosed contracts do not need prefetching.
     *
     * Optional
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.PrefetchContractKey prefetch_contract_keys = 15
     */
    prefetchContractKeys: PrefetchContractKey[]
}
/**
 * Preload contracts
 *
 * @generated from protobuf message com.daml.ledger.api.v2.PrefetchContractKey
 */
export interface PrefetchContractKey {
    /**
     * The template of contract the client wants to prefetch.
     * Both package-name and package-id reference identifier formats for the template-id are supported.
     * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
     *
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier template_id = 1
     */
    templateId?: Identifier
    /**
     * The key of the contract the client wants to prefetch.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Value contract_key = 2
     */
    contractKey?: Value
}
// @generated message type with reflection information, may provide speed optimized methods
class Command$Type extends MessageType<Command> {
    constructor() {
        super('com.daml.ledger.api.v2.Command', [
            {
                no: 1,
                name: 'create',
                kind: 'message',
                oneof: 'command',
                T: () => CreateCommand,
            },
            {
                no: 2,
                name: 'exercise',
                kind: 'message',
                oneof: 'command',
                T: () => ExerciseCommand,
            },
            {
                no: 4,
                name: 'exercise_by_key',
                kind: 'message',
                oneof: 'command',
                T: () => ExerciseByKeyCommand,
            },
            {
                no: 3,
                name: 'create_and_exercise',
                kind: 'message',
                oneof: 'command',
                T: () => CreateAndExerciseCommand,
            },
        ])
    }
    create(value?: PartialMessage<Command>): Command {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.command = { oneofKind: undefined }
        if (value !== undefined)
            reflectionMergePartial<Command>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Command
    ): Command {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.CreateCommand create */ 1:
                    message.command = {
                        oneofKind: 'create',
                        create: CreateCommand.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.command as any).create
                        ),
                    }
                    break
                case /* com.daml.ledger.api.v2.ExerciseCommand exercise */ 2:
                    message.command = {
                        oneofKind: 'exercise',
                        exercise: ExerciseCommand.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.command as any).exercise
                        ),
                    }
                    break
                case /* com.daml.ledger.api.v2.ExerciseByKeyCommand exercise_by_key */ 4:
                    message.command = {
                        oneofKind: 'exerciseByKey',
                        exerciseByKey: ExerciseByKeyCommand.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.command as any).exerciseByKey
                        ),
                    }
                    break
                case /* com.daml.ledger.api.v2.CreateAndExerciseCommand create_and_exercise */ 3:
                    message.command = {
                        oneofKind: 'createAndExercise',
                        createAndExercise:
                            CreateAndExerciseCommand.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                (message.command as any).createAndExercise
                            ),
                    }
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: Command,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.CreateCommand create = 1; */
        if (message.command.oneofKind === 'create')
            CreateCommand.internalBinaryWrite(
                message.command.create,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.ExerciseCommand exercise = 2; */
        if (message.command.oneofKind === 'exercise')
            ExerciseCommand.internalBinaryWrite(
                message.command.exercise,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.CreateAndExerciseCommand create_and_exercise = 3; */
        if (message.command.oneofKind === 'createAndExercise')
            CreateAndExerciseCommand.internalBinaryWrite(
                message.command.createAndExercise,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.ExerciseByKeyCommand exercise_by_key = 4; */
        if (message.command.oneofKind === 'exerciseByKey')
            ExerciseByKeyCommand.internalBinaryWrite(
                message.command.exerciseByKey,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.Command
 */
export const Command = new Command$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CreateCommand$Type extends MessageType<CreateCommand> {
    constructor() {
        super('com.daml.ledger.api.v2.CreateCommand', [
            {
                no: 1,
                name: 'template_id',
                kind: 'message',
                T: () => Identifier,
            },
            {
                no: 2,
                name: 'create_arguments',
                kind: 'message',
                T: () => Record,
            },
        ])
    }
    create(value?: PartialMessage<CreateCommand>): CreateCommand {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<CreateCommand>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CreateCommand
    ): CreateCommand {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Identifier template_id */ 1:
                    message.templateId = Identifier.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.templateId
                    )
                    break
                case /* com.daml.ledger.api.v2.Record create_arguments */ 2:
                    message.createArguments = Record.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.createArguments
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: CreateCommand,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.Identifier template_id = 1; */
        if (message.templateId)
            Identifier.internalBinaryWrite(
                message.templateId,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.Record create_arguments = 2; */
        if (message.createArguments)
            Record.internalBinaryWrite(
                message.createArguments,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.CreateCommand
 */
export const CreateCommand = new CreateCommand$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ExerciseCommand$Type extends MessageType<ExerciseCommand> {
    constructor() {
        super('com.daml.ledger.api.v2.ExerciseCommand', [
            {
                no: 1,
                name: 'template_id',
                kind: 'message',
                T: () => Identifier,
            },
            {
                no: 2,
                name: 'contract_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 3,
                name: 'choice',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            { no: 4, name: 'choice_argument', kind: 'message', T: () => Value },
        ])
    }
    create(value?: PartialMessage<ExerciseCommand>): ExerciseCommand {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.contractId = ''
        message.choice = ''
        if (value !== undefined)
            reflectionMergePartial<ExerciseCommand>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ExerciseCommand
    ): ExerciseCommand {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Identifier template_id */ 1:
                    message.templateId = Identifier.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.templateId
                    )
                    break
                case /* string contract_id */ 2:
                    message.contractId = reader.string()
                    break
                case /* string choice */ 3:
                    message.choice = reader.string()
                    break
                case /* com.daml.ledger.api.v2.Value choice_argument */ 4:
                    message.choiceArgument = Value.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.choiceArgument
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: ExerciseCommand,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.Identifier template_id = 1; */
        if (message.templateId)
            Identifier.internalBinaryWrite(
                message.templateId,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* string contract_id = 2; */
        if (message.contractId !== '')
            writer.tag(2, WireType.LengthDelimited).string(message.contractId)
        /* string choice = 3; */
        if (message.choice !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.choice)
        /* com.daml.ledger.api.v2.Value choice_argument = 4; */
        if (message.choiceArgument)
            Value.internalBinaryWrite(
                message.choiceArgument,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.ExerciseCommand
 */
export const ExerciseCommand = new ExerciseCommand$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ExerciseByKeyCommand$Type extends MessageType<ExerciseByKeyCommand> {
    constructor() {
        super('com.daml.ledger.api.v2.ExerciseByKeyCommand', [
            {
                no: 1,
                name: 'template_id',
                kind: 'message',
                T: () => Identifier,
            },
            { no: 2, name: 'contract_key', kind: 'message', T: () => Value },
            {
                no: 3,
                name: 'choice',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            { no: 4, name: 'choice_argument', kind: 'message', T: () => Value },
        ])
    }
    create(value?: PartialMessage<ExerciseByKeyCommand>): ExerciseByKeyCommand {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.choice = ''
        if (value !== undefined)
            reflectionMergePartial<ExerciseByKeyCommand>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ExerciseByKeyCommand
    ): ExerciseByKeyCommand {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Identifier template_id */ 1:
                    message.templateId = Identifier.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.templateId
                    )
                    break
                case /* com.daml.ledger.api.v2.Value contract_key */ 2:
                    message.contractKey = Value.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.contractKey
                    )
                    break
                case /* string choice */ 3:
                    message.choice = reader.string()
                    break
                case /* com.daml.ledger.api.v2.Value choice_argument */ 4:
                    message.choiceArgument = Value.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.choiceArgument
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: ExerciseByKeyCommand,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.Identifier template_id = 1; */
        if (message.templateId)
            Identifier.internalBinaryWrite(
                message.templateId,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.Value contract_key = 2; */
        if (message.contractKey)
            Value.internalBinaryWrite(
                message.contractKey,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* string choice = 3; */
        if (message.choice !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.choice)
        /* com.daml.ledger.api.v2.Value choice_argument = 4; */
        if (message.choiceArgument)
            Value.internalBinaryWrite(
                message.choiceArgument,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.ExerciseByKeyCommand
 */
export const ExerciseByKeyCommand = new ExerciseByKeyCommand$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CreateAndExerciseCommand$Type extends MessageType<CreateAndExerciseCommand> {
    constructor() {
        super('com.daml.ledger.api.v2.CreateAndExerciseCommand', [
            {
                no: 1,
                name: 'template_id',
                kind: 'message',
                T: () => Identifier,
            },
            {
                no: 2,
                name: 'create_arguments',
                kind: 'message',
                T: () => Record,
            },
            {
                no: 3,
                name: 'choice',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            { no: 4, name: 'choice_argument', kind: 'message', T: () => Value },
        ])
    }
    create(
        value?: PartialMessage<CreateAndExerciseCommand>
    ): CreateAndExerciseCommand {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.choice = ''
        if (value !== undefined)
            reflectionMergePartial<CreateAndExerciseCommand>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CreateAndExerciseCommand
    ): CreateAndExerciseCommand {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Identifier template_id */ 1:
                    message.templateId = Identifier.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.templateId
                    )
                    break
                case /* com.daml.ledger.api.v2.Record create_arguments */ 2:
                    message.createArguments = Record.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.createArguments
                    )
                    break
                case /* string choice */ 3:
                    message.choice = reader.string()
                    break
                case /* com.daml.ledger.api.v2.Value choice_argument */ 4:
                    message.choiceArgument = Value.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.choiceArgument
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: CreateAndExerciseCommand,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.Identifier template_id = 1; */
        if (message.templateId)
            Identifier.internalBinaryWrite(
                message.templateId,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.Record create_arguments = 2; */
        if (message.createArguments)
            Record.internalBinaryWrite(
                message.createArguments,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* string choice = 3; */
        if (message.choice !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.choice)
        /* com.daml.ledger.api.v2.Value choice_argument = 4; */
        if (message.choiceArgument)
            Value.internalBinaryWrite(
                message.choiceArgument,
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.CreateAndExerciseCommand
 */
export const CreateAndExerciseCommand = new CreateAndExerciseCommand$Type()
// @generated message type with reflection information, may provide speed optimized methods
class DisclosedContract$Type extends MessageType<DisclosedContract> {
    constructor() {
        super('com.daml.ledger.api.v2.DisclosedContract', [
            {
                no: 1,
                name: 'template_id',
                kind: 'message',
                T: () => Identifier,
            },
            {
                no: 2,
                name: 'contract_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 3,
                name: 'created_event_blob',
                kind: 'scalar',
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 4,
                name: 'synchronizer_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
        ])
    }
    create(value?: PartialMessage<DisclosedContract>): DisclosedContract {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.contractId = ''
        message.createdEventBlob = new Uint8Array(0)
        message.synchronizerId = ''
        if (value !== undefined)
            reflectionMergePartial<DisclosedContract>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: DisclosedContract
    ): DisclosedContract {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Identifier template_id */ 1:
                    message.templateId = Identifier.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.templateId
                    )
                    break
                case /* string contract_id */ 2:
                    message.contractId = reader.string()
                    break
                case /* bytes created_event_blob */ 3:
                    message.createdEventBlob = reader.bytes()
                    break
                case /* string synchronizer_id */ 4:
                    message.synchronizerId = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: DisclosedContract,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.Identifier template_id = 1; */
        if (message.templateId)
            Identifier.internalBinaryWrite(
                message.templateId,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* string contract_id = 2; */
        if (message.contractId !== '')
            writer.tag(2, WireType.LengthDelimited).string(message.contractId)
        /* bytes created_event_blob = 3; */
        if (message.createdEventBlob.length)
            writer
                .tag(3, WireType.LengthDelimited)
                .bytes(message.createdEventBlob)
        /* string synchronizer_id = 4; */
        if (message.synchronizerId !== '')
            writer
                .tag(4, WireType.LengthDelimited)
                .string(message.synchronizerId)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.DisclosedContract
 */
export const DisclosedContract = new DisclosedContract$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Commands$Type extends MessageType<Commands> {
    constructor() {
        super('com.daml.ledger.api.v2.Commands', [
            {
                no: 1,
                name: 'workflow_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 2,
                name: 'user_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 3,
                name: 'command_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 4,
                name: 'commands',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => Command,
            },
            {
                no: 5,
                name: 'deduplication_duration',
                kind: 'message',
                oneof: 'deduplicationPeriod',
                T: () => Duration,
            },
            {
                no: 6,
                name: 'deduplication_offset',
                kind: 'scalar',
                oneof: 'deduplicationPeriod',
                T: 3 /*ScalarType.INT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            {
                no: 7,
                name: 'min_ledger_time_abs',
                kind: 'message',
                T: () => Timestamp,
            },
            {
                no: 8,
                name: 'min_ledger_time_rel',
                kind: 'message',
                T: () => Duration,
            },
            {
                no: 9,
                name: 'act_as',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 10,
                name: 'read_as',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 11,
                name: 'submission_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 12,
                name: 'disclosed_contracts',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => DisclosedContract,
            },
            {
                no: 13,
                name: 'synchronizer_id',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 14,
                name: 'package_id_selection_preference',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 15,
                name: 'prefetch_contract_keys',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => PrefetchContractKey,
            },
        ])
    }
    create(value?: PartialMessage<Commands>): Commands {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.workflowId = ''
        message.userId = ''
        message.commandId = ''
        message.commands = []
        message.deduplicationPeriod = { oneofKind: undefined }
        message.actAs = []
        message.readAs = []
        message.submissionId = ''
        message.disclosedContracts = []
        message.synchronizerId = ''
        message.packageIdSelectionPreference = []
        message.prefetchContractKeys = []
        if (value !== undefined)
            reflectionMergePartial<Commands>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Commands
    ): Commands {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string workflow_id */ 1:
                    message.workflowId = reader.string()
                    break
                case /* string user_id */ 2:
                    message.userId = reader.string()
                    break
                case /* string command_id */ 3:
                    message.commandId = reader.string()
                    break
                case /* repeated com.daml.ledger.api.v2.Command commands */ 4:
                    message.commands.push(
                        Command.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                case /* google.protobuf.Duration deduplication_duration */ 5:
                    message.deduplicationPeriod = {
                        oneofKind: 'deduplicationDuration',
                        deduplicationDuration: Duration.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.deduplicationPeriod as any)
                                .deduplicationDuration
                        ),
                    }
                    break
                case /* int64 deduplication_offset */ 6:
                    message.deduplicationPeriod = {
                        oneofKind: 'deduplicationOffset',
                        deduplicationOffset: reader.int64().toBigInt(),
                    }
                    break
                case /* google.protobuf.Timestamp min_ledger_time_abs */ 7:
                    message.minLedgerTimeAbs = Timestamp.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.minLedgerTimeAbs
                    )
                    break
                case /* google.protobuf.Duration min_ledger_time_rel */ 8:
                    message.minLedgerTimeRel = Duration.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.minLedgerTimeRel
                    )
                    break
                case /* repeated string act_as */ 9:
                    message.actAs.push(reader.string())
                    break
                case /* repeated string read_as */ 10:
                    message.readAs.push(reader.string())
                    break
                case /* string submission_id */ 11:
                    message.submissionId = reader.string()
                    break
                case /* repeated com.daml.ledger.api.v2.DisclosedContract disclosed_contracts */ 12:
                    message.disclosedContracts.push(
                        DisclosedContract.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                case /* string synchronizer_id */ 13:
                    message.synchronizerId = reader.string()
                    break
                case /* repeated string package_id_selection_preference */ 14:
                    message.packageIdSelectionPreference.push(reader.string())
                    break
                case /* repeated com.daml.ledger.api.v2.PrefetchContractKey prefetch_contract_keys */ 15:
                    message.prefetchContractKeys.push(
                        PrefetchContractKey.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: Commands,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string workflow_id = 1; */
        if (message.workflowId !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.workflowId)
        /* string user_id = 2; */
        if (message.userId !== '')
            writer.tag(2, WireType.LengthDelimited).string(message.userId)
        /* string command_id = 3; */
        if (message.commandId !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.commandId)
        /* repeated com.daml.ledger.api.v2.Command commands = 4; */
        for (let i = 0; i < message.commands.length; i++)
            Command.internalBinaryWrite(
                message.commands[i],
                writer.tag(4, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* google.protobuf.Duration deduplication_duration = 5; */
        if (message.deduplicationPeriod.oneofKind === 'deduplicationDuration')
            Duration.internalBinaryWrite(
                message.deduplicationPeriod.deduplicationDuration,
                writer.tag(5, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* int64 deduplication_offset = 6; */
        if (message.deduplicationPeriod.oneofKind === 'deduplicationOffset')
            writer
                .tag(6, WireType.Varint)
                .int64(message.deduplicationPeriod.deduplicationOffset)
        /* google.protobuf.Timestamp min_ledger_time_abs = 7; */
        if (message.minLedgerTimeAbs)
            Timestamp.internalBinaryWrite(
                message.minLedgerTimeAbs,
                writer.tag(7, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* google.protobuf.Duration min_ledger_time_rel = 8; */
        if (message.minLedgerTimeRel)
            Duration.internalBinaryWrite(
                message.minLedgerTimeRel,
                writer.tag(8, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* repeated string act_as = 9; */
        for (let i = 0; i < message.actAs.length; i++)
            writer.tag(9, WireType.LengthDelimited).string(message.actAs[i])
        /* repeated string read_as = 10; */
        for (let i = 0; i < message.readAs.length; i++)
            writer.tag(10, WireType.LengthDelimited).string(message.readAs[i])
        /* string submission_id = 11; */
        if (message.submissionId !== '')
            writer
                .tag(11, WireType.LengthDelimited)
                .string(message.submissionId)
        /* repeated com.daml.ledger.api.v2.DisclosedContract disclosed_contracts = 12; */
        for (let i = 0; i < message.disclosedContracts.length; i++)
            DisclosedContract.internalBinaryWrite(
                message.disclosedContracts[i],
                writer.tag(12, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* string synchronizer_id = 13; */
        if (message.synchronizerId !== '')
            writer
                .tag(13, WireType.LengthDelimited)
                .string(message.synchronizerId)
        /* repeated string package_id_selection_preference = 14; */
        for (let i = 0; i < message.packageIdSelectionPreference.length; i++)
            writer
                .tag(14, WireType.LengthDelimited)
                .string(message.packageIdSelectionPreference[i])
        /* repeated com.daml.ledger.api.v2.PrefetchContractKey prefetch_contract_keys = 15; */
        for (let i = 0; i < message.prefetchContractKeys.length; i++)
            PrefetchContractKey.internalBinaryWrite(
                message.prefetchContractKeys[i],
                writer.tag(15, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.Commands
 */
export const Commands = new Commands$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PrefetchContractKey$Type extends MessageType<PrefetchContractKey> {
    constructor() {
        super('com.daml.ledger.api.v2.PrefetchContractKey', [
            {
                no: 1,
                name: 'template_id',
                kind: 'message',
                T: () => Identifier,
            },
            { no: 2, name: 'contract_key', kind: 'message', T: () => Value },
        ])
    }
    create(value?: PartialMessage<PrefetchContractKey>): PrefetchContractKey {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<PrefetchContractKey>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: PrefetchContractKey
    ): PrefetchContractKey {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Identifier template_id */ 1:
                    message.templateId = Identifier.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.templateId
                    )
                    break
                case /* com.daml.ledger.api.v2.Value contract_key */ 2:
                    message.contractKey = Value.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.contractKey
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: PrefetchContractKey,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.Identifier template_id = 1; */
        if (message.templateId)
            Identifier.internalBinaryWrite(
                message.templateId,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.Value contract_key = 2; */
        if (message.contractKey)
            Value.internalBinaryWrite(
                message.contractKey,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.PrefetchContractKey
 */
export const PrefetchContractKey = new PrefetchContractKey$Type()
