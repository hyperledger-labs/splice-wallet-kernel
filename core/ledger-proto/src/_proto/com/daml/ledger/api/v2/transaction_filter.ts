// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/transaction_filter.proto" (package "com.daml.ledger.api.v2", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
import { Identifier } from './value.js'
/**
 * The union of a set of template filters, interface filters, or a wildcard.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.Filters
 */
export interface Filters {
    /**
     * Every filter in the cumulative list expands the scope of the resulting stream. Each interface,
     * template or wildcard filter means additional events that will match the query.
     * The impact of include_interface_view and include_created_event_blob fields in the filters will
     * also be accumulated.
     * At least one cumulative filter MUST be specified.
     * A template or an interface SHOULD NOT appear twice in the accumulative field.
     * A wildcard filter SHOULD NOT be defined more than once in the accumulative field.
     * Optional
     *
     * @generated from protobuf field: repeated com.daml.ledger.api.v2.CumulativeFilter cumulative = 1
     */
    cumulative: CumulativeFilter[]
}
/**
 * A filter that matches all contracts that are either an instance of one of
 * the ``template_filters`` or that match one of the ``interface_filters``.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.CumulativeFilter
 */
export interface CumulativeFilter {
    /**
     * @generated from protobuf oneof: identifier_filter
     */
    identifierFilter:
        | {
              oneofKind: 'wildcardFilter'
              /**
               * A wildcard filter that matches all templates
               * Optional
               *
               * @generated from protobuf field: com.daml.ledger.api.v2.WildcardFilter wildcard_filter = 1
               */
              wildcardFilter: WildcardFilter
          }
        | {
              oneofKind: 'interfaceFilter'
              /**
               * Include an ``InterfaceView`` for every ``InterfaceFilter`` matching a contract.
               * The ``InterfaceFilter`` instances MUST each use a unique ``interface_id``.
               * Optional
               *
               * @generated from protobuf field: com.daml.ledger.api.v2.InterfaceFilter interface_filter = 2
               */
              interfaceFilter: InterfaceFilter
          }
        | {
              oneofKind: 'templateFilter'
              /**
               * A template for which the data will be included in the
               * ``create_arguments`` of a matching ``CreatedEvent``.
               * If a contract is simultaneously selected by a template filter and one or more interface filters,
               * the corresponding ``include_created_event_blob`` are consolidated using an OR operation.
               * Optional
               *
               * @generated from protobuf field: com.daml.ledger.api.v2.TemplateFilter template_filter = 3
               */
              templateFilter: TemplateFilter
          }
        | {
              oneofKind: undefined
          }
}
/**
 * This filter matches all templates.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.WildcardFilter
 */
export interface WildcardFilter {
    /**
     * Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
     * Use this to access the contract create event payload in your API client
     * for submitting it as a disclosed contract with future commands.
     * Optional
     *
     * @generated from protobuf field: bool include_created_event_blob = 1
     */
    includeCreatedEventBlob: boolean
}
/**
 * This filter matches contracts that implement a specific interface.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.InterfaceFilter
 */
export interface InterfaceFilter {
    /**
     * The interface that a matching contract must implement.
     * The ``interface_id`` needs to be valid: corresponding interface should be defined in
     * one of the available packages at the time of the query.
     * Both package-name and package-id reference formats for the identifier are supported.
     * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
     *
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier interface_id = 1
     */
    interfaceId?: Identifier
    /**
     * Whether to include the interface view on the contract in the returned ``CreatedEvent``.
     * Use this to access contract data in a uniform manner in your API client.
     * Optional
     *
     * @generated from protobuf field: bool include_interface_view = 2
     */
    includeInterfaceView: boolean
    /**
     * Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
     * Use this to access the contract create event payload in your API client
     * for submitting it as a disclosed contract with future commands.
     * Optional
     *
     * @generated from protobuf field: bool include_created_event_blob = 3
     */
    includeCreatedEventBlob: boolean
}
/**
 * This filter matches contracts of a specific template.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.TemplateFilter
 */
export interface TemplateFilter {
    /**
     * A template for which the payload should be included in the response.
     * The ``template_id`` needs to be valid: corresponding template should be defined in
     * one of the available packages at the time of the query.
     * Both package-name and package-id reference formats for the identifier are supported.
     * Note: The package-id reference identifier format is deprecated. We plan to end support for this format in version 3.4.
     *
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Identifier template_id = 1
     */
    templateId?: Identifier
    /**
     * Whether to include a ``created_event_blob`` in the returned ``CreatedEvent``.
     * Use this to access the contract event payload in your API client
     * for submitting it as a disclosed contract with future commands.
     * Optional
     *
     * @generated from protobuf field: bool include_created_event_blob = 2
     */
    includeCreatedEventBlob: boolean
}
/**
 * Provided for backwards compatibility, it will be removed in the Canton version 3.4.0.
 * Used both for filtering create and archive events as well as for filtering transaction trees.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.TransactionFilter
 */
export interface TransactionFilter {
    /**
     * Each key must be a valid PartyIdString (as described in ``value.proto``).
     * The interpretation of the filter depends on the transaction-shape being filtered:
     *
     * 1. For **transaction trees** (used in GetUpdateTreesResponse for backwards compatibility) all party keys used as
     *    wildcard filters, and all subtrees whose root has one of the listed parties as an informee are returned.
     *    If there are ``CumulativeFilter``s, those will control returned ``CreatedEvent`` fields where applicable, but will
     *    not be used for template/interface filtering.
     * 2. For **ledger-effects** create and exercise events are returned, for which the witnesses include at least one of
     *    the listed parties and match the per-party filter.
     * 3. For **transaction and active-contract-set streams** create and archive events are returned for all contracts whose
     *    stakeholders include at least one of the listed parties and match the per-party filter.
     *
     * Required
     *
     * @generated from protobuf field: map<string, com.daml.ledger.api.v2.Filters> filters_by_party = 1
     */
    filtersByParty: {
        [key: string]: Filters
    }
    /**
     * Wildcard filters that apply to all the parties existing on the participant. The interpretation of the filters is the same
     * with the per-party filter as described above.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Filters filters_for_any_party = 2
     */
    filtersForAnyParty?: Filters
}
/**
 * A format for events which defines both which events should be included
 * and what data should be computed and included for them.
 *
 * Note that some of the filtering behavior depends on the `TransactionShape`,
 * which is expected to be specified alongside usages of `EventFormat`.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.EventFormat
 */
export interface EventFormat {
    /**
     * Each key must be a valid PartyIdString (as described in ``value.proto``).
     * The interpretation of the filter depends on the transaction-shape being filtered:
     *
     * 1. For **ledger-effects** create and exercise events are returned, for which the witnesses include at least one of
     *    the listed parties and match the per-party filter.
     * 2. For **transaction and active-contract-set streams** create and archive events are returned for all contracts whose
     *    stakeholders include at least one of the listed parties and match the per-party filter.
     *
     * Optional
     *
     * @generated from protobuf field: map<string, com.daml.ledger.api.v2.Filters> filters_by_party = 1
     */
    filtersByParty: {
        [key: string]: Filters
    }
    /**
     * Wildcard filters that apply to all the parties existing on the participant. The interpretation of the filters is the same
     * with the per-party filter as described above.
     * Optional
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.Filters filters_for_any_party = 2
     */
    filtersForAnyParty?: Filters
    /**
     * If enabled, values served over the API will contain more information than strictly necessary to interpret the data.
     * In particular, setting the verbose flag to true triggers the ledger to include labels for record fields.
     * Optional
     *
     * @generated from protobuf field: bool verbose = 3
     */
    verbose: boolean
}
/**
 * A format that specifies what events to include in Daml transactions
 * and what data to compute and include for them.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.TransactionFormat
 */
export interface TransactionFormat {
    /**
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.EventFormat event_format = 1
     */
    eventFormat?: EventFormat
    /**
     * What transaction shape to use for interpreting the filters of the event format.
     * Required
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.TransactionShape transaction_shape = 2
     */
    transactionShape: TransactionShape
}
/**
 * A format specifying which topology transactions to include and how to render them.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.TopologyFormat
 */
export interface TopologyFormat {
    /**
     * Include participant authorization topology events in streams.
     * Optional, if unset no participant authorization topology events are emitted in the stream.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.ParticipantAuthorizationTopologyFormat include_participant_authorization_events = 1
     */
    includeParticipantAuthorizationEvents?: ParticipantAuthorizationTopologyFormat
}
/**
 * A format specifying which participant authorization topology transactions to include and how to render them.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.ParticipantAuthorizationTopologyFormat
 */
export interface ParticipantAuthorizationTopologyFormat {
    /**
     * List of parties for which the topology transactions should be sent.
     * Empty means: for all parties.
     *
     * @generated from protobuf field: repeated string parties = 1
     */
    parties: string[]
}
/**
 * A format specifying what updates to include and how to render them.
 *
 * @generated from protobuf message com.daml.ledger.api.v2.UpdateFormat
 */
export interface UpdateFormat {
    /**
     * Include Daml transactions in streams.
     * Optional, if unset, no transactions are emitted in the stream.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.TransactionFormat include_transactions = 1
     */
    includeTransactions?: TransactionFormat
    /**
     * Include (un)assignments in the stream.
     * The events in the result take the shape TRANSACTION_SHAPE_ACS_DELTA.
     * Optional, if unset, no (un)assignments are emitted in the stream.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.EventFormat include_reassignments = 2
     */
    includeReassignments?: EventFormat
    /**
     * Include topology events in streams.
     * Optional, if unset no topology events are emitted in the stream.
     *
     * @generated from protobuf field: com.daml.ledger.api.v2.TopologyFormat include_topology_events = 3
     */
    includeTopologyEvents?: TopologyFormat
}
/**
 * Event shape for Transactions.
 * Shapes are exclusive and only one of them can be defined in queries.
 *
 * @generated from protobuf enum com.daml.ledger.api.v2.TransactionShape
 */
export enum TransactionShape {
    /**
     * Following official proto3 convention, not intended for actual use.
     *
     * @generated from protobuf enum value: TRANSACTION_SHAPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Transaction shape that is sufficient to maintain an accurate ACS view.
     * The field witness_parties in events are populated as stakeholders, transaction filter will apply accordingly.
     * This translates to create and archive events.
     *
     * @generated from protobuf enum value: TRANSACTION_SHAPE_ACS_DELTA = 1;
     */
    ACS_DELTA = 1,
    /**
     * Transaction shape that allows maintaining an ACS and also conveys detailed information about
     * all exercises.
     * The field witness_parties in events are populated as cumulative informees, transaction filter will apply accordingly.
     * This translates to create, consuming exercise and non-consuming exercise.
     *
     * @generated from protobuf enum value: TRANSACTION_SHAPE_LEDGER_EFFECTS = 2;
     */
    LEDGER_EFFECTS = 2,
}
// @generated message type with reflection information, may provide speed optimized methods
class Filters$Type extends MessageType<Filters> {
    constructor() {
        super('com.daml.ledger.api.v2.Filters', [
            {
                no: 1,
                name: 'cumulative',
                kind: 'message',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: () => CumulativeFilter,
            },
        ])
    }
    create(value?: PartialMessage<Filters>): Filters {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.cumulative = []
        if (value !== undefined)
            reflectionMergePartial<Filters>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Filters
    ): Filters {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated com.daml.ledger.api.v2.CumulativeFilter cumulative */ 1:
                    message.cumulative.push(
                        CumulativeFilter.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options
                        )
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: Filters,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated com.daml.ledger.api.v2.CumulativeFilter cumulative = 1; */
        for (let i = 0; i < message.cumulative.length; i++)
            CumulativeFilter.internalBinaryWrite(
                message.cumulative[i],
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.Filters
 */
export const Filters = new Filters$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CumulativeFilter$Type extends MessageType<CumulativeFilter> {
    constructor() {
        super('com.daml.ledger.api.v2.CumulativeFilter', [
            {
                no: 1,
                name: 'wildcard_filter',
                kind: 'message',
                oneof: 'identifierFilter',
                T: () => WildcardFilter,
            },
            {
                no: 2,
                name: 'interface_filter',
                kind: 'message',
                oneof: 'identifierFilter',
                T: () => InterfaceFilter,
            },
            {
                no: 3,
                name: 'template_filter',
                kind: 'message',
                oneof: 'identifierFilter',
                T: () => TemplateFilter,
            },
        ])
    }
    create(value?: PartialMessage<CumulativeFilter>): CumulativeFilter {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.identifierFilter = { oneofKind: undefined }
        if (value !== undefined)
            reflectionMergePartial<CumulativeFilter>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CumulativeFilter
    ): CumulativeFilter {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.WildcardFilter wildcard_filter */ 1:
                    message.identifierFilter = {
                        oneofKind: 'wildcardFilter',
                        wildcardFilter: WildcardFilter.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.identifierFilter as any).wildcardFilter
                        ),
                    }
                    break
                case /* com.daml.ledger.api.v2.InterfaceFilter interface_filter */ 2:
                    message.identifierFilter = {
                        oneofKind: 'interfaceFilter',
                        interfaceFilter: InterfaceFilter.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.identifierFilter as any).interfaceFilter
                        ),
                    }
                    break
                case /* com.daml.ledger.api.v2.TemplateFilter template_filter */ 3:
                    message.identifierFilter = {
                        oneofKind: 'templateFilter',
                        templateFilter: TemplateFilter.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.identifierFilter as any).templateFilter
                        ),
                    }
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: CumulativeFilter,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.WildcardFilter wildcard_filter = 1; */
        if (message.identifierFilter.oneofKind === 'wildcardFilter')
            WildcardFilter.internalBinaryWrite(
                message.identifierFilter.wildcardFilter,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.InterfaceFilter interface_filter = 2; */
        if (message.identifierFilter.oneofKind === 'interfaceFilter')
            InterfaceFilter.internalBinaryWrite(
                message.identifierFilter.interfaceFilter,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.TemplateFilter template_filter = 3; */
        if (message.identifierFilter.oneofKind === 'templateFilter')
            TemplateFilter.internalBinaryWrite(
                message.identifierFilter.templateFilter,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.CumulativeFilter
 */
export const CumulativeFilter = new CumulativeFilter$Type()
// @generated message type with reflection information, may provide speed optimized methods
class WildcardFilter$Type extends MessageType<WildcardFilter> {
    constructor() {
        super('com.daml.ledger.api.v2.WildcardFilter', [
            {
                no: 1,
                name: 'include_created_event_blob',
                kind: 'scalar',
                T: 8 /*ScalarType.BOOL*/,
            },
        ])
    }
    create(value?: PartialMessage<WildcardFilter>): WildcardFilter {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.includeCreatedEventBlob = false
        if (value !== undefined)
            reflectionMergePartial<WildcardFilter>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: WildcardFilter
    ): WildcardFilter {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* bool include_created_event_blob */ 1:
                    message.includeCreatedEventBlob = reader.bool()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: WildcardFilter,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* bool include_created_event_blob = 1; */
        if (message.includeCreatedEventBlob !== false)
            writer.tag(1, WireType.Varint).bool(message.includeCreatedEventBlob)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.WildcardFilter
 */
export const WildcardFilter = new WildcardFilter$Type()
// @generated message type with reflection information, may provide speed optimized methods
class InterfaceFilter$Type extends MessageType<InterfaceFilter> {
    constructor() {
        super('com.daml.ledger.api.v2.InterfaceFilter', [
            {
                no: 1,
                name: 'interface_id',
                kind: 'message',
                T: () => Identifier,
            },
            {
                no: 2,
                name: 'include_interface_view',
                kind: 'scalar',
                T: 8 /*ScalarType.BOOL*/,
            },
            {
                no: 3,
                name: 'include_created_event_blob',
                kind: 'scalar',
                T: 8 /*ScalarType.BOOL*/,
            },
        ])
    }
    create(value?: PartialMessage<InterfaceFilter>): InterfaceFilter {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.includeInterfaceView = false
        message.includeCreatedEventBlob = false
        if (value !== undefined)
            reflectionMergePartial<InterfaceFilter>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: InterfaceFilter
    ): InterfaceFilter {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Identifier interface_id */ 1:
                    message.interfaceId = Identifier.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.interfaceId
                    )
                    break
                case /* bool include_interface_view */ 2:
                    message.includeInterfaceView = reader.bool()
                    break
                case /* bool include_created_event_blob */ 3:
                    message.includeCreatedEventBlob = reader.bool()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: InterfaceFilter,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.Identifier interface_id = 1; */
        if (message.interfaceId)
            Identifier.internalBinaryWrite(
                message.interfaceId,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* bool include_interface_view = 2; */
        if (message.includeInterfaceView !== false)
            writer.tag(2, WireType.Varint).bool(message.includeInterfaceView)
        /* bool include_created_event_blob = 3; */
        if (message.includeCreatedEventBlob !== false)
            writer.tag(3, WireType.Varint).bool(message.includeCreatedEventBlob)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.InterfaceFilter
 */
export const InterfaceFilter = new InterfaceFilter$Type()
// @generated message type with reflection information, may provide speed optimized methods
class TemplateFilter$Type extends MessageType<TemplateFilter> {
    constructor() {
        super('com.daml.ledger.api.v2.TemplateFilter', [
            {
                no: 1,
                name: 'template_id',
                kind: 'message',
                T: () => Identifier,
            },
            {
                no: 2,
                name: 'include_created_event_blob',
                kind: 'scalar',
                T: 8 /*ScalarType.BOOL*/,
            },
        ])
    }
    create(value?: PartialMessage<TemplateFilter>): TemplateFilter {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.includeCreatedEventBlob = false
        if (value !== undefined)
            reflectionMergePartial<TemplateFilter>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TemplateFilter
    ): TemplateFilter {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.Identifier template_id */ 1:
                    message.templateId = Identifier.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.templateId
                    )
                    break
                case /* bool include_created_event_blob */ 2:
                    message.includeCreatedEventBlob = reader.bool()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: TemplateFilter,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.Identifier template_id = 1; */
        if (message.templateId)
            Identifier.internalBinaryWrite(
                message.templateId,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* bool include_created_event_blob = 2; */
        if (message.includeCreatedEventBlob !== false)
            writer.tag(2, WireType.Varint).bool(message.includeCreatedEventBlob)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.TemplateFilter
 */
export const TemplateFilter = new TemplateFilter$Type()
// @generated message type with reflection information, may provide speed optimized methods
class TransactionFilter$Type extends MessageType<TransactionFilter> {
    constructor() {
        super('com.daml.ledger.api.v2.TransactionFilter', [
            {
                no: 1,
                name: 'filters_by_party',
                kind: 'map',
                K: 9 /*ScalarType.STRING*/,
                V: { kind: 'message', T: () => Filters },
            },
            {
                no: 2,
                name: 'filters_for_any_party',
                kind: 'message',
                T: () => Filters,
            },
        ])
    }
    create(value?: PartialMessage<TransactionFilter>): TransactionFilter {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.filtersByParty = {}
        if (value !== undefined)
            reflectionMergePartial<TransactionFilter>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TransactionFilter
    ): TransactionFilter {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* map<string, com.daml.ledger.api.v2.Filters> filters_by_party */ 1:
                    this.binaryReadMap1(message.filtersByParty, reader, options)
                    break
                case /* com.daml.ledger.api.v2.Filters filters_for_any_party */ 2:
                    message.filtersForAnyParty = Filters.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.filtersForAnyParty
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    private binaryReadMap1(
        map: TransactionFilter['filtersByParty'],
        reader: IBinaryReader,
        options: BinaryReadOptions
    ): void {
        let len = reader.uint32(),
            end = reader.pos + len,
            key: keyof TransactionFilter['filtersByParty'] | undefined,
            val: TransactionFilter['filtersByParty'][any] | undefined
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case 1:
                    key = reader.string()
                    break
                case 2:
                    val = Filters.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options
                    )
                    break
                default:
                    throw new globalThis.Error(
                        'unknown map entry field for com.daml.ledger.api.v2.TransactionFilter.filters_by_party'
                    )
            }
        }
        map[key ?? ''] = val ?? Filters.create()
    }
    internalBinaryWrite(
        message: TransactionFilter,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* map<string, com.daml.ledger.api.v2.Filters> filters_by_party = 1; */
        for (let k of globalThis.Object.keys(message.filtersByParty)) {
            writer
                .tag(1, WireType.LengthDelimited)
                .fork()
                .tag(1, WireType.LengthDelimited)
                .string(k)
            writer.tag(2, WireType.LengthDelimited).fork()
            Filters.internalBinaryWrite(
                message.filtersByParty[k],
                writer,
                options
            )
            writer.join().join()
        }
        /* com.daml.ledger.api.v2.Filters filters_for_any_party = 2; */
        if (message.filtersForAnyParty)
            Filters.internalBinaryWrite(
                message.filtersForAnyParty,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.TransactionFilter
 */
export const TransactionFilter = new TransactionFilter$Type()
// @generated message type with reflection information, may provide speed optimized methods
class EventFormat$Type extends MessageType<EventFormat> {
    constructor() {
        super('com.daml.ledger.api.v2.EventFormat', [
            {
                no: 1,
                name: 'filters_by_party',
                kind: 'map',
                K: 9 /*ScalarType.STRING*/,
                V: { kind: 'message', T: () => Filters },
            },
            {
                no: 2,
                name: 'filters_for_any_party',
                kind: 'message',
                T: () => Filters,
            },
            {
                no: 3,
                name: 'verbose',
                kind: 'scalar',
                T: 8 /*ScalarType.BOOL*/,
            },
        ])
    }
    create(value?: PartialMessage<EventFormat>): EventFormat {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.filtersByParty = {}
        message.verbose = false
        if (value !== undefined)
            reflectionMergePartial<EventFormat>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: EventFormat
    ): EventFormat {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* map<string, com.daml.ledger.api.v2.Filters> filters_by_party */ 1:
                    this.binaryReadMap1(message.filtersByParty, reader, options)
                    break
                case /* com.daml.ledger.api.v2.Filters filters_for_any_party */ 2:
                    message.filtersForAnyParty = Filters.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.filtersForAnyParty
                    )
                    break
                case /* bool verbose */ 3:
                    message.verbose = reader.bool()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    private binaryReadMap1(
        map: EventFormat['filtersByParty'],
        reader: IBinaryReader,
        options: BinaryReadOptions
    ): void {
        let len = reader.uint32(),
            end = reader.pos + len,
            key: keyof EventFormat['filtersByParty'] | undefined,
            val: EventFormat['filtersByParty'][any] | undefined
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case 1:
                    key = reader.string()
                    break
                case 2:
                    val = Filters.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options
                    )
                    break
                default:
                    throw new globalThis.Error(
                        'unknown map entry field for com.daml.ledger.api.v2.EventFormat.filters_by_party'
                    )
            }
        }
        map[key ?? ''] = val ?? Filters.create()
    }
    internalBinaryWrite(
        message: EventFormat,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* map<string, com.daml.ledger.api.v2.Filters> filters_by_party = 1; */
        for (let k of globalThis.Object.keys(message.filtersByParty)) {
            writer
                .tag(1, WireType.LengthDelimited)
                .fork()
                .tag(1, WireType.LengthDelimited)
                .string(k)
            writer.tag(2, WireType.LengthDelimited).fork()
            Filters.internalBinaryWrite(
                message.filtersByParty[k],
                writer,
                options
            )
            writer.join().join()
        }
        /* com.daml.ledger.api.v2.Filters filters_for_any_party = 2; */
        if (message.filtersForAnyParty)
            Filters.internalBinaryWrite(
                message.filtersForAnyParty,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* bool verbose = 3; */
        if (message.verbose !== false)
            writer.tag(3, WireType.Varint).bool(message.verbose)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.EventFormat
 */
export const EventFormat = new EventFormat$Type()
// @generated message type with reflection information, may provide speed optimized methods
class TransactionFormat$Type extends MessageType<TransactionFormat> {
    constructor() {
        super('com.daml.ledger.api.v2.TransactionFormat', [
            {
                no: 1,
                name: 'event_format',
                kind: 'message',
                T: () => EventFormat,
            },
            {
                no: 2,
                name: 'transaction_shape',
                kind: 'enum',
                T: () => [
                    'com.daml.ledger.api.v2.TransactionShape',
                    TransactionShape,
                    'TRANSACTION_SHAPE_',
                ],
            },
        ])
    }
    create(value?: PartialMessage<TransactionFormat>): TransactionFormat {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.transactionShape = 0
        if (value !== undefined)
            reflectionMergePartial<TransactionFormat>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TransactionFormat
    ): TransactionFormat {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.EventFormat event_format */ 1:
                    message.eventFormat = EventFormat.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.eventFormat
                    )
                    break
                case /* com.daml.ledger.api.v2.TransactionShape transaction_shape */ 2:
                    message.transactionShape = reader.int32()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: TransactionFormat,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.EventFormat event_format = 1; */
        if (message.eventFormat)
            EventFormat.internalBinaryWrite(
                message.eventFormat,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.TransactionShape transaction_shape = 2; */
        if (message.transactionShape !== 0)
            writer.tag(2, WireType.Varint).int32(message.transactionShape)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.TransactionFormat
 */
export const TransactionFormat = new TransactionFormat$Type()
// @generated message type with reflection information, may provide speed optimized methods
class TopologyFormat$Type extends MessageType<TopologyFormat> {
    constructor() {
        super('com.daml.ledger.api.v2.TopologyFormat', [
            {
                no: 1,
                name: 'include_participant_authorization_events',
                kind: 'message',
                T: () => ParticipantAuthorizationTopologyFormat,
            },
        ])
    }
    create(value?: PartialMessage<TopologyFormat>): TopologyFormat {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<TopologyFormat>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: TopologyFormat
    ): TopologyFormat {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.ParticipantAuthorizationTopologyFormat include_participant_authorization_events */ 1:
                    message.includeParticipantAuthorizationEvents =
                        ParticipantAuthorizationTopologyFormat.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.includeParticipantAuthorizationEvents
                        )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: TopologyFormat,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.ParticipantAuthorizationTopologyFormat include_participant_authorization_events = 1; */
        if (message.includeParticipantAuthorizationEvents)
            ParticipantAuthorizationTopologyFormat.internalBinaryWrite(
                message.includeParticipantAuthorizationEvents,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.TopologyFormat
 */
export const TopologyFormat = new TopologyFormat$Type()
// @generated message type with reflection information, may provide speed optimized methods
class ParticipantAuthorizationTopologyFormat$Type extends MessageType<ParticipantAuthorizationTopologyFormat> {
    constructor() {
        super('com.daml.ledger.api.v2.ParticipantAuthorizationTopologyFormat', [
            {
                no: 1,
                name: 'parties',
                kind: 'scalar',
                repeat: 2 /*RepeatType.UNPACKED*/,
                T: 9 /*ScalarType.STRING*/,
            },
        ])
    }
    create(
        value?: PartialMessage<ParticipantAuthorizationTopologyFormat>
    ): ParticipantAuthorizationTopologyFormat {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.parties = []
        if (value !== undefined)
            reflectionMergePartial<ParticipantAuthorizationTopologyFormat>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: ParticipantAuthorizationTopologyFormat
    ): ParticipantAuthorizationTopologyFormat {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated string parties */ 1:
                    message.parties.push(reader.string())
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: ParticipantAuthorizationTopologyFormat,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated string parties = 1; */
        for (let i = 0; i < message.parties.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.parties[i])
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.ParticipantAuthorizationTopologyFormat
 */
export const ParticipantAuthorizationTopologyFormat =
    new ParticipantAuthorizationTopologyFormat$Type()
// @generated message type with reflection information, may provide speed optimized methods
class UpdateFormat$Type extends MessageType<UpdateFormat> {
    constructor() {
        super('com.daml.ledger.api.v2.UpdateFormat', [
            {
                no: 1,
                name: 'include_transactions',
                kind: 'message',
                T: () => TransactionFormat,
            },
            {
                no: 2,
                name: 'include_reassignments',
                kind: 'message',
                T: () => EventFormat,
            },
            {
                no: 3,
                name: 'include_topology_events',
                kind: 'message',
                T: () => TopologyFormat,
            },
        ])
    }
    create(value?: PartialMessage<UpdateFormat>): UpdateFormat {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<UpdateFormat>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: UpdateFormat
    ): UpdateFormat {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.daml.ledger.api.v2.TransactionFormat include_transactions */ 1:
                    message.includeTransactions =
                        TransactionFormat.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.includeTransactions
                        )
                    break
                case /* com.daml.ledger.api.v2.EventFormat include_reassignments */ 2:
                    message.includeReassignments =
                        EventFormat.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.includeReassignments
                        )
                    break
                case /* com.daml.ledger.api.v2.TopologyFormat include_topology_events */ 3:
                    message.includeTopologyEvents =
                        TopologyFormat.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.includeTopologyEvents
                        )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: UpdateFormat,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.daml.ledger.api.v2.TransactionFormat include_transactions = 1; */
        if (message.includeTransactions)
            TransactionFormat.internalBinaryWrite(
                message.includeTransactions,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.EventFormat include_reassignments = 2; */
        if (message.includeReassignments)
            EventFormat.internalBinaryWrite(
                message.includeReassignments,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.daml.ledger.api.v2.TopologyFormat include_topology_events = 3; */
        if (message.includeTopologyEvents)
            TopologyFormat.internalBinaryWrite(
                message.includeTopologyEvents,
                writer.tag(3, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.daml.ledger.api.v2.UpdateFormat
 */
export const UpdateFormat = new UpdateFormat$Type()
