// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/daml/ledger/api/v2/state_service.proto" (package "com.daml.ledger.api.v2", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import type { RpcTransport } from '@protobuf-ts/runtime-rpc'
import type { ServiceInfo } from '@protobuf-ts/runtime-rpc'
import { StateService } from './state_service.js'
import type { GetLatestPrunedOffsetsResponse } from './state_service.js'
import type { GetLatestPrunedOffsetsRequest } from './state_service.js'
import type { GetLedgerEndResponse } from './state_service.js'
import type { GetLedgerEndRequest } from './state_service.js'
import type { GetConnectedSynchronizersResponse } from './state_service.js'
import type { GetConnectedSynchronizersRequest } from './state_service.js'
import type { UnaryCall } from '@protobuf-ts/runtime-rpc'
import { stackIntercept } from '@protobuf-ts/runtime-rpc'
import type { GetActiveContractsResponse } from './state_service.js'
import type { GetActiveContractsRequest } from './state_service.js'
import type { ServerStreamingCall } from '@protobuf-ts/runtime-rpc'
import type { RpcOptions } from '@protobuf-ts/runtime-rpc'
/**
 * Allows clients to get state from the ledger.
 *
 * @generated from protobuf service com.daml.ledger.api.v2.StateService
 */
export interface IStateServiceClient {
    /**
     * Returns a stream of the snapshot of the active contracts and incomplete (un)assignments at a ledger offset.
     * If there are no active contracts, the stream returns a single response message with the offset at which the snapshot has been taken.
     * Clients SHOULD use the offset in the last GetActiveContractsResponse message to continue streaming transactions with the update service.
     * Clients SHOULD NOT assume that the set of active contracts they receive reflects the state at the ledger end.
     *
     * @generated from protobuf rpc: GetActiveContracts
     */
    getActiveContracts(
        input: GetActiveContractsRequest,
        options?: RpcOptions
    ): ServerStreamingCall<
        GetActiveContractsRequest,
        GetActiveContractsResponse
    >
    /**
     * Get the list of connected synchronizers at the time of the query.
     *
     * @generated from protobuf rpc: GetConnectedSynchronizers
     */
    getConnectedSynchronizers(
        input: GetConnectedSynchronizersRequest,
        options?: RpcOptions
    ): UnaryCall<
        GetConnectedSynchronizersRequest,
        GetConnectedSynchronizersResponse
    >
    /**
     * Get the current ledger end.
     * Subscriptions started with the returned offset will serve events after this RPC was called.
     *
     * @generated from protobuf rpc: GetLedgerEnd
     */
    getLedgerEnd(
        input: GetLedgerEndRequest,
        options?: RpcOptions
    ): UnaryCall<GetLedgerEndRequest, GetLedgerEndResponse>
    /**
     * Get the latest successfully pruned ledger offsets
     *
     * @generated from protobuf rpc: GetLatestPrunedOffsets
     */
    getLatestPrunedOffsets(
        input: GetLatestPrunedOffsetsRequest,
        options?: RpcOptions
    ): UnaryCall<GetLatestPrunedOffsetsRequest, GetLatestPrunedOffsetsResponse>
}
/**
 * Allows clients to get state from the ledger.
 *
 * @generated from protobuf service com.daml.ledger.api.v2.StateService
 */
export class StateServiceClient implements IStateServiceClient, ServiceInfo {
    typeName = StateService.typeName
    methods = StateService.methods
    options = StateService.options
    constructor(private readonly _transport: RpcTransport) {}
    /**
     * Returns a stream of the snapshot of the active contracts and incomplete (un)assignments at a ledger offset.
     * If there are no active contracts, the stream returns a single response message with the offset at which the snapshot has been taken.
     * Clients SHOULD use the offset in the last GetActiveContractsResponse message to continue streaming transactions with the update service.
     * Clients SHOULD NOT assume that the set of active contracts they receive reflects the state at the ledger end.
     *
     * @generated from protobuf rpc: GetActiveContracts
     */
    getActiveContracts(
        input: GetActiveContractsRequest,
        options?: RpcOptions
    ): ServerStreamingCall<
        GetActiveContractsRequest,
        GetActiveContractsResponse
    > {
        const method = this.methods[0],
            opt = this._transport.mergeOptions(options)
        return stackIntercept<
            GetActiveContractsRequest,
            GetActiveContractsResponse
        >('serverStreaming', this._transport, method, opt, input)
    }
    /**
     * Get the list of connected synchronizers at the time of the query.
     *
     * @generated from protobuf rpc: GetConnectedSynchronizers
     */
    getConnectedSynchronizers(
        input: GetConnectedSynchronizersRequest,
        options?: RpcOptions
    ): UnaryCall<
        GetConnectedSynchronizersRequest,
        GetConnectedSynchronizersResponse
    > {
        const method = this.methods[1],
            opt = this._transport.mergeOptions(options)
        return stackIntercept<
            GetConnectedSynchronizersRequest,
            GetConnectedSynchronizersResponse
        >('unary', this._transport, method, opt, input)
    }
    /**
     * Get the current ledger end.
     * Subscriptions started with the returned offset will serve events after this RPC was called.
     *
     * @generated from protobuf rpc: GetLedgerEnd
     */
    getLedgerEnd(
        input: GetLedgerEndRequest,
        options?: RpcOptions
    ): UnaryCall<GetLedgerEndRequest, GetLedgerEndResponse> {
        const method = this.methods[2],
            opt = this._transport.mergeOptions(options)
        return stackIntercept<GetLedgerEndRequest, GetLedgerEndResponse>(
            'unary',
            this._transport,
            method,
            opt,
            input
        )
    }
    /**
     * Get the latest successfully pruned ledger offsets
     *
     * @generated from protobuf rpc: GetLatestPrunedOffsets
     */
    getLatestPrunedOffsets(
        input: GetLatestPrunedOffsetsRequest,
        options?: RpcOptions
    ): UnaryCall<
        GetLatestPrunedOffsetsRequest,
        GetLatestPrunedOffsetsResponse
    > {
        const method = this.methods[3],
            opt = this._transport.mergeOptions(options)
        return stackIntercept<
            GetLatestPrunedOffsetsRequest,
            GetLatestPrunedOffsetsResponse
        >('unary', this._transport, method, opt, input)
    }
}
