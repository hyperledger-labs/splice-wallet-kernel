// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "com/digitalasset/canton/crypto/v30/crypto.proto" (package "com.digitalasset.canton.crypto.v30", syntax proto3)
// tslint:disable
//
// Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0
//
import type { BinaryWriteOptions } from '@protobuf-ts/runtime'
import type { IBinaryWriter } from '@protobuf-ts/runtime'
import { WireType } from '@protobuf-ts/runtime'
import type { BinaryReadOptions } from '@protobuf-ts/runtime'
import type { IBinaryReader } from '@protobuf-ts/runtime'
import { UnknownFieldHandler } from '@protobuf-ts/runtime'
import type { PartialMessage } from '@protobuf-ts/runtime'
import { reflectionMergePartial } from '@protobuf-ts/runtime'
import { MessageType } from '@protobuf-ts/runtime'
/**
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.Hmac
 */
export interface Hmac {
    /**
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.HmacAlgorithm algorithm = 1
     */
    algorithm: HmacAlgorithm
    /**
     * @generated from protobuf field: bytes hmac = 2
     */
    hmac: Uint8Array
}
/**
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.Salt
 */
export interface Salt {
    /**
     * @generated from protobuf oneof: algorithm
     */
    algorithm:
        | {
              oneofKind: 'hmac'
              /**
               * @generated from protobuf field: com.digitalasset.canton.crypto.v30.HmacAlgorithm hmac = 1
               */
              hmac: HmacAlgorithm
          }
        | {
              oneofKind: undefined
          }
    /**
     * @generated from protobuf field: bytes salt = 2
     */
    salt: Uint8Array
}
/**
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.Signature
 */
export interface Signature {
    /**
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.SignatureFormat format = 1
     */
    format: SignatureFormat
    /**
     * @generated from protobuf field: bytes signature = 2
     */
    signature: Uint8Array
    /**
     * The fingerprint/id of the keypair used to create this signature and needed to verify.
     * If a signature delegation is defined, this fingerprint/id is not used to produce the signature, and, instead
     * is used to sign the delegation.
     *
     * @generated from protobuf field: string signed_by = 3
     */
    signedBy: string
    /**
     * The signing algorithm specification used to produce this signature
     *
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec signing_algorithm_spec = 4
     */
    signingAlgorithmSpec: SigningAlgorithmSpec
    /**
     * An optional signature delegation where a long-term signing key authorizes a session signing key to sign on its
     * behalf.
     *
     * @generated from protobuf field: optional com.digitalasset.canton.crypto.v30.SignatureDelegation signature_delegation = 5
     */
    signatureDelegation?: SignatureDelegation
}
/**
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.SignatureDelegation
 */
export interface SignatureDelegation {
    /**
     * ASN.1 + DER-encoding of X.509 SubjectPublicKeyInfo structure of the session public key:
     * https://datatracker.ietf.org/doc/html/rfc5280#section-4.1. This key was used to produce the actual signature.
     *
     * @generated from protobuf field: bytes session_key = 1
     */
    sessionKey: Uint8Array
    /**
     * The signing key spec for the session key.
     *
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.SigningKeySpec session_key_spec = 2
     */
    sessionKeySpec: SigningKeySpec
    /**
     * A timestamp in microseconds of UTC time since Unix epoch that indicates when the session key is
     * considered valid.
     *
     * @generated from protobuf field: int64 validity_period_from_inclusive = 3
     */
    validityPeriodFromInclusive: bigint
    /**
     * Duration in seconds indicating how long the session key remains valid.
     * The validity period starts from `validity_period_from_inclusive` above.
     *
     * @generated from protobuf field: uint32 validity_period_duration_seconds = 4
     */
    validityPeriodDurationSeconds: number
    /**
     * The format of the signature
     *
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.SignatureFormat format = 5
     */
    format: SignatureFormat
    /**
     * The signature of the combined hash of the session key fingerprint, validity period, and synchronizer id, by the
     * long-term key. This signature authorizes the session key to act on behalf of the long-term key.
     *
     * @generated from protobuf field: bytes signature = 6
     */
    signature: Uint8Array
    /**
     * The signing algorithm specification used to produce this signature
     *
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec signing_algorithm_spec = 7
     */
    signingAlgorithmSpec: SigningAlgorithmSpec
}
/**
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.PublicKey
 */
export interface PublicKey {
    /**
     * @generated from protobuf oneof: key
     */
    key:
        | {
              oneofKind: 'signingPublicKey'
              /**
               * @generated from protobuf field: com.digitalasset.canton.crypto.v30.SigningPublicKey signing_public_key = 1
               */
              signingPublicKey: SigningPublicKey
          }
        | {
              oneofKind: 'encryptionPublicKey'
              /**
               * @generated from protobuf field: com.digitalasset.canton.crypto.v30.EncryptionPublicKey encryption_public_key = 2
               */
              encryptionPublicKey: EncryptionPublicKey
          }
        | {
              oneofKind: undefined
          }
}
/**
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.PublicKeyWithName
 */
export interface PublicKeyWithName {
    /**
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.PublicKey public_key = 1
     */
    publicKey?: PublicKey
    /**
     * Optional name of the public key
     *
     * @generated from protobuf field: string name = 2
     */
    name: string
}
/**
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.PrivateKey
 */
export interface PrivateKey {
    /**
     * @generated from protobuf oneof: key
     */
    key:
        | {
              oneofKind: 'signingPrivateKey'
              /**
               * @generated from protobuf field: com.digitalasset.canton.crypto.v30.SigningPrivateKey signing_private_key = 1
               */
              signingPrivateKey: SigningPrivateKey
          }
        | {
              oneofKind: 'encryptionPrivateKey'
              /**
               * @generated from protobuf field: com.digitalasset.canton.crypto.v30.EncryptionPrivateKey encryption_private_key = 2
               */
              encryptionPrivateKey: EncryptionPrivateKey
          }
        | {
              oneofKind: undefined
          }
}
/**
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.SigningPublicKey
 */
export interface SigningPublicKey {
    /**
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.CryptoKeyFormat format = 2
     */
    format: CryptoKeyFormat
    /**
     * Serialized public key in the format specified above
     *
     * @generated from protobuf field: bytes public_key = 3
     */
    publicKey: Uint8Array
    /**
     * No longer used (only kept for backwards compatibility) stores both the crypto key scheme and algorithm.
     *
     * @deprecated
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.SigningKeyScheme scheme = 4 [deprecated = true]
     */
    scheme: SigningKeyScheme
    /**
     * Explicitly state the key's intended use
     *
     * @generated from protobuf field: repeated com.digitalasset.canton.crypto.v30.SigningKeyUsage usage = 5
     */
    usage: SigningKeyUsage[]
    /**
     * The key specification that was used to generate the key pair
     *
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.SigningKeySpec key_spec = 6
     */
    keySpec: SigningKeySpec
}
/**
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.SigningPrivateKey
 */
export interface SigningPrivateKey {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string
    /**
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.CryptoKeyFormat format = 2
     */
    format: CryptoKeyFormat
    /**
     * Serialized private key in the format specified above
     *
     * @generated from protobuf field: bytes private_key = 3
     */
    privateKey: Uint8Array
    /**
     * No longer used (only kept for backwards compatibility) stores both the crypto key scheme and algorithm.
     *
     * @deprecated
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.SigningKeyScheme scheme = 4 [deprecated = true]
     */
    scheme: SigningKeyScheme
    /**
     * Explicitly state the key's intended use
     *
     * @generated from protobuf field: repeated com.digitalasset.canton.crypto.v30.SigningKeyUsage usage = 5
     */
    usage: SigningKeyUsage[]
    /**
     * The key specification that was used to generate the key pair
     *
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.SigningKeySpec key_spec = 6
     */
    keySpec: SigningKeySpec
}
/**
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.SigningKeyPair
 */
export interface SigningKeyPair {
    /**
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.SigningPublicKey public_key = 1
     */
    publicKey?: SigningPublicKey
    /**
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.SigningPrivateKey private_key = 2
     */
    privateKey?: SigningPrivateKey
}
/**
 * Used to announce the required signing key and algorithm specifications in the static synchronizer parameters.
 *
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.RequiredSigningSpecs
 */
export interface RequiredSigningSpecs {
    /**
     * @generated from protobuf field: repeated com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec algorithms = 1
     */
    algorithms: SigningAlgorithmSpec[]
    /**
     * @generated from protobuf field: repeated com.digitalasset.canton.crypto.v30.SigningKeySpec keys = 2
     */
    keys: SigningKeySpec[]
}
/**
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.EncryptionPublicKey
 */
export interface EncryptionPublicKey {
    /**
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.CryptoKeyFormat format = 2
     */
    format: CryptoKeyFormat
    /**
     * Serialized public key in the format specified above
     *
     * @generated from protobuf field: bytes public_key = 3
     */
    publicKey: Uint8Array
    /**
     * No longer used (only kept for backwards compatibility) stores both the crypto key scheme and algorithm.
     *
     * @deprecated
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.EncryptionKeyScheme scheme = 4 [deprecated = true]
     */
    scheme: EncryptionKeyScheme
    /**
     * The key specification that was used to generate the key pair
     *
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.EncryptionKeySpec key_spec = 5
     */
    keySpec: EncryptionKeySpec
}
/**
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.EncryptionPrivateKey
 */
export interface EncryptionPrivateKey {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string
    /**
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.CryptoKeyFormat format = 2
     */
    format: CryptoKeyFormat
    /**
     * Serialized private key in the format specified above
     *
     * @generated from protobuf field: bytes private_key = 3
     */
    privateKey: Uint8Array
    /**
     * No longer used (only kept for backwards compatibility) stores both the crypto key scheme and algorithm.
     *
     * @deprecated
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.EncryptionKeyScheme scheme = 4 [deprecated = true]
     */
    scheme: EncryptionKeyScheme
    /**
     * The key specification that was used to generate the key pair
     *
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.EncryptionKeySpec key_spec = 5
     */
    keySpec: EncryptionKeySpec
}
/**
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.EncryptionKeyPair
 */
export interface EncryptionKeyPair {
    /**
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.EncryptionPublicKey public_key = 1
     */
    publicKey?: EncryptionPublicKey
    /**
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.EncryptionPrivateKey private_key = 2
     */
    privateKey?: EncryptionPrivateKey
}
/**
 * Used to announce the required encryption key and algorithm specifications in the static synchronizer parameters.
 *
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.RequiredEncryptionSpecs
 */
export interface RequiredEncryptionSpecs {
    /**
     * @generated from protobuf field: repeated com.digitalasset.canton.crypto.v30.EncryptionAlgorithmSpec algorithms = 1
     */
    algorithms: EncryptionAlgorithmSpec[]
    /**
     * @generated from protobuf field: repeated com.digitalasset.canton.crypto.v30.EncryptionKeySpec keys = 2
     */
    keys: EncryptionKeySpec[]
}
/**
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.CryptoKeyPair
 */
export interface CryptoKeyPair {
    /**
     * @generated from protobuf oneof: pair
     */
    pair:
        | {
              oneofKind: 'signingKeyPair'
              /**
               * @generated from protobuf field: com.digitalasset.canton.crypto.v30.SigningKeyPair signing_key_pair = 1
               */
              signingKeyPair: SigningKeyPair
          }
        | {
              oneofKind: 'encryptionKeyPair'
              /**
               * @generated from protobuf field: com.digitalasset.canton.crypto.v30.EncryptionKeyPair encryption_key_pair = 2
               */
              encryptionKeyPair: EncryptionKeyPair
          }
        | {
              oneofKind: undefined
          }
}
/**
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.SymmetricKey
 */
export interface SymmetricKey {
    /**
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.CryptoKeyFormat format = 1
     */
    format: CryptoKeyFormat
    /**
     * @generated from protobuf field: bytes key = 2
     */
    key: Uint8Array
    /**
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.SymmetricKeyScheme scheme = 3
     */
    scheme: SymmetricKeyScheme
}
/**
 * A password-based encrypted message
 *
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.PasswordBasedEncrypted
 */
export interface PasswordBasedEncrypted {
    /**
     * @generated from protobuf field: bytes ciphertext = 1
     */
    ciphertext: Uint8Array
    /**
     * The symmetric encryption scheme that was used to encrypt the plaintext
     *
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.SymmetricKeyScheme symmetric_key_scheme = 2
     */
    symmetricKeyScheme: SymmetricKeyScheme
    /**
     * The password-based KDF that was used to derive the symmetric encryption key from the password
     *
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.PbkdfScheme pbkdf_scheme = 3
     */
    pbkdfScheme: PbkdfScheme
    /**
     * The random salt that was used to derive the symmetric encryption key from the password
     *
     * @generated from protobuf field: bytes salt = 4
     */
    salt: Uint8Array
}
/**
 * @generated from protobuf message com.digitalasset.canton.crypto.v30.AsymmetricEncrypted
 */
export interface AsymmetricEncrypted {
    /**
     * Asymmetrically encrypted data
     *
     * @generated from protobuf field: bytes ciphertext = 1
     */
    ciphertext: Uint8Array
    /**
     * The asymmetric encryption specification used for the encryption
     *
     * @generated from protobuf field: com.digitalasset.canton.crypto.v30.EncryptionAlgorithmSpec encryption_algorithm_spec = 2
     */
    encryptionAlgorithmSpec: EncryptionAlgorithmSpec
    /**
     * The fingerprint of the public key that was used for the encryption
     *
     * @generated from protobuf field: string fingerprint = 3
     */
    fingerprint: string
}
/**
 * @generated from protobuf enum com.digitalasset.canton.crypto.v30.HashAlgorithm
 */
export enum HashAlgorithm {
    /**
     * @generated from protobuf enum value: HASH_ALGORITHM_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: HASH_ALGORITHM_SHA256 = 1;
     */
    SHA256 = 1,
}
/**
 * @generated from protobuf enum com.digitalasset.canton.crypto.v30.HmacAlgorithm
 */
export enum HmacAlgorithm {
    /**
     * @generated from protobuf enum value: HMAC_ALGORITHM_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: HMAC_ALGORITHM_HMAC_SHA256 = 1;
     */
    HMAC_SHA256 = 1,
}
/**
 * @generated from protobuf enum com.digitalasset.canton.crypto.v30.SignatureFormat
 */
export enum SignatureFormat {
    /**
     * @generated from protobuf enum value: SIGNATURE_FORMAT_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Signature scheme specific signature format
     * Legacy format no longer used, except for migrations
     *
     * @generated from protobuf enum value: SIGNATURE_FORMAT_RAW = 1;
     */
    RAW = 1,
    /**
     * ASN.1 + DER-encoding of the `r` and `s` integers, as defined in https://datatracker.ietf.org/doc/html/rfc3279#section-2.2.3
     * Used for ECDSA signatures
     *
     * @generated from protobuf enum value: SIGNATURE_FORMAT_DER = 2;
     */
    DER = 2,
    /**
     * Concatenation of the integers `r || s` in little-endian form, as defined in https://datatracker.ietf.org/doc/html/rfc8032#section-3.3
     * Note that this is different from the format defined in IEEE P1363, which uses concatenation in big-endian form.
     * Used for EdDSA signatures
     *
     * @generated from protobuf enum value: SIGNATURE_FORMAT_CONCAT = 3;
     */
    CONCAT = 3,
    /**
     * Symbolic crypto, must only be used for testing
     *
     * @generated from protobuf enum value: SIGNATURE_FORMAT_SYMBOLIC = 10000;
     */
    SYMBOLIC = 10000,
}
/**
 * @generated from protobuf enum com.digitalasset.canton.crypto.v30.EncryptionKeySpec
 */
export enum EncryptionKeySpec {
    /**
     * @generated from protobuf enum value: ENCRYPTION_KEY_SPEC_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Elliptic Curve Key from the NIST P-256 curve (aka Secp256r1)
     * as defined in https://doi.org/10.6028/NIST.FIPS.186-4
     *
     * @generated from protobuf enum value: ENCRYPTION_KEY_SPEC_EC_P256 = 1;
     */
    EC_P256 = 1,
    /**
     * RSA with 2048 bits
     *
     * @generated from protobuf enum value: ENCRYPTION_KEY_SPEC_RSA_2048 = 2;
     */
    RSA_2048 = 2,
}
/**
 * [start-docs-entry: signing key spec proto]
 *
 * @generated from protobuf enum com.digitalasset.canton.crypto.v30.SigningKeySpec
 */
export enum SigningKeySpec {
    /**
     * @generated from protobuf enum value: SIGNING_KEY_SPEC_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Elliptic Curve Key from Curve25519
     * as defined in http://ed25519.cr.yp.to/
     *
     * @generated from protobuf enum value: SIGNING_KEY_SPEC_EC_CURVE25519 = 1;
     */
    EC_CURVE25519 = 1,
    /**
     * Elliptic Curve Key from the NIST P-256 curve (aka secp256r1)
     * as defined in https://doi.org/10.6028/NIST.FIPS.186-4
     *
     * @generated from protobuf enum value: SIGNING_KEY_SPEC_EC_P256 = 2;
     */
    EC_P256 = 2,
    /**
     * Elliptic Curve Key from the NIST P-384 curve (aka secp384r1)
     * as defined in https://doi.org/10.6028/NIST.FIPS.186-4
     *
     * @generated from protobuf enum value: SIGNING_KEY_SPEC_EC_P384 = 3;
     */
    EC_P384 = 3,
    /**
     * Elliptic Curve Key from SECG P256k1 curve (aka secp256k1)
     * commonly used in bitcoin and ethereum
     * as defined in https://www.secg.org/sec2-v2.pdf
     *
     * @generated from protobuf enum value: SIGNING_KEY_SPEC_EC_SECP256K1 = 4;
     */
    EC_SECP256K1 = 4,
}
/**
 * @generated from protobuf enum com.digitalasset.canton.crypto.v30.KeyPurpose
 */
export enum KeyPurpose {
    /**
     * @generated from protobuf enum value: KEY_PURPOSE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: KEY_PURPOSE_SIGNING = 1;
     */
    SIGNING = 1,
    /**
     * @generated from protobuf enum value: KEY_PURPOSE_ENCRYPTION = 2;
     */
    ENCRYPTION = 2,
}
/**
 * @generated from protobuf enum com.digitalasset.canton.crypto.v30.SigningKeyUsage
 */
export enum SigningKeyUsage {
    /**
     * @generated from protobuf enum value: SIGNING_KEY_USAGE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * the root namespace key that defines a node's identity and signs topology requests
     *
     * @generated from protobuf enum value: SIGNING_KEY_USAGE_NAMESPACE = 1;
     */
    NAMESPACE = 1,
    /**
     * No longer used (only kept for backwards compatibility)
     *
     * @deprecated
     * @generated from protobuf enum value: SIGNING_KEY_USAGE_IDENTITY_DELEGATION = 2 [deprecated = true];
     */
    IDENTITY_DELEGATION = 2,
    /**
     * keys that authenticate members of the network towards a sequencer
     *
     * @generated from protobuf enum value: SIGNING_KEY_USAGE_SEQUENCER_AUTHENTICATION = 3;
     */
    SEQUENCER_AUTHENTICATION = 3,
    /**
     * keys that deal with all the signing that happens as part of the protocol
     *
     * @generated from protobuf enum value: SIGNING_KEY_USAGE_PROTOCOL = 4;
     */
    PROTOCOL = 4,
    /**
     * used internally to identify keys that can self-sign to prove ownership
     *
     * @generated from protobuf enum value: SIGNING_KEY_USAGE_PROOF_OF_OWNERSHIP = 5;
     */
    PROOF_OF_OWNERSHIP = 5,
}
/**
 * @generated from protobuf enum com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec
 */
export enum SigningAlgorithmSpec {
    /**
     * @generated from protobuf enum value: SIGNING_ALGORITHM_SPEC_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * EdDSA Signature based on Curve25519 with SHA-512
     * http://ed25519.cr.yp.to/
     *
     * @generated from protobuf enum value: SIGNING_ALGORITHM_SPEC_ED25519 = 1;
     */
    ED25519 = 1,
    /**
     * Elliptic Curve Digital Signature Algorithm with SHA256
     *
     * @generated from protobuf enum value: SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_256 = 2;
     */
    EC_DSA_SHA_256 = 2,
    /**
     * Elliptic Curve Digital Signature Algorithm with SHA384
     *
     * @generated from protobuf enum value: SIGNING_ALGORITHM_SPEC_EC_DSA_SHA_384 = 3;
     */
    EC_DSA_SHA_384 = 3,
}
/**
 * @deprecated
 *
 * @generated from protobuf enum com.digitalasset.canton.crypto.v30.SigningKeyScheme
 */
export enum SigningKeyScheme {
    /**
     * @generated from protobuf enum value: SIGNING_KEY_SCHEME_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Signature based on Curve25519
     * http://ed25519.cr.yp.to/
     *
     * @generated from protobuf enum value: SIGNING_KEY_SCHEME_ED25519 = 1;
     */
    ED25519 = 1,
    /**
     * EC-DSA with NIST curve P-256 or P-384
     *
     * @generated from protobuf enum value: SIGNING_KEY_SCHEME_EC_DSA_P256 = 2;
     */
    EC_DSA_P256 = 2,
    /**
     * @generated from protobuf enum value: SIGNING_KEY_SCHEME_EC_DSA_P384 = 3;
     */
    EC_DSA_P384 = 3,
}
/**
 * @generated from protobuf enum com.digitalasset.canton.crypto.v30.EncryptionAlgorithmSpec
 */
export enum EncryptionAlgorithmSpec {
    /**
     * @generated from protobuf enum value: ENCRYPTION_ALGORITHM_SPEC_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * ECIES with ECDH, AES128 GCM, and HKDF and authentication (MAC) with HMAC-SHA256. This requires a P-256 key
     * because we use SHA256 and we need to align the lengths of the curve and the hash function.
     *
     * @generated from protobuf enum value: ENCRYPTION_ALGORITHM_SPEC_ECIES_HKDF_HMAC_SHA256_AES128GCM = 1;
     */
    ECIES_HKDF_HMAC_SHA256_AES128GCM = 1,
    /**
     * ECIES with ECDH, AES128 CBC, and HKDF and authentication (MAC) with HMAC-SHA256. This requires a P-256 key
     * because we use SHA256 and we need to align the lengths of the curve the and hash function.
     *
     * @generated from protobuf enum value: ENCRYPTION_ALGORITHM_SPEC_ECIES_HKDF_HMAC_SHA256_AES128CBC = 2;
     */
    ECIES_HKDF_HMAC_SHA256_AES128CBC = 2,
    /**
     * RSA with OAEP Padding,
     * using SHA-256 for both the hash and in the MGF1 mask generation function along with an empty label.
     *
     * @generated from protobuf enum value: ENCRYPTION_ALGORITHM_SPEC_RSA_OAEP_SHA256 = 3;
     */
    RSA_OAEP_SHA256 = 3,
}
/**
 * @deprecated
 *
 * @generated from protobuf enum com.digitalasset.canton.crypto.v30.EncryptionKeyScheme
 */
export enum EncryptionKeyScheme {
    /**
     * @generated from protobuf enum value: ENCRYPTION_KEY_SCHEME_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * ECIES with ECDH over NIST P-256, AES128 GCM, and HKDF with HMAC-SHA256
     *
     * @generated from protobuf enum value: ENCRYPTION_KEY_SCHEME_ECIES_P256_HKDF_HMAC_SHA256_AES128GCM = 1;
     */
    ECIES_P256_HKDF_HMAC_SHA256_AES128GCM = 1,
    /**
     * ECIES with ECDH over NIST P-256, AES128 CBC, and HKDF and authentication with HMAC-SHA256
     *
     * @generated from protobuf enum value: ENCRYPTION_KEY_SCHEME_ECIES_P256_HMAC_SHA256A_ES128CBC = 2;
     */
    ECIES_P256_HMAC_SHA256A_ES128CBC = 2,
    /**
     * RSA with a 2048 bit key with OAEP Padding,
     * using SHA-256 for both the hash and in the MGF1 mask generation function along with an empty label.
     *
     * @generated from protobuf enum value: ENCRYPTION_KEY_SCHEME_RSA2048_OAEP_SHA256 = 3;
     */
    RSA2048_OAEP_SHA256 = 3,
}
/**
 * @generated from protobuf enum com.digitalasset.canton.crypto.v30.SymmetricKeyScheme
 */
export enum SymmetricKeyScheme {
    /**
     * @generated from protobuf enum value: SYMMETRIC_KEY_SCHEME_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * AES with 128bit keys in GCM
     *
     * @generated from protobuf enum value: SYMMETRIC_KEY_SCHEME_AES128GCM = 1;
     */
    AES128GCM = 1,
}
/**
 * Serialization format for crypto keys and signatures
 *
 * @generated from protobuf enum com.digitalasset.canton.crypto.v30.CryptoKeyFormat
 */
export enum CryptoKeyFormat {
    /**
     * @generated from protobuf enum value: CRYPTO_KEY_FORMAT_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * ASN.1 + DER encoding
     * Legacy format no longer used, except for migrations
     *
     * @generated from protobuf enum value: CRYPTO_KEY_FORMAT_DER = 2;
     */
    DER = 2,
    /**
     * Raw encoding of a key, used for symmetric keys
     *
     * @generated from protobuf enum value: CRYPTO_KEY_FORMAT_RAW = 3;
     */
    RAW = 3,
    /**
     * ASN.1 + DER-encoding of X.509 SubjectPublicKeyInfo structure: https://datatracker.ietf.org/doc/html/rfc5280#section-4.1
     *
     * @generated from protobuf enum value: CRYPTO_KEY_FORMAT_DER_X509_SUBJECT_PUBLIC_KEY_INFO = 4;
     */
    DER_X509_SUBJECT_PUBLIC_KEY_INFO = 4,
    /**
     * ASN.1 + DER-encoding of PKCS #8 PrivateKeyInfo structure: https://datatracker.ietf.org/doc/html/rfc5208#section-5
     *
     * @generated from protobuf enum value: CRYPTO_KEY_FORMAT_DER_PKCS8_PRIVATE_KEY_INFO = 5;
     */
    DER_PKCS8_PRIVATE_KEY_INFO = 5,
    /**
     * Symbolic crypto, must only be used for testing
     *
     * @generated from protobuf enum value: CRYPTO_KEY_FORMAT_SYMBOLIC = 10000;
     */
    SYMBOLIC = 10000,
}
/**
 * @generated from protobuf enum com.digitalasset.canton.crypto.v30.PbkdfScheme
 */
export enum PbkdfScheme {
    /**
     * @generated from protobuf enum value: PBKDF_SCHEME_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Argon2id with m=12288 (12 MiB), t=3, p=1
     *
     * @generated from protobuf enum value: PBKDF_SCHEME_ARGON2ID_MODE1 = 1;
     */
    ARGON2ID_MODE1 = 1,
}
// @generated message type with reflection information, may provide speed optimized methods
class Hmac$Type extends MessageType<Hmac> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.Hmac', [
            {
                no: 1,
                name: 'algorithm',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.HmacAlgorithm',
                    HmacAlgorithm,
                    'HMAC_ALGORITHM_',
                ],
            },
            { no: 2, name: 'hmac', kind: 'scalar', T: 12 /*ScalarType.BYTES*/ },
        ])
    }
    create(value?: PartialMessage<Hmac>): Hmac {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.algorithm = 0
        message.hmac = new Uint8Array(0)
        if (value !== undefined)
            reflectionMergePartial<Hmac>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Hmac
    ): Hmac {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.crypto.v30.HmacAlgorithm algorithm */ 1:
                    message.algorithm = reader.int32()
                    break
                case /* bytes hmac */ 2:
                    message.hmac = reader.bytes()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: Hmac,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.crypto.v30.HmacAlgorithm algorithm = 1; */
        if (message.algorithm !== 0)
            writer.tag(1, WireType.Varint).int32(message.algorithm)
        /* bytes hmac = 2; */
        if (message.hmac.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.hmac)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.Hmac
 */
export const Hmac = new Hmac$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Salt$Type extends MessageType<Salt> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.Salt', [
            {
                no: 1,
                name: 'hmac',
                kind: 'enum',
                oneof: 'algorithm',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.HmacAlgorithm',
                    HmacAlgorithm,
                    'HMAC_ALGORITHM_',
                ],
            },
            { no: 2, name: 'salt', kind: 'scalar', T: 12 /*ScalarType.BYTES*/ },
        ])
    }
    create(value?: PartialMessage<Salt>): Salt {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.algorithm = { oneofKind: undefined }
        message.salt = new Uint8Array(0)
        if (value !== undefined)
            reflectionMergePartial<Salt>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Salt
    ): Salt {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.crypto.v30.HmacAlgorithm hmac */ 1:
                    message.algorithm = {
                        oneofKind: 'hmac',
                        hmac: reader.int32(),
                    }
                    break
                case /* bytes salt */ 2:
                    message.salt = reader.bytes()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: Salt,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.crypto.v30.HmacAlgorithm hmac = 1; */
        if (message.algorithm.oneofKind === 'hmac')
            writer.tag(1, WireType.Varint).int32(message.algorithm.hmac)
        /* bytes salt = 2; */
        if (message.salt.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.salt)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.Salt
 */
export const Salt = new Salt$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Signature$Type extends MessageType<Signature> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.Signature', [
            {
                no: 1,
                name: 'format',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.SignatureFormat',
                    SignatureFormat,
                    'SIGNATURE_FORMAT_',
                ],
            },
            {
                no: 2,
                name: 'signature',
                kind: 'scalar',
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 3,
                name: 'signed_by',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
            {
                no: 4,
                name: 'signing_algorithm_spec',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec',
                    SigningAlgorithmSpec,
                    'SIGNING_ALGORITHM_SPEC_',
                ],
            },
            {
                no: 5,
                name: 'signature_delegation',
                kind: 'message',
                T: () => SignatureDelegation,
            },
        ])
    }
    create(value?: PartialMessage<Signature>): Signature {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.format = 0
        message.signature = new Uint8Array(0)
        message.signedBy = ''
        message.signingAlgorithmSpec = 0
        if (value !== undefined)
            reflectionMergePartial<Signature>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: Signature
    ): Signature {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.crypto.v30.SignatureFormat format */ 1:
                    message.format = reader.int32()
                    break
                case /* bytes signature */ 2:
                    message.signature = reader.bytes()
                    break
                case /* string signed_by */ 3:
                    message.signedBy = reader.string()
                    break
                case /* com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec signing_algorithm_spec */ 4:
                    message.signingAlgorithmSpec = reader.int32()
                    break
                case /* optional com.digitalasset.canton.crypto.v30.SignatureDelegation signature_delegation */ 5:
                    message.signatureDelegation =
                        SignatureDelegation.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.signatureDelegation
                        )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: Signature,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.crypto.v30.SignatureFormat format = 1; */
        if (message.format !== 0)
            writer.tag(1, WireType.Varint).int32(message.format)
        /* bytes signature = 2; */
        if (message.signature.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.signature)
        /* string signed_by = 3; */
        if (message.signedBy !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.signedBy)
        /* com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec signing_algorithm_spec = 4; */
        if (message.signingAlgorithmSpec !== 0)
            writer.tag(4, WireType.Varint).int32(message.signingAlgorithmSpec)
        /* optional com.digitalasset.canton.crypto.v30.SignatureDelegation signature_delegation = 5; */
        if (message.signatureDelegation)
            SignatureDelegation.internalBinaryWrite(
                message.signatureDelegation,
                writer.tag(5, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.Signature
 */
export const Signature = new Signature$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SignatureDelegation$Type extends MessageType<SignatureDelegation> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.SignatureDelegation', [
            {
                no: 1,
                name: 'session_key',
                kind: 'scalar',
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 2,
                name: 'session_key_spec',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.SigningKeySpec',
                    SigningKeySpec,
                    'SIGNING_KEY_SPEC_',
                ],
            },
            {
                no: 3,
                name: 'validity_period_from_inclusive',
                kind: 'scalar',
                T: 3 /*ScalarType.INT64*/,
                L: 0 /*LongType.BIGINT*/,
            },
            {
                no: 4,
                name: 'validity_period_duration_seconds',
                kind: 'scalar',
                T: 13 /*ScalarType.UINT32*/,
            },
            {
                no: 5,
                name: 'format',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.SignatureFormat',
                    SignatureFormat,
                    'SIGNATURE_FORMAT_',
                ],
            },
            {
                no: 6,
                name: 'signature',
                kind: 'scalar',
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 7,
                name: 'signing_algorithm_spec',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec',
                    SigningAlgorithmSpec,
                    'SIGNING_ALGORITHM_SPEC_',
                ],
            },
        ])
    }
    create(value?: PartialMessage<SignatureDelegation>): SignatureDelegation {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.sessionKey = new Uint8Array(0)
        message.sessionKeySpec = 0
        message.validityPeriodFromInclusive = 0n
        message.validityPeriodDurationSeconds = 0
        message.format = 0
        message.signature = new Uint8Array(0)
        message.signingAlgorithmSpec = 0
        if (value !== undefined)
            reflectionMergePartial<SignatureDelegation>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SignatureDelegation
    ): SignatureDelegation {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* bytes session_key */ 1:
                    message.sessionKey = reader.bytes()
                    break
                case /* com.digitalasset.canton.crypto.v30.SigningKeySpec session_key_spec */ 2:
                    message.sessionKeySpec = reader.int32()
                    break
                case /* int64 validity_period_from_inclusive */ 3:
                    message.validityPeriodFromInclusive = reader
                        .int64()
                        .toBigInt()
                    break
                case /* uint32 validity_period_duration_seconds */ 4:
                    message.validityPeriodDurationSeconds = reader.uint32()
                    break
                case /* com.digitalasset.canton.crypto.v30.SignatureFormat format */ 5:
                    message.format = reader.int32()
                    break
                case /* bytes signature */ 6:
                    message.signature = reader.bytes()
                    break
                case /* com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec signing_algorithm_spec */ 7:
                    message.signingAlgorithmSpec = reader.int32()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: SignatureDelegation,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* bytes session_key = 1; */
        if (message.sessionKey.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.sessionKey)
        /* com.digitalasset.canton.crypto.v30.SigningKeySpec session_key_spec = 2; */
        if (message.sessionKeySpec !== 0)
            writer.tag(2, WireType.Varint).int32(message.sessionKeySpec)
        /* int64 validity_period_from_inclusive = 3; */
        if (message.validityPeriodFromInclusive !== 0n)
            writer
                .tag(3, WireType.Varint)
                .int64(message.validityPeriodFromInclusive)
        /* uint32 validity_period_duration_seconds = 4; */
        if (message.validityPeriodDurationSeconds !== 0)
            writer
                .tag(4, WireType.Varint)
                .uint32(message.validityPeriodDurationSeconds)
        /* com.digitalasset.canton.crypto.v30.SignatureFormat format = 5; */
        if (message.format !== 0)
            writer.tag(5, WireType.Varint).int32(message.format)
        /* bytes signature = 6; */
        if (message.signature.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.signature)
        /* com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec signing_algorithm_spec = 7; */
        if (message.signingAlgorithmSpec !== 0)
            writer.tag(7, WireType.Varint).int32(message.signingAlgorithmSpec)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.SignatureDelegation
 */
export const SignatureDelegation = new SignatureDelegation$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PublicKey$Type extends MessageType<PublicKey> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.PublicKey', [
            {
                no: 1,
                name: 'signing_public_key',
                kind: 'message',
                oneof: 'key',
                T: () => SigningPublicKey,
            },
            {
                no: 2,
                name: 'encryption_public_key',
                kind: 'message',
                oneof: 'key',
                T: () => EncryptionPublicKey,
            },
        ])
    }
    create(value?: PartialMessage<PublicKey>): PublicKey {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.key = { oneofKind: undefined }
        if (value !== undefined)
            reflectionMergePartial<PublicKey>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: PublicKey
    ): PublicKey {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.crypto.v30.SigningPublicKey signing_public_key */ 1:
                    message.key = {
                        oneofKind: 'signingPublicKey',
                        signingPublicKey: SigningPublicKey.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.key as any).signingPublicKey
                        ),
                    }
                    break
                case /* com.digitalasset.canton.crypto.v30.EncryptionPublicKey encryption_public_key */ 2:
                    message.key = {
                        oneofKind: 'encryptionPublicKey',
                        encryptionPublicKey:
                            EncryptionPublicKey.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                (message.key as any).encryptionPublicKey
                            ),
                    }
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: PublicKey,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.crypto.v30.SigningPublicKey signing_public_key = 1; */
        if (message.key.oneofKind === 'signingPublicKey')
            SigningPublicKey.internalBinaryWrite(
                message.key.signingPublicKey,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.crypto.v30.EncryptionPublicKey encryption_public_key = 2; */
        if (message.key.oneofKind === 'encryptionPublicKey')
            EncryptionPublicKey.internalBinaryWrite(
                message.key.encryptionPublicKey,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.PublicKey
 */
export const PublicKey = new PublicKey$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PublicKeyWithName$Type extends MessageType<PublicKeyWithName> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.PublicKeyWithName', [
            { no: 1, name: 'public_key', kind: 'message', T: () => PublicKey },
            { no: 2, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
        ])
    }
    create(value?: PartialMessage<PublicKeyWithName>): PublicKeyWithName {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.name = ''
        if (value !== undefined)
            reflectionMergePartial<PublicKeyWithName>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: PublicKeyWithName
    ): PublicKeyWithName {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.crypto.v30.PublicKey public_key */ 1:
                    message.publicKey = PublicKey.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.publicKey
                    )
                    break
                case /* string name */ 2:
                    message.name = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: PublicKeyWithName,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.crypto.v30.PublicKey public_key = 1; */
        if (message.publicKey)
            PublicKey.internalBinaryWrite(
                message.publicKey,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* string name = 2; */
        if (message.name !== '')
            writer.tag(2, WireType.LengthDelimited).string(message.name)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.PublicKeyWithName
 */
export const PublicKeyWithName = new PublicKeyWithName$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PrivateKey$Type extends MessageType<PrivateKey> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.PrivateKey', [
            {
                no: 1,
                name: 'signing_private_key',
                kind: 'message',
                oneof: 'key',
                T: () => SigningPrivateKey,
            },
            {
                no: 2,
                name: 'encryption_private_key',
                kind: 'message',
                oneof: 'key',
                T: () => EncryptionPrivateKey,
            },
        ])
    }
    create(value?: PartialMessage<PrivateKey>): PrivateKey {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.key = { oneofKind: undefined }
        if (value !== undefined)
            reflectionMergePartial<PrivateKey>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: PrivateKey
    ): PrivateKey {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.crypto.v30.SigningPrivateKey signing_private_key */ 1:
                    message.key = {
                        oneofKind: 'signingPrivateKey',
                        signingPrivateKey: SigningPrivateKey.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.key as any).signingPrivateKey
                        ),
                    }
                    break
                case /* com.digitalasset.canton.crypto.v30.EncryptionPrivateKey encryption_private_key */ 2:
                    message.key = {
                        oneofKind: 'encryptionPrivateKey',
                        encryptionPrivateKey:
                            EncryptionPrivateKey.internalBinaryRead(
                                reader,
                                reader.uint32(),
                                options,
                                (message.key as any).encryptionPrivateKey
                            ),
                    }
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: PrivateKey,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.crypto.v30.SigningPrivateKey signing_private_key = 1; */
        if (message.key.oneofKind === 'signingPrivateKey')
            SigningPrivateKey.internalBinaryWrite(
                message.key.signingPrivateKey,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.crypto.v30.EncryptionPrivateKey encryption_private_key = 2; */
        if (message.key.oneofKind === 'encryptionPrivateKey')
            EncryptionPrivateKey.internalBinaryWrite(
                message.key.encryptionPrivateKey,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.PrivateKey
 */
export const PrivateKey = new PrivateKey$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SigningPublicKey$Type extends MessageType<SigningPublicKey> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.SigningPublicKey', [
            {
                no: 2,
                name: 'format',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.CryptoKeyFormat',
                    CryptoKeyFormat,
                    'CRYPTO_KEY_FORMAT_',
                ],
            },
            {
                no: 3,
                name: 'public_key',
                kind: 'scalar',
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 4,
                name: 'scheme',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.SigningKeyScheme',
                    SigningKeyScheme,
                    'SIGNING_KEY_SCHEME_',
                ],
            },
            {
                no: 5,
                name: 'usage',
                kind: 'enum',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => [
                    'com.digitalasset.canton.crypto.v30.SigningKeyUsage',
                    SigningKeyUsage,
                    'SIGNING_KEY_USAGE_',
                ],
            },
            {
                no: 6,
                name: 'key_spec',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.SigningKeySpec',
                    SigningKeySpec,
                    'SIGNING_KEY_SPEC_',
                ],
            },
        ])
    }
    create(value?: PartialMessage<SigningPublicKey>): SigningPublicKey {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.format = 0
        message.publicKey = new Uint8Array(0)
        message.scheme = 0
        message.usage = []
        message.keySpec = 0
        if (value !== undefined)
            reflectionMergePartial<SigningPublicKey>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SigningPublicKey
    ): SigningPublicKey {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.crypto.v30.CryptoKeyFormat format */ 2:
                    message.format = reader.int32()
                    break
                case /* bytes public_key */ 3:
                    message.publicKey = reader.bytes()
                    break
                case /* com.digitalasset.canton.crypto.v30.SigningKeyScheme scheme = 4 [deprecated = true] */ 4:
                    message.scheme = reader.int32()
                    break
                case /* repeated com.digitalasset.canton.crypto.v30.SigningKeyUsage usage */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (
                            let e = reader.int32() + reader.pos;
                            reader.pos < e;

                        )
                            message.usage.push(reader.int32())
                    else message.usage.push(reader.int32())
                    break
                case /* com.digitalasset.canton.crypto.v30.SigningKeySpec key_spec */ 6:
                    message.keySpec = reader.int32()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: SigningPublicKey,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.crypto.v30.CryptoKeyFormat format = 2; */
        if (message.format !== 0)
            writer.tag(2, WireType.Varint).int32(message.format)
        /* bytes public_key = 3; */
        if (message.publicKey.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.publicKey)
        /* com.digitalasset.canton.crypto.v30.SigningKeyScheme scheme = 4 [deprecated = true]; */
        if (message.scheme !== 0)
            writer.tag(4, WireType.Varint).int32(message.scheme)
        /* repeated com.digitalasset.canton.crypto.v30.SigningKeyUsage usage = 5; */
        if (message.usage.length) {
            writer.tag(5, WireType.LengthDelimited).fork()
            for (let i = 0; i < message.usage.length; i++)
                writer.int32(message.usage[i])
            writer.join()
        }
        /* com.digitalasset.canton.crypto.v30.SigningKeySpec key_spec = 6; */
        if (message.keySpec !== 0)
            writer.tag(6, WireType.Varint).int32(message.keySpec)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.SigningPublicKey
 */
export const SigningPublicKey = new SigningPublicKey$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SigningPrivateKey$Type extends MessageType<SigningPrivateKey> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.SigningPrivateKey', [
            { no: 1, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            {
                no: 2,
                name: 'format',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.CryptoKeyFormat',
                    CryptoKeyFormat,
                    'CRYPTO_KEY_FORMAT_',
                ],
            },
            {
                no: 3,
                name: 'private_key',
                kind: 'scalar',
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 4,
                name: 'scheme',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.SigningKeyScheme',
                    SigningKeyScheme,
                    'SIGNING_KEY_SCHEME_',
                ],
            },
            {
                no: 5,
                name: 'usage',
                kind: 'enum',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => [
                    'com.digitalasset.canton.crypto.v30.SigningKeyUsage',
                    SigningKeyUsage,
                    'SIGNING_KEY_USAGE_',
                ],
            },
            {
                no: 6,
                name: 'key_spec',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.SigningKeySpec',
                    SigningKeySpec,
                    'SIGNING_KEY_SPEC_',
                ],
            },
        ])
    }
    create(value?: PartialMessage<SigningPrivateKey>): SigningPrivateKey {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.id = ''
        message.format = 0
        message.privateKey = new Uint8Array(0)
        message.scheme = 0
        message.usage = []
        message.keySpec = 0
        if (value !== undefined)
            reflectionMergePartial<SigningPrivateKey>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SigningPrivateKey
    ): SigningPrivateKey {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string()
                    break
                case /* com.digitalasset.canton.crypto.v30.CryptoKeyFormat format */ 2:
                    message.format = reader.int32()
                    break
                case /* bytes private_key */ 3:
                    message.privateKey = reader.bytes()
                    break
                case /* com.digitalasset.canton.crypto.v30.SigningKeyScheme scheme = 4 [deprecated = true] */ 4:
                    message.scheme = reader.int32()
                    break
                case /* repeated com.digitalasset.canton.crypto.v30.SigningKeyUsage usage */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (
                            let e = reader.int32() + reader.pos;
                            reader.pos < e;

                        )
                            message.usage.push(reader.int32())
                    else message.usage.push(reader.int32())
                    break
                case /* com.digitalasset.canton.crypto.v30.SigningKeySpec key_spec */ 6:
                    message.keySpec = reader.int32()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: SigningPrivateKey,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.id)
        /* com.digitalasset.canton.crypto.v30.CryptoKeyFormat format = 2; */
        if (message.format !== 0)
            writer.tag(2, WireType.Varint).int32(message.format)
        /* bytes private_key = 3; */
        if (message.privateKey.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.privateKey)
        /* com.digitalasset.canton.crypto.v30.SigningKeyScheme scheme = 4 [deprecated = true]; */
        if (message.scheme !== 0)
            writer.tag(4, WireType.Varint).int32(message.scheme)
        /* repeated com.digitalasset.canton.crypto.v30.SigningKeyUsage usage = 5; */
        if (message.usage.length) {
            writer.tag(5, WireType.LengthDelimited).fork()
            for (let i = 0; i < message.usage.length; i++)
                writer.int32(message.usage[i])
            writer.join()
        }
        /* com.digitalasset.canton.crypto.v30.SigningKeySpec key_spec = 6; */
        if (message.keySpec !== 0)
            writer.tag(6, WireType.Varint).int32(message.keySpec)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.SigningPrivateKey
 */
export const SigningPrivateKey = new SigningPrivateKey$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SigningKeyPair$Type extends MessageType<SigningKeyPair> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.SigningKeyPair', [
            {
                no: 1,
                name: 'public_key',
                kind: 'message',
                T: () => SigningPublicKey,
            },
            {
                no: 2,
                name: 'private_key',
                kind: 'message',
                T: () => SigningPrivateKey,
            },
        ])
    }
    create(value?: PartialMessage<SigningKeyPair>): SigningKeyPair {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<SigningKeyPair>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SigningKeyPair
    ): SigningKeyPair {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.crypto.v30.SigningPublicKey public_key */ 1:
                    message.publicKey = SigningPublicKey.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.publicKey
                    )
                    break
                case /* com.digitalasset.canton.crypto.v30.SigningPrivateKey private_key */ 2:
                    message.privateKey = SigningPrivateKey.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.privateKey
                    )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: SigningKeyPair,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.crypto.v30.SigningPublicKey public_key = 1; */
        if (message.publicKey)
            SigningPublicKey.internalBinaryWrite(
                message.publicKey,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.crypto.v30.SigningPrivateKey private_key = 2; */
        if (message.privateKey)
            SigningPrivateKey.internalBinaryWrite(
                message.privateKey,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.SigningKeyPair
 */
export const SigningKeyPair = new SigningKeyPair$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RequiredSigningSpecs$Type extends MessageType<RequiredSigningSpecs> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.RequiredSigningSpecs', [
            {
                no: 1,
                name: 'algorithms',
                kind: 'enum',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => [
                    'com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec',
                    SigningAlgorithmSpec,
                    'SIGNING_ALGORITHM_SPEC_',
                ],
            },
            {
                no: 2,
                name: 'keys',
                kind: 'enum',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => [
                    'com.digitalasset.canton.crypto.v30.SigningKeySpec',
                    SigningKeySpec,
                    'SIGNING_KEY_SPEC_',
                ],
            },
        ])
    }
    create(value?: PartialMessage<RequiredSigningSpecs>): RequiredSigningSpecs {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.algorithms = []
        message.keys = []
        if (value !== undefined)
            reflectionMergePartial<RequiredSigningSpecs>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RequiredSigningSpecs
    ): RequiredSigningSpecs {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec algorithms */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (
                            let e = reader.int32() + reader.pos;
                            reader.pos < e;

                        )
                            message.algorithms.push(reader.int32())
                    else message.algorithms.push(reader.int32())
                    break
                case /* repeated com.digitalasset.canton.crypto.v30.SigningKeySpec keys */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (
                            let e = reader.int32() + reader.pos;
                            reader.pos < e;

                        )
                            message.keys.push(reader.int32())
                    else message.keys.push(reader.int32())
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: RequiredSigningSpecs,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated com.digitalasset.canton.crypto.v30.SigningAlgorithmSpec algorithms = 1; */
        if (message.algorithms.length) {
            writer.tag(1, WireType.LengthDelimited).fork()
            for (let i = 0; i < message.algorithms.length; i++)
                writer.int32(message.algorithms[i])
            writer.join()
        }
        /* repeated com.digitalasset.canton.crypto.v30.SigningKeySpec keys = 2; */
        if (message.keys.length) {
            writer.tag(2, WireType.LengthDelimited).fork()
            for (let i = 0; i < message.keys.length; i++)
                writer.int32(message.keys[i])
            writer.join()
        }
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.RequiredSigningSpecs
 */
export const RequiredSigningSpecs = new RequiredSigningSpecs$Type()
// @generated message type with reflection information, may provide speed optimized methods
class EncryptionPublicKey$Type extends MessageType<EncryptionPublicKey> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.EncryptionPublicKey', [
            {
                no: 2,
                name: 'format',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.CryptoKeyFormat',
                    CryptoKeyFormat,
                    'CRYPTO_KEY_FORMAT_',
                ],
            },
            {
                no: 3,
                name: 'public_key',
                kind: 'scalar',
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 4,
                name: 'scheme',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.EncryptionKeyScheme',
                    EncryptionKeyScheme,
                    'ENCRYPTION_KEY_SCHEME_',
                ],
            },
            {
                no: 5,
                name: 'key_spec',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.EncryptionKeySpec',
                    EncryptionKeySpec,
                    'ENCRYPTION_KEY_SPEC_',
                ],
            },
        ])
    }
    create(value?: PartialMessage<EncryptionPublicKey>): EncryptionPublicKey {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.format = 0
        message.publicKey = new Uint8Array(0)
        message.scheme = 0
        message.keySpec = 0
        if (value !== undefined)
            reflectionMergePartial<EncryptionPublicKey>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: EncryptionPublicKey
    ): EncryptionPublicKey {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.crypto.v30.CryptoKeyFormat format */ 2:
                    message.format = reader.int32()
                    break
                case /* bytes public_key */ 3:
                    message.publicKey = reader.bytes()
                    break
                case /* com.digitalasset.canton.crypto.v30.EncryptionKeyScheme scheme = 4 [deprecated = true] */ 4:
                    message.scheme = reader.int32()
                    break
                case /* com.digitalasset.canton.crypto.v30.EncryptionKeySpec key_spec */ 5:
                    message.keySpec = reader.int32()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: EncryptionPublicKey,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.crypto.v30.CryptoKeyFormat format = 2; */
        if (message.format !== 0)
            writer.tag(2, WireType.Varint).int32(message.format)
        /* bytes public_key = 3; */
        if (message.publicKey.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.publicKey)
        /* com.digitalasset.canton.crypto.v30.EncryptionKeyScheme scheme = 4 [deprecated = true]; */
        if (message.scheme !== 0)
            writer.tag(4, WireType.Varint).int32(message.scheme)
        /* com.digitalasset.canton.crypto.v30.EncryptionKeySpec key_spec = 5; */
        if (message.keySpec !== 0)
            writer.tag(5, WireType.Varint).int32(message.keySpec)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.EncryptionPublicKey
 */
export const EncryptionPublicKey = new EncryptionPublicKey$Type()
// @generated message type with reflection information, may provide speed optimized methods
class EncryptionPrivateKey$Type extends MessageType<EncryptionPrivateKey> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.EncryptionPrivateKey', [
            { no: 1, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
            {
                no: 2,
                name: 'format',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.CryptoKeyFormat',
                    CryptoKeyFormat,
                    'CRYPTO_KEY_FORMAT_',
                ],
            },
            {
                no: 3,
                name: 'private_key',
                kind: 'scalar',
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 4,
                name: 'scheme',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.EncryptionKeyScheme',
                    EncryptionKeyScheme,
                    'ENCRYPTION_KEY_SCHEME_',
                ],
            },
            {
                no: 5,
                name: 'key_spec',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.EncryptionKeySpec',
                    EncryptionKeySpec,
                    'ENCRYPTION_KEY_SPEC_',
                ],
            },
        ])
    }
    create(value?: PartialMessage<EncryptionPrivateKey>): EncryptionPrivateKey {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.id = ''
        message.format = 0
        message.privateKey = new Uint8Array(0)
        message.scheme = 0
        message.keySpec = 0
        if (value !== undefined)
            reflectionMergePartial<EncryptionPrivateKey>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: EncryptionPrivateKey
    ): EncryptionPrivateKey {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string()
                    break
                case /* com.digitalasset.canton.crypto.v30.CryptoKeyFormat format */ 2:
                    message.format = reader.int32()
                    break
                case /* bytes private_key */ 3:
                    message.privateKey = reader.bytes()
                    break
                case /* com.digitalasset.canton.crypto.v30.EncryptionKeyScheme scheme = 4 [deprecated = true] */ 4:
                    message.scheme = reader.int32()
                    break
                case /* com.digitalasset.canton.crypto.v30.EncryptionKeySpec key_spec */ 5:
                    message.keySpec = reader.int32()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: EncryptionPrivateKey,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== '')
            writer.tag(1, WireType.LengthDelimited).string(message.id)
        /* com.digitalasset.canton.crypto.v30.CryptoKeyFormat format = 2; */
        if (message.format !== 0)
            writer.tag(2, WireType.Varint).int32(message.format)
        /* bytes private_key = 3; */
        if (message.privateKey.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.privateKey)
        /* com.digitalasset.canton.crypto.v30.EncryptionKeyScheme scheme = 4 [deprecated = true]; */
        if (message.scheme !== 0)
            writer.tag(4, WireType.Varint).int32(message.scheme)
        /* com.digitalasset.canton.crypto.v30.EncryptionKeySpec key_spec = 5; */
        if (message.keySpec !== 0)
            writer.tag(5, WireType.Varint).int32(message.keySpec)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.EncryptionPrivateKey
 */
export const EncryptionPrivateKey = new EncryptionPrivateKey$Type()
// @generated message type with reflection information, may provide speed optimized methods
class EncryptionKeyPair$Type extends MessageType<EncryptionKeyPair> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.EncryptionKeyPair', [
            {
                no: 1,
                name: 'public_key',
                kind: 'message',
                T: () => EncryptionPublicKey,
            },
            {
                no: 2,
                name: 'private_key',
                kind: 'message',
                T: () => EncryptionPrivateKey,
            },
        ])
    }
    create(value?: PartialMessage<EncryptionKeyPair>): EncryptionKeyPair {
        const message = globalThis.Object.create(this.messagePrototype!)
        if (value !== undefined)
            reflectionMergePartial<EncryptionKeyPair>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: EncryptionKeyPair
    ): EncryptionKeyPair {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.crypto.v30.EncryptionPublicKey public_key */ 1:
                    message.publicKey = EncryptionPublicKey.internalBinaryRead(
                        reader,
                        reader.uint32(),
                        options,
                        message.publicKey
                    )
                    break
                case /* com.digitalasset.canton.crypto.v30.EncryptionPrivateKey private_key */ 2:
                    message.privateKey =
                        EncryptionPrivateKey.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            message.privateKey
                        )
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: EncryptionKeyPair,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.crypto.v30.EncryptionPublicKey public_key = 1; */
        if (message.publicKey)
            EncryptionPublicKey.internalBinaryWrite(
                message.publicKey,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.crypto.v30.EncryptionPrivateKey private_key = 2; */
        if (message.privateKey)
            EncryptionPrivateKey.internalBinaryWrite(
                message.privateKey,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.EncryptionKeyPair
 */
export const EncryptionKeyPair = new EncryptionKeyPair$Type()
// @generated message type with reflection information, may provide speed optimized methods
class RequiredEncryptionSpecs$Type extends MessageType<RequiredEncryptionSpecs> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.RequiredEncryptionSpecs', [
            {
                no: 1,
                name: 'algorithms',
                kind: 'enum',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => [
                    'com.digitalasset.canton.crypto.v30.EncryptionAlgorithmSpec',
                    EncryptionAlgorithmSpec,
                    'ENCRYPTION_ALGORITHM_SPEC_',
                ],
            },
            {
                no: 2,
                name: 'keys',
                kind: 'enum',
                repeat: 1 /*RepeatType.PACKED*/,
                T: () => [
                    'com.digitalasset.canton.crypto.v30.EncryptionKeySpec',
                    EncryptionKeySpec,
                    'ENCRYPTION_KEY_SPEC_',
                ],
            },
        ])
    }
    create(
        value?: PartialMessage<RequiredEncryptionSpecs>
    ): RequiredEncryptionSpecs {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.algorithms = []
        message.keys = []
        if (value !== undefined)
            reflectionMergePartial<RequiredEncryptionSpecs>(
                this,
                message,
                value
            )
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: RequiredEncryptionSpecs
    ): RequiredEncryptionSpecs {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* repeated com.digitalasset.canton.crypto.v30.EncryptionAlgorithmSpec algorithms */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (
                            let e = reader.int32() + reader.pos;
                            reader.pos < e;

                        )
                            message.algorithms.push(reader.int32())
                    else message.algorithms.push(reader.int32())
                    break
                case /* repeated com.digitalasset.canton.crypto.v30.EncryptionKeySpec keys */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (
                            let e = reader.int32() + reader.pos;
                            reader.pos < e;

                        )
                            message.keys.push(reader.int32())
                    else message.keys.push(reader.int32())
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: RequiredEncryptionSpecs,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* repeated com.digitalasset.canton.crypto.v30.EncryptionAlgorithmSpec algorithms = 1; */
        if (message.algorithms.length) {
            writer.tag(1, WireType.LengthDelimited).fork()
            for (let i = 0; i < message.algorithms.length; i++)
                writer.int32(message.algorithms[i])
            writer.join()
        }
        /* repeated com.digitalasset.canton.crypto.v30.EncryptionKeySpec keys = 2; */
        if (message.keys.length) {
            writer.tag(2, WireType.LengthDelimited).fork()
            for (let i = 0; i < message.keys.length; i++)
                writer.int32(message.keys[i])
            writer.join()
        }
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.RequiredEncryptionSpecs
 */
export const RequiredEncryptionSpecs = new RequiredEncryptionSpecs$Type()
// @generated message type with reflection information, may provide speed optimized methods
class CryptoKeyPair$Type extends MessageType<CryptoKeyPair> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.CryptoKeyPair', [
            {
                no: 1,
                name: 'signing_key_pair',
                kind: 'message',
                oneof: 'pair',
                T: () => SigningKeyPair,
            },
            {
                no: 2,
                name: 'encryption_key_pair',
                kind: 'message',
                oneof: 'pair',
                T: () => EncryptionKeyPair,
            },
        ])
    }
    create(value?: PartialMessage<CryptoKeyPair>): CryptoKeyPair {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.pair = { oneofKind: undefined }
        if (value !== undefined)
            reflectionMergePartial<CryptoKeyPair>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: CryptoKeyPair
    ): CryptoKeyPair {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.crypto.v30.SigningKeyPair signing_key_pair */ 1:
                    message.pair = {
                        oneofKind: 'signingKeyPair',
                        signingKeyPair: SigningKeyPair.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.pair as any).signingKeyPair
                        ),
                    }
                    break
                case /* com.digitalasset.canton.crypto.v30.EncryptionKeyPair encryption_key_pair */ 2:
                    message.pair = {
                        oneofKind: 'encryptionKeyPair',
                        encryptionKeyPair: EncryptionKeyPair.internalBinaryRead(
                            reader,
                            reader.uint32(),
                            options,
                            (message.pair as any).encryptionKeyPair
                        ),
                    }
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: CryptoKeyPair,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.crypto.v30.SigningKeyPair signing_key_pair = 1; */
        if (message.pair.oneofKind === 'signingKeyPair')
            SigningKeyPair.internalBinaryWrite(
                message.pair.signingKeyPair,
                writer.tag(1, WireType.LengthDelimited).fork(),
                options
            ).join()
        /* com.digitalasset.canton.crypto.v30.EncryptionKeyPair encryption_key_pair = 2; */
        if (message.pair.oneofKind === 'encryptionKeyPair')
            EncryptionKeyPair.internalBinaryWrite(
                message.pair.encryptionKeyPair,
                writer.tag(2, WireType.LengthDelimited).fork(),
                options
            ).join()
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.CryptoKeyPair
 */
export const CryptoKeyPair = new CryptoKeyPair$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SymmetricKey$Type extends MessageType<SymmetricKey> {
    constructor() {
        super(
            'com.digitalasset.canton.crypto.v30.SymmetricKey',
            [
                {
                    no: 1,
                    name: 'format',
                    kind: 'enum',
                    T: () => [
                        'com.digitalasset.canton.crypto.v30.CryptoKeyFormat',
                        CryptoKeyFormat,
                        'CRYPTO_KEY_FORMAT_',
                    ],
                },
                {
                    no: 2,
                    name: 'key',
                    kind: 'scalar',
                    T: 12 /*ScalarType.BYTES*/,
                },
                {
                    no: 3,
                    name: 'scheme',
                    kind: 'enum',
                    T: () => [
                        'com.digitalasset.canton.crypto.v30.SymmetricKeyScheme',
                        SymmetricKeyScheme,
                        'SYMMETRIC_KEY_SCHEME_',
                    ],
                },
            ],
            {
                'scalapb.message': {
                    companionExtends: [
                        'com.digitalasset.canton.version.StableProtoVersion',
                    ],
                },
            }
        )
    }
    create(value?: PartialMessage<SymmetricKey>): SymmetricKey {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.format = 0
        message.key = new Uint8Array(0)
        message.scheme = 0
        if (value !== undefined)
            reflectionMergePartial<SymmetricKey>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: SymmetricKey
    ): SymmetricKey {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* com.digitalasset.canton.crypto.v30.CryptoKeyFormat format */ 1:
                    message.format = reader.int32()
                    break
                case /* bytes key */ 2:
                    message.key = reader.bytes()
                    break
                case /* com.digitalasset.canton.crypto.v30.SymmetricKeyScheme scheme */ 3:
                    message.scheme = reader.int32()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: SymmetricKey,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* com.digitalasset.canton.crypto.v30.CryptoKeyFormat format = 1; */
        if (message.format !== 0)
            writer.tag(1, WireType.Varint).int32(message.format)
        /* bytes key = 2; */
        if (message.key.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.key)
        /* com.digitalasset.canton.crypto.v30.SymmetricKeyScheme scheme = 3; */
        if (message.scheme !== 0)
            writer.tag(3, WireType.Varint).int32(message.scheme)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.SymmetricKey
 */
export const SymmetricKey = new SymmetricKey$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PasswordBasedEncrypted$Type extends MessageType<PasswordBasedEncrypted> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.PasswordBasedEncrypted', [
            {
                no: 1,
                name: 'ciphertext',
                kind: 'scalar',
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 2,
                name: 'symmetric_key_scheme',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.SymmetricKeyScheme',
                    SymmetricKeyScheme,
                    'SYMMETRIC_KEY_SCHEME_',
                ],
            },
            {
                no: 3,
                name: 'pbkdf_scheme',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.PbkdfScheme',
                    PbkdfScheme,
                    'PBKDF_SCHEME_',
                ],
            },
            { no: 4, name: 'salt', kind: 'scalar', T: 12 /*ScalarType.BYTES*/ },
        ])
    }
    create(
        value?: PartialMessage<PasswordBasedEncrypted>
    ): PasswordBasedEncrypted {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.ciphertext = new Uint8Array(0)
        message.symmetricKeyScheme = 0
        message.pbkdfScheme = 0
        message.salt = new Uint8Array(0)
        if (value !== undefined)
            reflectionMergePartial<PasswordBasedEncrypted>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: PasswordBasedEncrypted
    ): PasswordBasedEncrypted {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* bytes ciphertext */ 1:
                    message.ciphertext = reader.bytes()
                    break
                case /* com.digitalasset.canton.crypto.v30.SymmetricKeyScheme symmetric_key_scheme */ 2:
                    message.symmetricKeyScheme = reader.int32()
                    break
                case /* com.digitalasset.canton.crypto.v30.PbkdfScheme pbkdf_scheme */ 3:
                    message.pbkdfScheme = reader.int32()
                    break
                case /* bytes salt */ 4:
                    message.salt = reader.bytes()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: PasswordBasedEncrypted,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* bytes ciphertext = 1; */
        if (message.ciphertext.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.ciphertext)
        /* com.digitalasset.canton.crypto.v30.SymmetricKeyScheme symmetric_key_scheme = 2; */
        if (message.symmetricKeyScheme !== 0)
            writer.tag(2, WireType.Varint).int32(message.symmetricKeyScheme)
        /* com.digitalasset.canton.crypto.v30.PbkdfScheme pbkdf_scheme = 3; */
        if (message.pbkdfScheme !== 0)
            writer.tag(3, WireType.Varint).int32(message.pbkdfScheme)
        /* bytes salt = 4; */
        if (message.salt.length)
            writer.tag(4, WireType.LengthDelimited).bytes(message.salt)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.PasswordBasedEncrypted
 */
export const PasswordBasedEncrypted = new PasswordBasedEncrypted$Type()
// @generated message type with reflection information, may provide speed optimized methods
class AsymmetricEncrypted$Type extends MessageType<AsymmetricEncrypted> {
    constructor() {
        super('com.digitalasset.canton.crypto.v30.AsymmetricEncrypted', [
            {
                no: 1,
                name: 'ciphertext',
                kind: 'scalar',
                T: 12 /*ScalarType.BYTES*/,
            },
            {
                no: 2,
                name: 'encryption_algorithm_spec',
                kind: 'enum',
                T: () => [
                    'com.digitalasset.canton.crypto.v30.EncryptionAlgorithmSpec',
                    EncryptionAlgorithmSpec,
                    'ENCRYPTION_ALGORITHM_SPEC_',
                ],
            },
            {
                no: 3,
                name: 'fingerprint',
                kind: 'scalar',
                T: 9 /*ScalarType.STRING*/,
            },
        ])
    }
    create(value?: PartialMessage<AsymmetricEncrypted>): AsymmetricEncrypted {
        const message = globalThis.Object.create(this.messagePrototype!)
        message.ciphertext = new Uint8Array(0)
        message.encryptionAlgorithmSpec = 0
        message.fingerprint = ''
        if (value !== undefined)
            reflectionMergePartial<AsymmetricEncrypted>(this, message, value)
        return message
    }
    internalBinaryRead(
        reader: IBinaryReader,
        length: number,
        options: BinaryReadOptions,
        target?: AsymmetricEncrypted
    ): AsymmetricEncrypted {
        let message = target ?? this.create(),
            end = reader.pos + length
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag()
            switch (fieldNo) {
                case /* bytes ciphertext */ 1:
                    message.ciphertext = reader.bytes()
                    break
                case /* com.digitalasset.canton.crypto.v30.EncryptionAlgorithmSpec encryption_algorithm_spec */ 2:
                    message.encryptionAlgorithmSpec = reader.int32()
                    break
                case /* string fingerprint */ 3:
                    message.fingerprint = reader.string()
                    break
                default:
                    let u = options.readUnknownField
                    if (u === 'throw')
                        throw new globalThis.Error(
                            `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`
                        )
                    let d = reader.skip(wireType)
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(
                            this.typeName,
                            message,
                            fieldNo,
                            wireType,
                            d
                        )
            }
        }
        return message
    }
    internalBinaryWrite(
        message: AsymmetricEncrypted,
        writer: IBinaryWriter,
        options: BinaryWriteOptions
    ): IBinaryWriter {
        /* bytes ciphertext = 1; */
        if (message.ciphertext.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.ciphertext)
        /* com.digitalasset.canton.crypto.v30.EncryptionAlgorithmSpec encryption_algorithm_spec = 2; */
        if (message.encryptionAlgorithmSpec !== 0)
            writer
                .tag(2, WireType.Varint)
                .int32(message.encryptionAlgorithmSpec)
        /* string fingerprint = 3; */
        if (message.fingerprint !== '')
            writer.tag(3, WireType.LengthDelimited).string(message.fingerprint)
        let u = options.writeUnknownFields
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(
                this.typeName,
                message,
                writer
            )
        return writer
    }
}
/**
 * @generated MessageType for protobuf message com.digitalasset.canton.crypto.v30.AsymmetricEncrypted
 */
export const AsymmetricEncrypted = new AsymmetricEncrypted$Type()
